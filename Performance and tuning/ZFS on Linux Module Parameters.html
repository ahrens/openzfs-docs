
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>ZFS on Linux Module Parameters &#8212; OpenZFS  documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="ZFS I/O (ZIO) Scheduler" href="ZIO Scheduler.html" />
    <link rel="prev" title="ZFS Transaction Delay" href="ZFS Transaction Delay.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="zfs-on-linux-module-parameters">
<h1>ZFS on Linux Module Parameters<a class="headerlink" href="#zfs-on-linux-module-parameters" title="Permalink to this headline">¶</a></h1>
<p>Most of the ZFS kernel module parameters are accessible in the SysFS
<code class="docutils literal notranslate"><span class="pre">/sys/module/zfs/paramaters</span></code> directory. Current value can be observed
by</p>
<div class="code shell highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cat</span> <span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">module</span><span class="o">/</span><span class="n">zfs</span><span class="o">/</span><span class="n">parameters</span><span class="o">/</span><span class="n">PARAMETER</span>
</pre></div>
</div>
<p>Many of these can be changed by writing new values. These are denoted by
Change|Dynamic in the PARAMETER details below.</p>
<div class="code shell highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">echo</span> <span class="n">NEWVALUE</span> <span class="o">&gt;&gt;</span> <span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">module</span><span class="o">/</span><span class="n">zfs</span><span class="o">/</span><span class="n">parameters</span><span class="o">/</span><span class="n">PARAMETER</span>
</pre></div>
</div>
<p>If the parameter is not dynamically adjustable, an error can occur and
the value will not be set. It can be helpful to check the permissions
for the PARAMETER file in SysFS.</p>
<p>In some cases, the parameter must be set prior to loading the kernel
modules or it is desired to have the parameters set automatically at
boot time. For many distros, this can be accomplished by creating a file
named <code class="docutils literal notranslate"><span class="pre">/etc/modprobe.d/zfs.conf</span></code> containing a text line for each
module parameter using the format:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># change PARAMETER for workload XZY to solve problem PROBLEM_DESCRIPTION</span>
<span class="c1"># changed by YOUR_NAME on DATE</span>
<span class="n">options</span> <span class="n">zfs</span> <span class="n">PARAMETER</span><span class="o">=</span><span class="n">VALUE</span>
</pre></div>
</div>
<p>Some parameters related to ZFS operations are located in module
parameters other than in the <code class="docutils literal notranslate"><span class="pre">zfs</span></code> kernel module. These are documented
in the individual parameter description. Unless otherwise noted, the
tunable applies to the <code class="docutils literal notranslate"><span class="pre">zfs</span></code> kernel module. For example, the <code class="docutils literal notranslate"><span class="pre">icp</span></code>
kernel module parameters are visible in the
<code class="docutils literal notranslate"><span class="pre">/sys/module/icp/parameters</span></code> directory and can be set by default at
boot time by changing the <code class="docutils literal notranslate"><span class="pre">/etc/modprobe.d/icp.conf</span></code> file.</p>
<p>See the man page for <em>modprobe.d</em> for more information.</p>
<div class="section" id="zfs-module-parameters-manual-page">
<h2>zfs-module-parameters Manual Page<a class="headerlink" href="#zfs-module-parameters-manual-page" title="Permalink to this headline">¶</a></h2>
<p>The <em>zfs-module-parameters(5)</em> man page contains brief descriptions of
the module parameters. Alas, man pages are not as suitable for quick
reference as wiki pages. This wiki page is intended to be a better
cross-reference and capture some of the wisdom of ZFS developers and
practitioners.</p>
</div>
<div class="section" id="zfs-module-parameters">
<h2>ZFS Module Parameters<a class="headerlink" href="#zfs-module-parameters" title="Permalink to this headline">¶</a></h2>
<p>The ZFS kernel module, <code class="docutils literal notranslate"><span class="pre">zfs.ko</span></code>, parameters are detailed below.</p>
<p>To observe the list of parameters along with a short synopsis of each
parameter, use the <code class="docutils literal notranslate"><span class="pre">modinfo</span></code> command:</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">modinfo</span> <span class="n">zfs</span>
</pre></div>
</div>
</div>
<div class="section" id="tags">
<h2>Tags<a class="headerlink" href="#tags" title="Permalink to this headline">¶</a></h2>
<p>The list of parameters is quite large and resists hierarchical
representation. To assist in quickly finding relevant information
quickly, each module parameter has a “Tags” row with keywords for
frequent searches.</p>
<div class="section" id="abd">
<h3>ABD<a class="headerlink" href="#abd" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-abd-scatter-enabled">zfs_abd_scatter_enabled</a></li>
<li><a class="reference external" href="#zfs-abd-scatter-max-order">zfs_abd_scatter_max_order</a></li>
<li><a class="reference external" href="#zfs-compressed-arc-enabled">zfs_compressed_arc_enabled</a></li>
</ul>
</div>
<div class="section" id="allocation">
<h3>allocation<a class="headerlink" href="#allocation" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#dmu-object-alloc-chunk-shift">dmu_object_alloc_chunk_shift</a></li>
<li><a class="reference external" href="#metaslab-aliquot">metaslab_aliquot</a></li>
<li><a class="reference external" href="#metaslab-bias-enabled">metaslab_bias_enabled</a></li>
<li><a class="reference external" href="#metaslab-debug-load">metaslab_debug_load</a></li>
<li><a class="reference external" href="#metaslab-debug-unload">metaslab_debug_unload</a></li>
<li><a class="reference external" href="#metaslab-force-ganging">metaslab_force_ganging</a></li>
<li><a class="reference external" href="#metaslab-fragmentation-factor-enabled">metaslab_fragmentation_factor_enabled</a></li>
<li><a class="reference external" href="#zfs-metaslab-fragmentation-threshold">zfs_metaslab_fragmentation_threshold</a></li>
<li><a class="reference external" href="#metaslab-lba-weighting-enabled">metaslab_lba_weighting_enabled</a></li>
<li><a class="reference external" href="#metaslab-preload-enabled">metaslab_preload_enabled</a></li>
<li><a class="reference external" href="#zfs-metaslab-segment-weight-enabled">zfs_metaslab_segment_weight_enabled</a></li>
<li><a class="reference external" href="#zfs-metaslab-switch-threshold">zfs_metaslab_switch_threshold</a></li>
<li><a class="reference external" href="#metaslabs-per-vdev">metaslabs_per_vdev</a></li>
<li><a class="reference external" href="#zfs-mg-fragmentation-threshold">zfs_mg_fragmentation_threshold</a></li>
<li><a class="reference external" href="#zfs-mg-noalloc-threshold">zfs_mg_noalloc_threshold</a></li>
<li><a class="reference external" href="#spa-asize-inflation">spa_asize_inflation</a></li>
<li><a class="reference external" href="#spa-load-verify-data">spa_load_verify_data</a></li>
<li><a class="reference external" href="#spa-slop-shift">spa_slop_shift</a></li>
<li><a class="reference external" href="#zfs-vdev-default-ms-count">zfs_vdev_default_ms_count</a></li>
</ul>
</div>
<div class="section" id="arc">
<h3>ARC<a class="headerlink" href="#arc" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-abd-scatter-min-size">zfs_abd_scatter_min_size</a></li>
<li><a class="reference external" href="#zfs-arc-average-blocksize">zfs_arc_average_blocksize</a></li>
<li><a class="reference external" href="#zfs-arc-dnode-limit">zfs_arc_dnode_limit</a></li>
<li><a class="reference external" href="#zfs-arc-dnode-limit-percent">zfs_arc_dnode_limit_percent</a></li>
<li><a class="reference external" href="#zfs-arc-dnode-reduce-percent">zfs_arc_dnode_reduce_percent</a></li>
<li><a class="reference external" href="#zfs-arc-evict-batch-limit">zfs_arc_evict_batch_limit</a></li>
<li><a class="reference external" href="#zfs-arc-grow-retry">zfs_arc_grow_retry</a></li>
<li><a class="reference external" href="#zfs-arc-lotsfree-percent">zfs_arc_lotsfree_percent</a></li>
<li><a class="reference external" href="#zfs-arc-max">zfs_arc_max</a></li>
<li><a class="reference external" href="#zfs-arc-meta-adjust-restarts">zfs_arc_meta_adjust_restarts</a></li>
<li><a class="reference external" href="#zfs-arc-meta-limit">zfs_arc_meta_limit</a></li>
<li><a class="reference external" href="#zfs-arc-meta-limit-percent">zfs_arc_meta_limit_percent</a></li>
<li><a class="reference external" href="#zfs-arc-meta-min">zfs_arc_meta_min</a></li>
<li><a class="reference external" href="#zfs-arc-meta-prune">zfs_arc_meta_prune</a></li>
<li><a class="reference external" href="#zfs-arc-meta-strategy">zfs_arc_meta_strategy</a></li>
<li><a class="reference external" href="#zfs-arc-min">zfs_arc_min</a></li>
<li><a class="reference external" href="#zfs-arc-min-prefetch-lifespan">zfs_arc_min_prefetch_lifespan</a></li>
<li><a class="reference external" href="#zfs-arc-min-prefetch-ms">zfs_arc_min_prefetch_ms</a></li>
<li><a class="reference external" href="#zfs-arc-min-prescient-prefetch-ms">zfs_arc_min_prescient_prefetch_ms</a></li>
<li><a class="reference external" href="#zfs-arc-overflow-shift">zfs_arc_overflow_shift</a></li>
<li><a class="reference external" href="#zfs-arc-p-dampener-disable">zfs_arc_p_dampener_disable</a></li>
<li><a class="reference external" href="#zfs-arc-p-min-shift">zfs_arc_p_min_shift</a></li>
<li><a class="reference external" href="#zfs-arc-pc-percent">zfs_arc_pc_percent</a></li>
<li><a class="reference external" href="#zfs-arc-shrink-shift">zfs_arc_shrink_shift</a></li>
<li><a class="reference external" href="#zfs-arc-sys-free">zfs_arc_sys_free</a></li>
<li><a class="reference external" href="#dbuf-cache-max-bytes">dbuf_cache_max_bytes</a></li>
<li><a class="reference external" href="#dbuf-cache-shift">dbuf_cache_shift</a></li>
<li><a class="reference external" href="#dbuf-metadata-cache-shift">dbuf_metadata_cache_shift</a></li>
<li><a class="reference external" href="#zfs-disable-dup-eviction">zfs_disable_dup_eviction</a></li>
<li><a class="reference external" href="#l2arc-feed-again">l2arc_feed_again</a></li>
<li><a class="reference external" href="#l2arc-feed-min-ms">l2arc_feed_min_ms</a></li>
<li><a class="reference external" href="#l2arc-feed-secs">l2arc_feed_secs</a></li>
<li><a class="reference external" href="#l2arc-headroom">l2arc_headroom</a></li>
<li><a class="reference external" href="#l2arc-headroom-boost">l2arc_headroom_boost</a></li>
<li><a class="reference external" href="#l2arc-nocompress">l2arc_nocompress</a></li>
<li><a class="reference external" href="#l2arc-noprefetch">l2arc_noprefetch</a></li>
<li><a class="reference external" href="#l2arc-norw">l2arc_norw</a></li>
<li><a class="reference external" href="#l2arc-write-boost">l2arc_write_boost</a></li>
<li><a class="reference external" href="#l2arc-write-max">l2arc_write_max</a></li>
<li><a class="reference external" href="#zfs-multilist-num-sublists">zfs_multilist_num_sublists</a></li>
<li><a class="reference external" href="#spa-load-verify-shift">spa_load_verify_shift</a></li>
</ul>
</div>
<div class="section" id="channel-programs">
<h3>channel_programs<a class="headerlink" href="#channel-programs" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-lua-max-instrlimit">zfs_lua_max_instrlimit</a></li>
<li><a class="reference external" href="#zfs-lua-max-memlimit">zfs_lua_max_memlimit</a></li>
</ul>
</div>
<div class="section" id="checkpoint">
<h3>checkpoint<a class="headerlink" href="#checkpoint" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-spa-discard-memory-limit">zfs_spa_discard_memory_limit</a></li>
</ul>
</div>
<div class="section" id="checksum">
<h3>checksum<a class="headerlink" href="#checksum" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-checksums-per-second">zfs_checksums_per_second</a></li>
<li><a class="reference external" href="#zfs-fletcher-4-impl">zfs_fletcher_4_impl</a></li>
<li><a class="reference external" href="#zfs-nopwrite-enabled">zfs_nopwrite_enabled</a></li>
<li><a class="reference external" href="#zfs-qat-checksum-disable">zfs_qat_checksum_disable</a></li>
</ul>
</div>
<div class="section" id="compression">
<h3>compression<a class="headerlink" href="#compression" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-compressed-arc-enabled">zfs_compressed_arc_enabled</a></li>
<li><a class="reference external" href="#zfs-qat-compress-disable">zfs_qat_compress_disable</a></li>
<li><a class="reference external" href="#zfs-qat-disable">zfs_qat_disable</a></li>
</ul>
</div>
<div class="section" id="cpu">
<h3>CPU<a class="headerlink" href="#cpu" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-fletcher-4-impl">zfs_fletcher_4_impl</a></li>
<li><a class="reference external" href="#zfs-mdcomp-disable">zfs_mdcomp_disable</a></li>
<li><a class="reference external" href="#spl-kmem-cache-kmem-threads">spl_kmem_cache_kmem_threads</a></li>
<li><a class="reference external" href="#spl-kmem-cache-magazine-size">spl_kmem_cache_magazine_size</a></li>
<li><a class="reference external" href="#spl-taskq-thread-bind">spl_taskq_thread_bind</a></li>
<li><a class="reference external" href="#spl-taskq-thread-priority">spl_taskq_thread_priority</a></li>
<li><a class="reference external" href="#spl-taskq-thread-sequential">spl_taskq_thread_sequential</a></li>
<li><a class="reference external" href="#zfs-vdev-raidz-impl">zfs_vdev_raidz_impl</a></li>
</ul>
</div>
<div class="section" id="dataset">
<h3>dataset<a class="headerlink" href="#dataset" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-max-dataset-nesting">zfs_max_dataset_nesting</a></li>
</ul>
</div>
<div class="section" id="dbuf-cache">
<h3>dbuf_cache<a class="headerlink" href="#dbuf-cache" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#dbuf-cache-hiwater-pct">dbuf_cache_hiwater_pct</a></li>
<li><a class="reference external" href="#dbuf-cache-lowater-pct">dbuf_cache_lowater_pct</a></li>
<li><a class="reference external" href="#dbuf-cache-max-bytes">dbuf_cache_max_bytes</a></li>
<li><a class="reference external" href="#dbuf-cache-max-bytes">dbuf_cache_max_bytes</a></li>
<li><a class="reference external" href="#dbuf-cache-max-shift">dbuf_cache_max_shift</a></li>
<li><a class="reference external" href="#dbuf-cache-shift">dbuf_cache_shift</a></li>
<li><a class="reference external" href="#dbuf-metadata-cache-max-bytes">dbuf_metadata_cache_max_bytes</a></li>
<li><a class="reference external" href="#dbuf-metadata-cache-shift">dbuf_metadata_cache_shift</a></li>
</ul>
</div>
<div class="section" id="debug">
<h3>debug<a class="headerlink" href="#debug" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-dbgmsg-enable">zfs_dbgmsg_enable</a></li>
<li><a class="reference external" href="#zfs-dbgmsg-maxsize">zfs_dbgmsg_maxsize</a></li>
<li><a class="reference external" href="#zfs-dbuf-state-index">zfs_dbuf_state_index</a></li>
<li><a class="reference external" href="#zfs-deadman-checktime-ms">zfs_deadman_checktime_ms</a></li>
<li><a class="reference external" href="#zfs-deadman-enabled">zfs_deadman_enabled</a></li>
<li><a class="reference external" href="#zfs-deadman-failmode">zfs_deadman_failmode</a></li>
<li><a class="reference external" href="#zfs-deadman-synctime-ms">zfs_deadman_synctime_ms</a></li>
<li><a class="reference external" href="#zfs-deadman-ziotime-ms">zfs_deadman_ziotime_ms</a></li>
<li><a class="reference external" href="#zfs-flags">zfs_flags</a></li>
<li><a class="reference external" href="#zfs-free-leak-on-eio">zfs_free_leak_on_eio</a></li>
<li><a class="reference external" href="#zfs-nopwrite-enabled">zfs_nopwrite_enabled</a></li>
<li><a class="reference external" href="#zfs-object-mutex-size">zfs_object_mutex_size</a></li>
<li><a class="reference external" href="#zfs-read-history">zfs_read_history</a></li>
<li><a class="reference external" href="#zfs-read-history-hits">zfs_read_history_hits</a></li>
<li><a class="reference external" href="#spl-panic-halt">spl_panic_halt</a></li>
<li><a class="reference external" href="#zfs-txg-history">zfs_txg_history</a></li>
<li><a class="reference external" href="#zfs-zevent-cols">zfs_zevent_cols</a></li>
<li><a class="reference external" href="#zfs-zevent-console">zfs_zevent_console</a></li>
<li><a class="reference external" href="#zfs-zevent-len-max">zfs_zevent_len_max</a></li>
<li><a class="reference external" href="#zil-replay-disable">zil_replay_disable</a></li>
<li><a class="reference external" href="#zio-deadman-log-all">zio_deadman_log_all</a></li>
<li><a class="reference external" href="#zio-decompress-fail-fraction">zio_decompress_fail_fraction</a></li>
<li><a class="reference external" href="#zio-delay-max">zio_delay_max</a></li>
</ul>
</div>
<div class="section" id="dedup">
<h3>dedup<a class="headerlink" href="#dedup" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-ddt-data-is-special">zfs_ddt_data_is_special</a></li>
<li><a class="reference external" href="#zfs-disable-dup-eviction">zfs_disable_dup_eviction</a></li>
</ul>
</div>
<div class="section" id="delay">
<h3>delay<a class="headerlink" href="#delay" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-delays-per-second">zfs_delays_per_second</a></li>
</ul>
</div>
<div class="section" id="delete">
<h3>delete<a class="headerlink" href="#delete" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-async-block-max-blocks">zfs_async_block_max_blocks</a></li>
<li><a class="reference external" href="#zfs-delete-blocks">zfs_delete_blocks</a></li>
<li><a class="reference external" href="#zfs-free-bpobj-enabled">zfs_free_bpobj_enabled</a></li>
<li><a class="reference external" href="#zfs-free-max-blocks">zfs_free_max_blocks</a></li>
<li><a class="reference external" href="#zfs-free-min-time-ms">zfs_free_min_time_ms</a></li>
<li><a class="reference external" href="#zfs-obsolete-min-time-ms">zfs_obsolete_min_time_ms</a></li>
<li><a class="reference external" href="#zfs-per-txg-dirty-frees-percent">zfs_per_txg_dirty_frees_percent</a></li>
</ul>
</div>
<div class="section" id="discard">
<h3>discard<a class="headerlink" href="#discard" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zvol-max-discard-blocks">zvol_max_discard_blocks</a></li>
</ul>
</div>
<div class="section" id="disks">
<h3>disks<a class="headerlink" href="#disks" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-nocacheflush">zfs_nocacheflush</a></li>
<li><a class="reference external" href="#zil-nocacheflush">zil_nocacheflush</a></li>
</ul>
</div>
<div class="section" id="dmu">
<h3>DMU<a class="headerlink" href="#dmu" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-async-block-max-blocks">zfs_async_block_max_blocks</a></li>
<li><a class="reference external" href="#dmu-object-alloc-chunk-shift">dmu_object_alloc_chunk_shift</a></li>
<li><a class="reference external" href="#zfs-dmu-offset-next-sync">zfs_dmu_offset_next_sync</a></li>
</ul>
</div>
<div class="section" id="encryption">
<h3>encryption<a class="headerlink" href="#encryption" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#icp-aes-impl">icp_aes_impl</a></li>
<li><a class="reference external" href="#icp-gcm-impl">icp_gcm_impl</a></li>
<li><a class="reference external" href="#zfs-key-max-salt-uses">zfs_key_max_salt_uses</a></li>
<li><a class="reference external" href="#zfs-qat-encrypt-disable">zfs_qat_encrypt_disable</a></li>
</ul>
</div>
<div class="section" id="filesystem">
<h3>filesystem<a class="headerlink" href="#filesystem" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-admin-snapshot">zfs_admin_snapshot</a></li>
<li><a class="reference external" href="#zfs-delete-blocks">zfs_delete_blocks</a></li>
<li><a class="reference external" href="#zfs-expire-snapshot">zfs_expire_snapshot</a></li>
<li><a class="reference external" href="#zfs-free-max-blocks">zfs_free_max_blocks</a></li>
<li><a class="reference external" href="#zfs-max-recordsize">zfs_max_recordsize</a></li>
<li><a class="reference external" href="#zfs-read-chunk-size">zfs_read_chunk_size</a></li>
</ul>
</div>
<div class="section" id="fragmentation">
<h3>fragmentation<a class="headerlink" href="#fragmentation" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-metaslab-fragmentation-threshold">zfs_metaslab_fragmentation_threshold</a></li>
<li><a class="reference external" href="#zfs-mg-fragmentation-threshold">zfs_mg_fragmentation_threshold</a></li>
<li><a class="reference external" href="#zfs-mg-noalloc-threshold">zfs_mg_noalloc_threshold</a></li>
</ul>
</div>
<div class="section" id="hdd">
<h3>HDD<a class="headerlink" href="#hdd" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#metaslab-lba-weighting-enabled">metaslab_lba_weighting_enabled</a></li>
<li><a class="reference external" href="#zfs-vdev-mirror-rotating-inc">zfs_vdev_mirror_rotating_inc</a></li>
<li><a class="reference external" href="#zfs-vdev-mirror-rotating-seek-inc">zfs_vdev_mirror_rotating_seek_inc</a></li>
<li><a class="reference external" href="#zfs-vdev-mirror-rotating-seek-offset">zfs_vdev_mirror_rotating_seek_offset</a></li>
</ul>
</div>
<div class="section" id="hostid">
<h3>hostid<a class="headerlink" href="#hostid" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#spl-hostid">spl_hostid</a></li>
<li><a class="reference external" href="#spl-hostid-path">spl_hostid_path</a></li>
</ul>
</div>
<div class="section" id="import">
<h3>import<a class="headerlink" href="#import" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-autoimport-disable">zfs_autoimport_disable</a></li>
<li><a class="reference external" href="#zfs-max-missing-tvds">zfs_max_missing_tvds</a></li>
<li><a class="reference external" href="#zfs-multihost-fail-intervals">zfs_multihost_fail_intervals</a></li>
<li><a class="reference external" href="#zfs-multihost-history">zfs_multihost_history</a></li>
<li><a class="reference external" href="#zfs-multihost-import-intervals">zfs_multihost_import_intervals</a></li>
<li><a class="reference external" href="#zfs-multihost-interval">zfs_multihost_interval</a></li>
<li><a class="reference external" href="#zfs-recover">zfs_recover</a></li>
<li><a class="reference external" href="#spa-config-path">spa_config_path</a></li>
<li><a class="reference external" href="#spa-load-print-vdev-tree">spa_load_print_vdev_tree</a></li>
<li><a class="reference external" href="#spa-load-verify-maxinflight">spa_load_verify_maxinflight</a></li>
<li><a class="reference external" href="#spa-load-verify-metadata">spa_load_verify_metadata</a></li>
<li><a class="reference external" href="#spa-load-verify-shift">spa_load_verify_shift</a></li>
<li><a class="reference external" href="#zvol-inhibit-dev">zvol_inhibit_dev</a></li>
</ul>
</div>
<div class="section" id="l2arc">
<h3>L2ARC<a class="headerlink" href="#l2arc" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#l2arc-feed-again">l2arc_feed_again</a></li>
<li><a class="reference external" href="#l2arc-feed-min-ms">l2arc_feed_min_ms</a></li>
<li><a class="reference external" href="#l2arc-feed-secs">l2arc_feed_secs</a></li>
<li><a class="reference external" href="#l2arc-headroom">l2arc_headroom</a></li>
<li><a class="reference external" href="#l2arc-headroom-boost">l2arc_headroom_boost</a></li>
<li><a class="reference external" href="#l2arc-nocompress">l2arc_nocompress</a></li>
<li><a class="reference external" href="#l2arc-noprefetch">l2arc_noprefetch</a></li>
<li><a class="reference external" href="#l2arc-norw">l2arc_norw</a></li>
<li><a class="reference external" href="#l2arc-write-boost">l2arc_write_boost</a></li>
<li><a class="reference external" href="#l2arc-write-max">l2arc_write_max</a></li>
</ul>
</div>
<div class="section" id="memory">
<h3>memory<a class="headerlink" href="#memory" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-abd-scatter-enabled">zfs_abd_scatter_enabled</a></li>
<li><a class="reference external" href="#zfs-abd-scatter-max-order">zfs_abd_scatter_max_order</a></li>
<li><a class="reference external" href="#zfs-arc-average-blocksize">zfs_arc_average_blocksize</a></li>
<li><a class="reference external" href="#zfs-arc-grow-retry">zfs_arc_grow_retry</a></li>
<li><a class="reference external" href="#zfs-arc-lotsfree-percent">zfs_arc_lotsfree_percent</a></li>
<li><a class="reference external" href="#zfs-arc-max">zfs_arc_max</a></li>
<li><a class="reference external" href="#zfs-arc-pc-percent">zfs_arc_pc_percent</a></li>
<li><a class="reference external" href="#zfs-arc-shrink-shift">zfs_arc_shrink_shift</a></li>
<li><a class="reference external" href="#zfs-arc-sys-free">zfs_arc_sys_free</a></li>
<li><a class="reference external" href="#zfs-dedup-prefetch">zfs_dedup_prefetch</a></li>
<li><a class="reference external" href="#zfs-max-recordsize">zfs_max_recordsize</a></li>
<li><a class="reference external" href="#metaslab-debug-load">metaslab_debug_load</a></li>
<li><a class="reference external" href="#metaslab-debug-unload">metaslab_debug_unload</a></li>
<li><a class="reference external" href="#zfs-scan-mem-lim-fact">zfs_scan_mem_lim_fact</a></li>
<li><a class="reference external" href="#zfs-scan-strict-mem-lim">zfs_scan_strict_mem_lim</a></li>
<li><a class="reference external" href="#spl-kmem-alloc-max">spl_kmem_alloc_max</a></li>
<li><a class="reference external" href="#spl-kmem-alloc-warn">spl_kmem_alloc_warn</a></li>
<li><a class="reference external" href="#spl-kmem-cache-expire">spl_kmem_cache_expire</a></li>
<li><a class="reference external" href="#spl-kmem-cache-kmem-limit">spl_kmem_cache_kmem_limit</a></li>
<li><a class="reference external" href="#spl-kmem-cache-kmem-threads">spl_kmem_cache_kmem_threads</a></li>
<li><a class="reference external" href="#spl-kmem-cache-magazine-size">spl_kmem_cache_magazine_size</a></li>
<li><a class="reference external" href="#spl-kmem-cache-max-size">spl_kmem_cache_max_size</a></li>
<li><a class="reference external" href="#spl-kmem-cache-obj-per-slab">spl_kmem_cache_obj_per_slab</a></li>
<li><a class="reference external" href="#spl-kmem-cache-obj-per-slab-min">spl_kmem_cache_obj_per_slab_min</a></li>
<li><a class="reference external" href="#spl-kmem-cache-reclaim">spl_kmem_cache_reclaim</a></li>
<li><a class="reference external" href="#spl-kmem-cache-slab-limit">spl_kmem_cache_slab_limit</a></li>
</ul>
</div>
<div class="section" id="metadata">
<h3>metadata<a class="headerlink" href="#metadata" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-mdcomp-disable">zfs_mdcomp_disable</a></li>
</ul>
</div>
<div class="section" id="metaslab">
<h3>metaslab<a class="headerlink" href="#metaslab" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#metaslab-aliquot">metaslab_aliquot</a></li>
<li><a class="reference external" href="#metaslab-bias-enabled">metaslab_bias_enabled</a></li>
<li><a class="reference external" href="#metaslab-debug-load">metaslab_debug_load</a></li>
<li><a class="reference external" href="#metaslab-debug-unload">metaslab_debug_unload</a></li>
<li><a class="reference external" href="#metaslab-fragmentation-factor-enabled">metaslab_fragmentation_factor_enabled</a></li>
<li><a class="reference external" href="#metaslab-lba-weighting-enabled">metaslab_lba_weighting_enabled</a></li>
<li><a class="reference external" href="#metaslab-preload-enabled">metaslab_preload_enabled</a></li>
<li><a class="reference external" href="#zfs-metaslab-segment-weight-enabled">zfs_metaslab_segment_weight_enabled</a></li>
<li><a class="reference external" href="#zfs-metaslab-switch-threshold">zfs_metaslab_switch_threshold</a></li>
<li><a class="reference external" href="#metaslabs-per-vdev">metaslabs_per_vdev</a></li>
<li><a class="reference external" href="#zfs-vdev-min-ms-count">zfs_vdev_min_ms_count</a></li>
<li><a class="reference external" href="#zfs-vdev-ms-count-limit">zfs_vdev_ms_count_limit</a></li>
</ul>
</div>
<div class="section" id="mirror">
<h3>mirror<a class="headerlink" href="#mirror" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-vdev-mirror-non-rotating-inc">zfs_vdev_mirror_non_rotating_inc</a></li>
<li><a class="reference external" href="#zfs-vdev-mirror-non-rotating-seek-inc">zfs_vdev_mirror_non_rotating_seek_inc</a></li>
<li><a class="reference external" href="#zfs-vdev-mirror-rotating-inc">zfs_vdev_mirror_rotating_inc</a></li>
<li><a class="reference external" href="#zfs-vdev-mirror-rotating-seek-inc">zfs_vdev_mirror_rotating_seek_inc</a></li>
<li><a class="reference external" href="#zfs-vdev-mirror-rotating-seek-offset">zfs_vdev_mirror_rotating_seek_offset</a></li>
</ul>
</div>
<div class="section" id="mmp">
<h3>MMP<a class="headerlink" href="#mmp" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-multihost-fail-intervals">zfs_multihost_fail_intervals</a></li>
<li><a class="reference external" href="#zfs-multihost-history">zfs_multihost_history</a></li>
<li><a class="reference external" href="#zfs-multihost-import-intervals">zfs_multihost_import_intervals</a></li>
<li><a class="reference external" href="#zfs-multihost-interval">zfs_multihost_interval</a></li>
<li><a class="reference external" href="#spl-hostid">spl_hostid</a></li>
<li><a class="reference external" href="#spl-hostid-path">spl_hostid_path</a></li>
</ul>
</div>
<div class="section" id="panic">
<h3>panic<a class="headerlink" href="#panic" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#spl-panic-halt">spl_panic_halt</a></li>
</ul>
</div>
<div class="section" id="prefetch">
<h3>prefetch<a class="headerlink" href="#prefetch" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-arc-min-prefetch-ms">zfs_arc_min_prefetch_ms</a></li>
<li><a class="reference external" href="#zfs-arc-min-prescient-prefetch-ms">zfs_arc_min_prescient_prefetch_ms</a></li>
<li><a class="reference external" href="#zfs-dedup-prefetch">zfs_dedup_prefetch</a></li>
<li><a class="reference external" href="#l2arc-noprefetch">l2arc_noprefetch</a></li>
<li><a class="reference external" href="#zfs-no-scrub-prefetch">zfs_no_scrub_prefetch</a></li>
<li><a class="reference external" href="#zfs-pd-bytes-max">zfs_pd_bytes_max</a></li>
<li><a class="reference external" href="#zfs-prefetch-disable">zfs_prefetch_disable</a></li>
<li><a class="reference external" href="#zfetch-array-rd-sz">zfetch_array_rd_sz</a></li>
<li><a class="reference external" href="#zfetch-max-distance">zfetch_max_distance</a></li>
<li><a class="reference external" href="#zfetch-max-streams">zfetch_max_streams</a></li>
<li><a class="reference external" href="#zfetch-min-sec-reap">zfetch_min_sec_reap</a></li>
<li><a class="reference external" href="#zvol-prefetch-bytes">zvol_prefetch_bytes</a></li>
</ul>
</div>
<div class="section" id="qat">
<h3>QAT<a class="headerlink" href="#qat" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-qat-checksum-disable">zfs_qat_checksum_disable</a></li>
<li><a class="reference external" href="#zfs-qat-compress-disable">zfs_qat_compress_disable</a></li>
<li><a class="reference external" href="#zfs-qat-disable">zfs_qat_disable</a></li>
<li><a class="reference external" href="#zfs-qat-encrypt-disable">zfs_qat_encrypt_disable</a></li>
</ul>
</div>
<div class="section" id="raidz">
<h3>raidz<a class="headerlink" href="#raidz" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-vdev-raidz-impl">zfs_vdev_raidz_impl</a></li>
</ul>
</div>
<div class="section" id="receive">
<h3>receive<a class="headerlink" href="#receive" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-disable-ivset-guid-check">zfs_disable_ivset_guid_check</a></li>
<li><a class="reference external" href="#zfs-recv-queue-length">zfs_recv_queue_length</a></li>
</ul>
</div>
<div class="section" id="remove">
<h3>remove<a class="headerlink" href="#remove" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-obsolete-min-time-ms">zfs_obsolete_min_time_ms</a></li>
<li><a class="reference external" href="#zfs-remove-max-segment">zfs_remove_max_segment</a></li>
</ul>
</div>
<div class="section" id="resilver">
<h3>resilver<a class="headerlink" href="#resilver" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-resilver-delay">zfs_resilver_delay</a></li>
<li><a class="reference external" href="#zfs-resilver-disable-defer">zfs_resilver_disable_defer</a></li>
<li><a class="reference external" href="#zfs-resilver-min-time-ms">zfs_resilver_min_time_ms</a></li>
<li><a class="reference external" href="#zfs-scan-checkpoint-intval">zfs_scan_checkpoint_intval</a></li>
<li><a class="reference external" href="#zfs-scan-fill-weight">zfs_scan_fill_weight</a></li>
<li><a class="reference external" href="#zfs-scan-idle">zfs_scan_idle</a></li>
<li><a class="reference external" href="#zfs-scan-ignore-errors">zfs_scan_ignore_errors</a></li>
<li><a class="reference external" href="#zfs-scan-issue-strategy">zfs_scan_issue_strategy</a></li>
<li><a class="reference external" href="#zfs-scan-legacy">zfs_scan_legacy</a></li>
<li><a class="reference external" href="#zfs-scan-max-ext-gap">zfs_scan_max_ext_gap</a></li>
<li><a class="reference external" href="#zfs-scan-mem-lim-fact">zfs_scan_mem_lim_fact</a></li>
<li><a class="reference external" href="#zfs-scan-mem-lim-soft-fact">zfs_scan_mem_lim_soft_fact</a></li>
<li><a class="reference external" href="#zfs-scan-strict-mem-lim">zfs_scan_strict_mem_lim</a></li>
<li><a class="reference external" href="#zfs-scan-suspend-progress">zfs_scan_suspend_progress</a></li>
<li><a class="reference external" href="#zfs-scan-vdev-limit">zfs_scan_vdev_limit</a></li>
<li><a class="reference external" href="#zfs-top-maxinflight">zfs_top_maxinflight</a></li>
<li><a class="reference external" href="#zfs-vdev-scrub-max-active">zfs_vdev_scrub_max_active</a></li>
<li><a class="reference external" href="#zfs-vdev-scrub-min-active">zfs_vdev_scrub_min_active</a></li>
</ul>
</div>
<div class="section" id="scrub">
<h3>scrub<a class="headerlink" href="#scrub" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-no-scrub-io">zfs_no_scrub_io</a></li>
<li><a class="reference external" href="#zfs-no-scrub-prefetch">zfs_no_scrub_prefetch</a></li>
<li><a class="reference external" href="#zfs-scan-checkpoint-intval">zfs_scan_checkpoint_intval</a></li>
<li><a class="reference external" href="#zfs-scan-fill-weight">zfs_scan_fill_weight</a></li>
<li><a class="reference external" href="#zfs-scan-idle">zfs_scan_idle</a></li>
<li><a class="reference external" href="#zfs-scan-issue-strategy">zfs_scan_issue_strategy</a></li>
<li><a class="reference external" href="#zfs-scan-legacy">zfs_scan_legacy</a></li>
<li><a class="reference external" href="#zfs-scan-max-ext-gap">zfs_scan_max_ext_gap</a></li>
<li><a class="reference external" href="#zfs-scan-mem-lim-fact">zfs_scan_mem_lim_fact</a></li>
<li><a class="reference external" href="#zfs-scan-mem-lim-soft-fact">zfs_scan_mem_lim_soft_fact</a></li>
<li><a class="reference external" href="#zfs-scan-min-time-ms">zfs_scan_min_time_ms</a></li>
<li><a class="reference external" href="#zfs-scan-strict-mem-lim">zfs_scan_strict_mem_lim</a></li>
<li><a class="reference external" href="#zfs-scan-suspend-progress">zfs_scan_suspend_progress</a></li>
<li><a class="reference external" href="#zfs-scan-vdev-limit">zfs_scan_vdev_limit</a></li>
<li><a class="reference external" href="#zfs-scrub-delay">zfs_scrub_delay</a></li>
<li><a class="reference external" href="#zfs-scrub-min-time-ms">zfs_scrub_min_time_ms</a></li>
<li><a class="reference external" href="#zfs-top-maxinflight">zfs_top_maxinflight</a></li>
<li><a class="reference external" href="#zfs-vdev-scrub-max-active">zfs_vdev_scrub_max_active</a></li>
<li><a class="reference external" href="#zfs-vdev-scrub-min-active">zfs_vdev_scrub_min_active</a></li>
</ul>
</div>
<div class="section" id="send">
<h3>send<a class="headerlink" href="#send" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#ignore-hole-birth">ignore_hole_birth</a></li>
<li><a class="reference external" href="#zfs-override-estimate-recordsize">zfs_override_estimate_recordsize</a></li>
<li><a class="reference external" href="#zfs-pd-bytes-max">zfs_pd_bytes_max</a></li>
<li><a class="reference external" href="#zfs-send-corrupt-data">zfs_send_corrupt_data</a></li>
<li><a class="reference external" href="#zfs-send-queue-length">zfs_send_queue_length</a></li>
<li><a class="reference external" href="#zfs-send-unmodified-spill-blocks">zfs_send_unmodified_spill_blocks</a></li>
</ul>
</div>
<div class="section" id="snapshot">
<h3>snapshot<a class="headerlink" href="#snapshot" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-admin-snapshot">zfs_admin_snapshot</a></li>
<li><a class="reference external" href="#zfs-expire-snapshot">zfs_expire_snapshot</a></li>
</ul>
</div>
<div class="section" id="spa">
<h3>SPA<a class="headerlink" href="#spa" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#spa-asize-inflation">spa_asize_inflation</a></li>
<li><a class="reference external" href="#spa-load-print-vdev-tree">spa_load_print_vdev_tree</a></li>
<li><a class="reference external" href="#spa-load-verify-data">spa_load_verify_data</a></li>
<li><a class="reference external" href="#spa-load-verify-shift">spa_load_verify_shift</a></li>
<li><a class="reference external" href="#spa-slop-shift">spa_slop_shift</a></li>
<li><a class="reference external" href="#zfs-sync-pass-deferred-free">zfs_sync_pass_deferred_free</a></li>
<li><a class="reference external" href="#zfs-sync-pass-dont-compress">zfs_sync_pass_dont_compress</a></li>
<li><a class="reference external" href="#zfs-sync-pass-rewrite">zfs_sync_pass_rewrite</a></li>
<li><a class="reference external" href="#zfs-sync-taskq-batch-pct">zfs_sync_taskq_batch_pct</a></li>
<li><a class="reference external" href="#zfs-txg-timeout">zfs_txg_timeout</a></li>
</ul>
</div>
<div class="section" id="special-vdev">
<h3>special_vdev<a class="headerlink" href="#special-vdev" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-ddt-data-is-special">zfs_ddt_data_is_special</a></li>
<li><a class="reference external" href="#zfs-special-class-metadata-reserve-pct">zfs_special_class_metadata_reserve_pct</a></li>
<li><a class="reference external" href="#zfs-user-indirect-is-special">zfs_user_indirect_is_special</a></li>
</ul>
</div>
<div class="section" id="ssd">
<h3>SSD<a class="headerlink" href="#ssd" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#metaslab-lba-weighting-enabled">metaslab_lba_weighting_enabled</a></li>
<li><a class="reference external" href="#zfs-vdev-mirror-non-rotating-inc">zfs_vdev_mirror_non_rotating_inc</a></li>
<li><a class="reference external" href="#zfs-vdev-mirror-non-rotating-seek-inc">zfs_vdev_mirror_non_rotating_seek_inc</a></li>
</ul>
</div>
<div class="section" id="taskq">
<h3>taskq<a class="headerlink" href="#taskq" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#spl-max-show-tasks">spl_max_show_tasks</a></li>
<li><a class="reference external" href="#spl-taskq-kick">spl_taskq_kick</a></li>
<li><a class="reference external" href="#spl-taskq-thread-bind">spl_taskq_thread_bind</a></li>
<li><a class="reference external" href="#spl-taskq-thread-dynamic">spl_taskq_thread_dynamic</a></li>
<li><a class="reference external" href="#spl-taskq-thread-priority">spl_taskq_thread_priority</a></li>
<li><a class="reference external" href="#spl-taskq-thread-sequential">spl_taskq_thread_sequential</a></li>
<li><a class="reference external" href="#zfs-zil-clean-taskq-nthr-pct">zfs_zil_clean_taskq_nthr_pct</a></li>
<li><a class="reference external" href="#zio-taskq-batch-pct">zio_taskq_batch_pct</a></li>
</ul>
</div>
<div class="section" id="trim">
<h3>trim<a class="headerlink" href="#trim" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-trim-extent-bytes-max">zfs_trim_extent_bytes_max</a></li>
<li><a class="reference external" href="#zfs-trim-extent-bytes-min">zfs_trim_extent_bytes_min</a></li>
<li><a class="reference external" href="#zfs-trim-metaslab-skip">zfs_trim_metaslab_skip</a></li>
<li><a class="reference external" href="#zfs-trim-queue-limit">zfs_trim_queue_limit</a></li>
<li><a class="reference external" href="#zfs-trim-txg-batch">zfs_trim_txg_batch</a></li>
<li><a class="reference external" href="#zfs-vdev-aggregate-trim">zfs_vdev_aggregate_trim</a></li>
</ul>
</div>
<div class="section" id="vdev">
<h3>vdev<a class="headerlink" href="#vdev" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-checksum-events-per-second">zfs_checksum_events_per_second</a></li>
<li><a class="reference external" href="#metaslab-aliquot">metaslab_aliquot</a></li>
<li><a class="reference external" href="#metaslab-bias-enabled">metaslab_bias_enabled</a></li>
<li><a class="reference external" href="#zfs-metaslab-fragmentation-threshold">zfs_metaslab_fragmentation_threshold</a></li>
<li><a class="reference external" href="#metaslabs-per-vdev">metaslabs_per_vdev</a></li>
<li><a class="reference external" href="#zfs-mg-fragmentation-threshold">zfs_mg_fragmentation_threshold</a></li>
<li><a class="reference external" href="#zfs-mg-noalloc-threshold">zfs_mg_noalloc_threshold</a></li>
<li><a class="reference external" href="#zfs-multihost-interval">zfs_multihost_interval</a></li>
<li><a class="reference external" href="#zfs-scan-vdev-limit">zfs_scan_vdev_limit</a></li>
<li><a class="reference external" href="#zfs-slow-io-events-per-second">zfs_slow_io_events_per_second</a></li>
<li><a class="reference external" href="#zfs-vdev-aggregate-trim">zfs_vdev_aggregate_trim</a></li>
<li><a class="reference external" href="#zfs-vdev-aggregation-limit">zfs_vdev_aggregation_limit</a></li>
<li><a class="reference external" href="#zfs-vdev-aggregation-limit-non-rotating">zfs_vdev_aggregation_limit_non_rotating</a></li>
<li><a class="reference external" href="#zfs-vdev-async-read-max-active">zfs_vdev_async_read_max_active</a></li>
<li><a class="reference external" href="#zfs-vdev-async-read-min-active">zfs_vdev_async_read_min_active</a></li>
<li><a class="reference external" href="#zfs-vdev-async-write-active-max-dirty-percent">zfs_vdev_async_write_active_max_dirty_percent</a></li>
<li><a class="reference external" href="#zfs-vdev-async-write-active-min-dirty-percent">zfs_vdev_async_write_active_min_dirty_percent</a></li>
<li><a class="reference external" href="#zfs-vdev-async-write-max-active">zfs_vdev_async_write_max_active</a></li>
<li><a class="reference external" href="#zfs-vdev-async-write-min-active">zfs_vdev_async_write_min_active</a></li>
<li><a class="reference external" href="#zfs-vdev-cache-bshift">zfs_vdev_cache_bshift</a></li>
<li><a class="reference external" href="#zfs-vdev-cache-max">zfs_vdev_cache_max</a></li>
<li><a class="reference external" href="#zfs-vdev-cache-size">zfs_vdev_cache_size</a></li>
<li><a class="reference external" href="#zfs-vdev-initializing-max-active">zfs_vdev_initializing_max_active</a></li>
<li><a class="reference external" href="#zfs-vdev-initializing-min-active">zfs_vdev_initializing_min_active</a></li>
<li><a class="reference external" href="#zfs-vdev-max-active">zfs_vdev_max_active</a></li>
<li><a class="reference external" href="#zfs-vdev-min-ms-count">zfs_vdev_min_ms_count</a></li>
<li><a class="reference external" href="#zfs-vdev-mirror-non-rotating-inc">zfs_vdev_mirror_non_rotating_inc</a></li>
<li><a class="reference external" href="#zfs-vdev-mirror-non-rotating-seek-inc">zfs_vdev_mirror_non_rotating_seek_inc</a></li>
<li><a class="reference external" href="#zfs-vdev-mirror-rotating-inc">zfs_vdev_mirror_rotating_inc</a></li>
<li><a class="reference external" href="#zfs-vdev-mirror-rotating-seek-inc">zfs_vdev_mirror_rotating_seek_inc</a></li>
<li><a class="reference external" href="#zfs-vdev-mirror-rotating-seek-offset">zfs_vdev_mirror_rotating_seek_offset</a></li>
<li><a class="reference external" href="#zfs-vdev-ms-count-limit">zfs_vdev_ms_count_limit</a></li>
<li><a class="reference external" href="#zfs-vdev-queue-depth-pct">zfs_vdev_queue_depth_pct</a></li>
<li><a class="reference external" href="#zfs-vdev-raidz-impl">zfs_vdev_raidz_impl</a></li>
<li><a class="reference external" href="#zfs-vdev-read-gap-limit">zfs_vdev_read_gap_limit</a></li>
<li><a class="reference external" href="#zfs-vdev-removal-max-active">zfs_vdev_removal_max_active</a></li>
<li><a class="reference external" href="#zfs-vdev-removal-min-active">zfs_vdev_removal_min_active</a></li>
<li><a class="reference external" href="#zfs-vdev-scheduler">zfs_vdev_scheduler</a></li>
<li><a class="reference external" href="#zfs-vdev-scrub-max-active">zfs_vdev_scrub_max_active</a></li>
<li><a class="reference external" href="#zfs-vdev-scrub-min-active">zfs_vdev_scrub_min_active</a></li>
<li><a class="reference external" href="#zfs-vdev-sync-read-max-active">zfs_vdev_sync_read_max_active</a></li>
<li><a class="reference external" href="#zfs-vdev-sync-read-min-active">zfs_vdev_sync_read_min_active</a></li>
<li><a class="reference external" href="#zfs-vdev-sync-write-max-active">zfs_vdev_sync_write_max_active</a></li>
<li><a class="reference external" href="#zfs-vdev-sync-write-min-active">zfs_vdev_sync_write_min_active</a></li>
<li><a class="reference external" href="#zfs-vdev-trim-max-active">zfs_vdev_trim_max_active</a></li>
<li><a class="reference external" href="#zfs-vdev-trim-min-active">zfs_vdev_trim_min_active</a></li>
<li><a class="reference external" href="#vdev-validate-skip">vdev_validate_skip</a></li>
<li><a class="reference external" href="#zfs-vdev-write-gap-limit">zfs_vdev_write_gap_limit</a></li>
<li><a class="reference external" href="#zio-dva-throttle-enabled">zio_dva_throttle_enabled</a></li>
<li><a class="reference external" href="#zio-slow-io-ms">zio_slow_io_ms</a></li>
</ul>
</div>
<div class="section" id="vdev-cache">
<h3>vdev_cache<a class="headerlink" href="#vdev-cache" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-vdev-cache-bshift">zfs_vdev_cache_bshift</a></li>
<li><a class="reference external" href="#zfs-vdev-cache-max">zfs_vdev_cache_max</a></li>
<li><a class="reference external" href="#zfs-vdev-cache-size">zfs_vdev_cache_size</a></li>
</ul>
</div>
<div class="section" id="vdev-initialize">
<h3>vdev_initialize<a class="headerlink" href="#vdev-initialize" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-initialize-value">zfs_initialize_value</a></li>
</ul>
</div>
<div class="section" id="vdev-removal">
<h3>vdev_removal<a class="headerlink" href="#vdev-removal" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-condense-indirect-commit-entry-delay-ms">zfs_condense_indirect_commit_entry_delay_ms</a></li>
<li><a class="reference external" href="#zfs-condense-indirect-vdevs-enable">zfs_condense_indirect_vdevs_enable</a></li>
<li><a class="reference external" href="#zfs-condense-max-obsolete-bytes">zfs_condense_max_obsolete_bytes</a></li>
<li><a class="reference external" href="#zfs-condense-min-mapping-bytes">zfs_condense_min_mapping_bytes</a></li>
<li><a class="reference external" href="#zfs-reconstruct-indirect-combinations-max">zfs_reconstruct_indirect_combinations_max</a></li>
<li><a class="reference external" href="#zfs-removal-ignore-errors">zfs_removal_ignore_errors</a></li>
<li><a class="reference external" href="#zfs-removal-suspend-progress">zfs_removal_suspend_progress</a></li>
<li><a class="reference external" href="#vdev-removal-max-span">vdev_removal_max_span</a></li>
</ul>
</div>
<div class="section" id="volume">
<h3>volume<a class="headerlink" href="#volume" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-max-recordsize">zfs_max_recordsize</a></li>
<li><a class="reference external" href="#zvol-inhibit-dev">zvol_inhibit_dev</a></li>
<li><a class="reference external" href="#zvol-major">zvol_major</a></li>
<li><a class="reference external" href="#zvol-max-discard-blocks">zvol_max_discard_blocks</a></li>
<li><a class="reference external" href="#zvol-prefetch-bytes">zvol_prefetch_bytes</a></li>
<li><a class="reference external" href="#zvol-request-sync">zvol_request_sync</a></li>
<li><a class="reference external" href="#zvol-threads">zvol_threads</a></li>
<li><a class="reference external" href="#zvol-volmode">zvol_volmode</a></li>
</ul>
</div>
<div class="section" id="write-throttle">
<h3>write_throttle<a class="headerlink" href="#write-throttle" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-delay-min-dirty-percent">zfs_delay_min_dirty_percent</a></li>
<li><a class="reference external" href="#zfs-delay-scale">zfs_delay_scale</a></li>
<li><a class="reference external" href="#zfs-dirty-data-max">zfs_dirty_data_max</a></li>
<li><a class="reference external" href="#zfs-dirty-data-max-max">zfs_dirty_data_max_max</a></li>
<li><a class="reference external" href="#zfs-dirty-data-max-max-percent">zfs_dirty_data_max_max_percent</a></li>
<li><a class="reference external" href="#zfs-dirty-data-max-percent">zfs_dirty_data_max_percent</a></li>
<li><a class="reference external" href="#zfs-dirty-data-sync">zfs_dirty_data_sync</a></li>
<li><a class="reference external" href="#zfs-dirty-data-sync-percent">zfs_dirty_data_sync_percent</a></li>
</ul>
</div>
<div class="section" id="zed">
<h3>zed<a class="headerlink" href="#zed" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-checksums-per-second">zfs_checksums_per_second</a></li>
<li><a class="reference external" href="#zfs-delays-per-second">zfs_delays_per_second</a></li>
<li><a class="reference external" href="#zio-slow-io-ms">zio_slow_io_ms</a></li>
</ul>
</div>
<div class="section" id="zil">
<h3>ZIL<a class="headerlink" href="#zil" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-commit-timeout-pct">zfs_commit_timeout_pct</a></li>
<li><a class="reference external" href="#zfs-immediate-write-sz">zfs_immediate_write_sz</a></li>
<li><a class="reference external" href="#zfs-zil-clean-taskq-maxalloc">zfs_zil_clean_taskq_maxalloc</a></li>
<li><a class="reference external" href="#zfs-zil-clean-taskq-minalloc">zfs_zil_clean_taskq_minalloc</a></li>
<li><a class="reference external" href="#zfs-zil-clean-taskq-nthr-pct">zfs_zil_clean_taskq_nthr_pct</a></li>
<li><a class="reference external" href="#zil-nocacheflush">zil_nocacheflush</a></li>
<li><a class="reference external" href="#zil-replay-disable">zil_replay_disable</a></li>
<li><a class="reference external" href="#zil-slog-bulk">zil_slog_bulk</a></li>
</ul>
</div>
<div class="section" id="zio-scheduler">
<h3>ZIO_scheduler<a class="headerlink" href="#zio-scheduler" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="#zfs-dirty-data-sync">zfs_dirty_data_sync</a></li>
<li><a class="reference external" href="#zfs-dirty-data-sync-percent">zfs_dirty_data_sync_percent</a></li>
<li><a class="reference external" href="#zfs-resilver-delay">zfs_resilver_delay</a></li>
<li><a class="reference external" href="#zfs-scan-idle">zfs_scan_idle</a></li>
<li><a class="reference external" href="#zfs-scrub-delay">zfs_scrub_delay</a></li>
<li><a class="reference external" href="#zfs-top-maxinflight">zfs_top_maxinflight</a></li>
<li><a class="reference external" href="#zfs-txg-timeout">zfs_txg_timeout</a></li>
<li><a class="reference external" href="#zfs-vdev-aggregate-trim">zfs_vdev_aggregate_trim</a></li>
<li><a class="reference external" href="#zfs-vdev-aggregation-limit">zfs_vdev_aggregation_limit</a></li>
<li><a class="reference external" href="#zfs-vdev-aggregation-limit-non-rotating">zfs_vdev_aggregation_limit_non_rotating</a></li>
<li><a class="reference external" href="#zfs-vdev-async-read-max-active">zfs_vdev_async_read_max_active</a></li>
<li><a class="reference external" href="#zfs-vdev-async-read-min-active">zfs_vdev_async_read_min_active</a></li>
<li><a class="reference external" href="#zfs-vdev-async-write-active-max-dirty-percent">zfs_vdev_async_write_active_max_dirty_percent</a></li>
<li><a class="reference external" href="#zfs-vdev-async-write-active-min-dirty-percent">zfs_vdev_async_write_active_min_dirty_percent</a></li>
<li><a class="reference external" href="#zfs-vdev-async-write-max-active">zfs_vdev_async_write_max_active</a></li>
<li><a class="reference external" href="#zfs-vdev-async-write-min-active">zfs_vdev_async_write_min_active</a></li>
<li><a class="reference external" href="#zfs-vdev-initializing-max-active">zfs_vdev_initializing_max_active</a></li>
<li><a class="reference external" href="#zfs-vdev-initializing-min-active">zfs_vdev_initializing_min_active</a></li>
<li><a class="reference external" href="#zfs-vdev-max-active">zfs_vdev_max_active</a></li>
<li><a class="reference external" href="#zfs-vdev-queue-depth-pct">zfs_vdev_queue_depth_pct</a></li>
<li><a class="reference external" href="#zfs-vdev-read-gap-limit">zfs_vdev_read_gap_limit</a></li>
<li><a class="reference external" href="#zfs-vdev-removal-max-active">zfs_vdev_removal_max_active</a></li>
<li><a class="reference external" href="#zfs-vdev-removal-min-active">zfs_vdev_removal_min_active</a></li>
<li><a class="reference external" href="#zfs-vdev-scheduler">zfs_vdev_scheduler</a></li>
<li><a class="reference external" href="#zfs-vdev-scrub-max-active">zfs_vdev_scrub_max_active</a></li>
<li><a class="reference external" href="#zfs-vdev-scrub-min-active">zfs_vdev_scrub_min_active</a></li>
<li><a class="reference external" href="#zfs-vdev-sync-read-max-active">zfs_vdev_sync_read_max_active</a></li>
<li><a class="reference external" href="#zfs-vdev-sync-read-min-active">zfs_vdev_sync_read_min_active</a></li>
<li><a class="reference external" href="#zfs-vdev-sync-write-max-active">zfs_vdev_sync_write_max_active</a></li>
<li><a class="reference external" href="#zfs-vdev-sync-write-min-active">zfs_vdev_sync_write_min_active</a></li>
<li><a class="reference external" href="#zfs-vdev-trim-max-active">zfs_vdev_trim_max_active</a></li>
<li><a class="reference external" href="#zfs-vdev-trim-min-active">zfs_vdev_trim_min_active</a></li>
<li><a class="reference external" href="#zfs-vdev-write-gap-limit">zfs_vdev_write_gap_limit</a></li>
<li><a class="reference external" href="#zio-dva-throttle-enabled">zio_dva_throttle_enabled</a></li>
<li><a class="reference external" href="#zio-requeue-io-start-cut-in-line">zio_requeue_io_start_cut_in_line</a></li>
<li><a class="reference external" href="#zio-taskq-batch-pct">zio_taskq_batch_pct</a></li>
</ul>
</div>
</div>
<div class="section" id="index">
<h2>Index<a class="headerlink" href="#index" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference external" href="#zfs-abd-scatter-enabled">zfs_abd_scatter_enabled</a></li>
<li><a class="reference external" href="#zfs-abd-scatter-max-order">zfs_abd_scatter_max_order</a></li>
<li><a class="reference external" href="#zfs-abd-scatter-min-size">zfs_abd_scatter_min_size</a></li>
<li><a class="reference external" href="#zfs-admin-snapshot">zfs_admin_snapshot</a></li>
<li><a class="reference external" href="#zfs-arc-average-blocksize">zfs_arc_average_blocksize</a></li>
<li><a class="reference external" href="#zfs-arc-dnode-limit">zfs_arc_dnode_limit</a></li>
<li><a class="reference external" href="#zfs-arc-dnode-limit-percent">zfs_arc_dnode_limit_percent</a></li>
<li><a class="reference external" href="#zfs-arc-dnode-reduce-percent">zfs_arc_dnode_reduce_percent</a></li>
<li><a class="reference external" href="#zfs-arc-evict-batch-limit">zfs_arc_evict_batch_limit</a></li>
<li><a class="reference external" href="#zfs-arc-grow-retry">zfs_arc_grow_retry</a></li>
<li><a class="reference external" href="#zfs-arc-lotsfree-percent">zfs_arc_lotsfree_percent</a></li>
<li><a class="reference external" href="#zfs-arc-max">zfs_arc_max</a></li>
<li><a class="reference external" href="#zfs-arc-meta-adjust-restarts">zfs_arc_meta_adjust_restarts</a></li>
<li><a class="reference external" href="#zfs-arc-meta-limit">zfs_arc_meta_limit</a></li>
<li><a class="reference external" href="#zfs-arc-meta-limit-percent">zfs_arc_meta_limit_percent</a></li>
<li><a class="reference external" href="#zfs-arc-meta-min">zfs_arc_meta_min</a></li>
<li><a class="reference external" href="#zfs-arc-meta-prune">zfs_arc_meta_prune</a></li>
<li><a class="reference external" href="#zfs-arc-meta-strategy">zfs_arc_meta_strategy</a></li>
<li><a class="reference external" href="#zfs-arc-min">zfs_arc_min</a></li>
<li><a class="reference external" href="#zfs-arc-min-prefetch-lifespan">zfs_arc_min_prefetch_lifespan</a></li>
<li><a class="reference external" href="#zfs-arc-min-prefetch-ms">zfs_arc_min_prefetch_ms</a></li>
<li><a class="reference external" href="#zfs-arc-min-prescient-prefetch-ms">zfs_arc_min_prescient_prefetch_ms</a></li>
<li><a class="reference external" href="#zfs-arc-overflow-shift">zfs_arc_overflow_shift</a></li>
<li><a class="reference external" href="#zfs-arc-p-dampener-disable">zfs_arc_p_dampener_disable</a></li>
<li><a class="reference external" href="#zfs-arc-p-min-shift">zfs_arc_p_min_shift</a></li>
<li><a class="reference external" href="#zfs-arc-pc-percent">zfs_arc_pc_percent</a></li>
<li><a class="reference external" href="#zfs-arc-shrink-shift">zfs_arc_shrink_shift</a></li>
<li><a class="reference external" href="#zfs-arc-sys-free">zfs_arc_sys_free</a></li>
<li><a class="reference external" href="#zfs-async-block-max-blocks">zfs_async_block_max_blocks</a></li>
<li><a class="reference external" href="#zfs-autoimport-disable">zfs_autoimport_disable</a></li>
<li><a class="reference external" href="#zfs-checksum-events-per-second">zfs_checksum_events_per_second</a></li>
<li><a class="reference external" href="#zfs-checksums-per-second">zfs_checksums_per_second</a></li>
<li><a class="reference external" href="#zfs-commit-timeout-pct">zfs_commit_timeout_pct</a></li>
<li><a class="reference external" href="#zfs-compressed-arc-enabled">zfs_compressed_arc_enabled</a></li>
<li><a class="reference external" href="#zfs-condense-indirect-commit-entry-delay-ms">zfs_condense_indirect_commit_entry_delay_ms</a></li>
<li><a class="reference external" href="#zfs-condense-indirect-vdevs-enable">zfs_condense_indirect_vdevs_enable</a></li>
<li><a class="reference external" href="#zfs-condense-max-obsolete-bytes">zfs_condense_max_obsolete_bytes</a></li>
<li><a class="reference external" href="#zfs-condense-min-mapping-bytes">zfs_condense_min_mapping_bytes</a></li>
<li><a class="reference external" href="#zfs-dbgmsg-enable">zfs_dbgmsg_enable</a></li>
<li><a class="reference external" href="#zfs-dbgmsg-maxsize">zfs_dbgmsg_maxsize</a></li>
<li><a class="reference external" href="#dbuf-cache-hiwater-pct">dbuf_cache_hiwater_pct</a></li>
<li><a class="reference external" href="#dbuf-cache-lowater-pct">dbuf_cache_lowater_pct</a></li>
<li><a class="reference external" href="#dbuf-cache-max-bytes">dbuf_cache_max_bytes</a></li>
<li><a class="reference external" href="#dbuf-cache-max-shift">dbuf_cache_max_shift</a></li>
<li><a class="reference external" href="#dbuf-cache-shift">dbuf_cache_shift</a></li>
<li><a class="reference external" href="#dbuf-metadata-cache-max-bytes">dbuf_metadata_cache_max_bytes</a></li>
<li><a class="reference external" href="#dbuf-metadata-cache-shift">dbuf_metadata_cache_shift</a></li>
<li><a class="reference external" href="#zfs-dbuf-state-index">zfs_dbuf_state_index</a></li>
<li><a class="reference external" href="#zfs-ddt-data-is-special">zfs_ddt_data_is_special</a></li>
<li><a class="reference external" href="#zfs-deadman-checktime-ms">zfs_deadman_checktime_ms</a></li>
<li><a class="reference external" href="#zfs-deadman-enabled">zfs_deadman_enabled</a></li>
<li><a class="reference external" href="#zfs-deadman-failmode">zfs_deadman_failmode</a></li>
<li><a class="reference external" href="#zfs-deadman-synctime-ms">zfs_deadman_synctime_ms</a></li>
<li><a class="reference external" href="#zfs-deadman-ziotime-ms">zfs_deadman_ziotime_ms</a></li>
<li><a class="reference external" href="#zfs-dedup-prefetch">zfs_dedup_prefetch</a></li>
<li><a class="reference external" href="#zfs-delay-min-dirty-percent">zfs_delay_min_dirty_percent</a></li>
<li><a class="reference external" href="#zfs-delay-scale">zfs_delay_scale</a></li>
<li><a class="reference external" href="#zfs-delays-per-second">zfs_delays_per_second</a></li>
<li><a class="reference external" href="#zfs-delete-blocks">zfs_delete_blocks</a></li>
<li><a class="reference external" href="#zfs-dirty-data-max">zfs_dirty_data_max</a></li>
<li><a class="reference external" href="#zfs-dirty-data-max-max">zfs_dirty_data_max_max</a></li>
<li><a class="reference external" href="#zfs-dirty-data-max-max-percent">zfs_dirty_data_max_max_percent</a></li>
<li><a class="reference external" href="#zfs-dirty-data-max-percent">zfs_dirty_data_max_percent</a></li>
<li><a class="reference external" href="#zfs-dirty-data-sync">zfs_dirty_data_sync</a></li>
<li><a class="reference external" href="#zfs-dirty-data-sync-percent">zfs_dirty_data_sync_percent</a></li>
<li><a class="reference external" href="#zfs-disable-dup-eviction">zfs_disable_dup_eviction</a></li>
<li><a class="reference external" href="#zfs-disable-ivset-guid-check">zfs_disable_ivset_guid_check</a></li>
<li><a class="reference external" href="#dmu-object-alloc-chunk-shift">dmu_object_alloc_chunk_shift</a></li>
<li><a class="reference external" href="#zfs-dmu-offset-next-sync">zfs_dmu_offset_next_sync</a></li>
<li><a class="reference external" href="#zfs-expire-snapshot">zfs_expire_snapshot</a></li>
<li><a class="reference external" href="#zfs-flags">zfs_flags</a></li>
<li><a class="reference external" href="#zfs-fletcher-4-impl">zfs_fletcher_4_impl</a></li>
<li><a class="reference external" href="#zfs-free-bpobj-enabled">zfs_free_bpobj_enabled</a></li>
<li><a class="reference external" href="#zfs-free-leak-on-eio">zfs_free_leak_on_eio</a></li>
<li><a class="reference external" href="#zfs-free-max-blocks">zfs_free_max_blocks</a></li>
<li><a class="reference external" href="#zfs-free-min-time-ms">zfs_free_min_time_ms</a></li>
<li><a class="reference external" href="#icp-aes-impl">icp_aes_impl</a></li>
<li><a class="reference external" href="#icp-gcm-impl">icp_gcm_impl</a></li>
<li><a class="reference external" href="#ignore-hole-birth">ignore_hole_birth</a></li>
<li><a class="reference external" href="#zfs-immediate-write-sz">zfs_immediate_write_sz</a></li>
<li><a class="reference external" href="#zfs-initialize-value">zfs_initialize_value</a></li>
<li><a class="reference external" href="#zfs-key-max-salt-uses">zfs_key_max_salt_uses</a></li>
<li><a class="reference external" href="#l2arc-feed-again">l2arc_feed_again</a></li>
<li><a class="reference external" href="#l2arc-feed-min-ms">l2arc_feed_min_ms</a></li>
<li><a class="reference external" href="#l2arc-feed-secs">l2arc_feed_secs</a></li>
<li><a class="reference external" href="#l2arc-headroom">l2arc_headroom</a></li>
<li><a class="reference external" href="#l2arc-headroom-boost">l2arc_headroom_boost</a></li>
<li><a class="reference external" href="#l2arc-nocompress">l2arc_nocompress</a></li>
<li><a class="reference external" href="#l2arc-noprefetch">l2arc_noprefetch</a></li>
<li><a class="reference external" href="#l2arc-norw">l2arc_norw</a></li>
<li><a class="reference external" href="#l2arc-write-boost">l2arc_write_boost</a></li>
<li><a class="reference external" href="#l2arc-write-max">l2arc_write_max</a></li>
<li><a class="reference external" href="#zfs-lua-max-instrlimit">zfs_lua_max_instrlimit</a></li>
<li><a class="reference external" href="#zfs-lua-max-memlimit">zfs_lua_max_memlimit</a></li>
<li><a class="reference external" href="#zfs-max-dataset-nesting">zfs_max_dataset_nesting</a></li>
<li><a class="reference external" href="#zfs-max-missing-tvds">zfs_max_missing_tvds</a></li>
<li><a class="reference external" href="#zfs-max-recordsize">zfs_max_recordsize</a></li>
<li><a class="reference external" href="#zfs-mdcomp-disable">zfs_mdcomp_disable</a></li>
<li><a class="reference external" href="#metaslab-aliquot">metaslab_aliquot</a></li>
<li><a class="reference external" href="#metaslab-bias-enabled">metaslab_bias_enabled</a></li>
<li><a class="reference external" href="#metaslab-debug-load">metaslab_debug_load</a></li>
<li><a class="reference external" href="#metaslab-debug-unload">metaslab_debug_unload</a></li>
<li><a class="reference external" href="#metaslab-force-ganging">metaslab_force_ganging</a></li>
<li><a class="reference external" href="#metaslab-fragmentation-factor-enabled">metaslab_fragmentation_factor_enabled</a></li>
<li><a class="reference external" href="#zfs-metaslab-fragmentation-threshold">zfs_metaslab_fragmentation_threshold</a></li>
<li><a class="reference external" href="#metaslab-lba-weighting-enabled">metaslab_lba_weighting_enabled</a></li>
<li><a class="reference external" href="#metaslab-preload-enabled">metaslab_preload_enabled</a></li>
<li><a class="reference external" href="#zfs-metaslab-segment-weight-enabled">zfs_metaslab_segment_weight_enabled</a></li>
<li><a class="reference external" href="#zfs-metaslab-switch-threshold">zfs_metaslab_switch_threshold</a></li>
<li><a class="reference external" href="#metaslabs-per-vdev">metaslabs_per_vdev</a></li>
<li><a class="reference external" href="#zfs-mg-fragmentation-threshold">zfs_mg_fragmentation_threshold</a></li>
<li><a class="reference external" href="#zfs-mg-noalloc-threshold">zfs_mg_noalloc_threshold</a></li>
<li><a class="reference external" href="#zfs-multihost-fail-intervals">zfs_multihost_fail_intervals</a></li>
<li><a class="reference external" href="#zfs-multihost-history">zfs_multihost_history</a></li>
<li><a class="reference external" href="#zfs-multihost-import-intervals">zfs_multihost_import_intervals</a></li>
<li><a class="reference external" href="#zfs-multihost-interval">zfs_multihost_interval</a></li>
<li><a class="reference external" href="#zfs-multilist-num-sublists">zfs_multilist_num_sublists</a></li>
<li><a class="reference external" href="#zfs-no-scrub-io">zfs_no_scrub_io</a></li>
<li><a class="reference external" href="#zfs-no-scrub-prefetch">zfs_no_scrub_prefetch</a></li>
<li><a class="reference external" href="#zfs-nocacheflush">zfs_nocacheflush</a></li>
<li><a class="reference external" href="#zfs-nopwrite-enabled">zfs_nopwrite_enabled</a></li>
<li><a class="reference external" href="#zfs-object-mutex-size">zfs_object_mutex_size</a></li>
<li><a class="reference external" href="#zfs-obsolete-min-time-ms">zfs_obsolete_min_time_ms</a></li>
<li><a class="reference external" href="#zfs-override-estimate-recordsize">zfs_override_estimate_recordsize</a></li>
<li><a class="reference external" href="#zfs-pd-bytes-max">zfs_pd_bytes_max</a></li>
<li><a class="reference external" href="#zfs-per-txg-dirty-frees-percent">zfs_per_txg_dirty_frees_percent</a></li>
<li><a class="reference external" href="#zfs-prefetch-disable">zfs_prefetch_disable</a></li>
<li><a class="reference external" href="#zfs-qat-checksum-disable">zfs_qat_checksum_disable</a></li>
<li><a class="reference external" href="#zfs-qat-compress-disable">zfs_qat_compress_disable</a></li>
<li><a class="reference external" href="#zfs-qat-disable">zfs_qat_disable</a></li>
<li><a class="reference external" href="#zfs-qat-encrypt-disable">zfs_qat_encrypt_disable</a></li>
<li><a class="reference external" href="#zfs-read-chunk-size">zfs_read_chunk_size</a></li>
<li><a class="reference external" href="#zfs-read-history">zfs_read_history</a></li>
<li><a class="reference external" href="#zfs-read-history-hits">zfs_read_history_hits</a></li>
<li><a class="reference external" href="#zfs-reconstruct-indirect-combinations-max">zfs_reconstruct_indirect_combinations_max</a></li>
<li><a class="reference external" href="#zfs-recover">zfs_recover</a></li>
<li><a class="reference external" href="#zfs-recv-queue-length">zfs_recv_queue_length</a></li>
<li><a class="reference external" href="#zfs-removal-ignore-errors">zfs_removal_ignore_errors</a></li>
<li><a class="reference external" href="#zfs-removal-suspend-progress">zfs_removal_suspend_progress</a></li>
<li><a class="reference external" href="#zfs-remove-max-segment">zfs_remove_max_segment</a></li>
<li><a class="reference external" href="#zfs-resilver-delay">zfs_resilver_delay</a></li>
<li><a class="reference external" href="#zfs-resilver-disable-defer">zfs_resilver_disable_defer</a></li>
<li><a class="reference external" href="#zfs-resilver-min-time-ms">zfs_resilver_min_time_ms</a></li>
<li><a class="reference external" href="#zfs-scan-checkpoint-intval">zfs_scan_checkpoint_intval</a></li>
<li><a class="reference external" href="#zfs-scan-fill-weight">zfs_scan_fill_weight</a></li>
<li><a class="reference external" href="#zfs-scan-idle">zfs_scan_idle</a></li>
<li><a class="reference external" href="#zfs-scan-ignore-errors">zfs_scan_ignore_errors</a></li>
<li><a class="reference external" href="#zfs-scan-issue-strategy">zfs_scan_issue_strategy</a></li>
<li><a class="reference external" href="#zfs-scan-legacy">zfs_scan_legacy</a></li>
<li><a class="reference external" href="#zfs-scan-max-ext-gap">zfs_scan_max_ext_gap</a></li>
<li><a class="reference external" href="#zfs-scan-mem-lim-fact">zfs_scan_mem_lim_fact</a></li>
<li><a class="reference external" href="#zfs-scan-mem-lim-soft-fact">zfs_scan_mem_lim_soft_fact</a></li>
<li><a class="reference external" href="#zfs-scan-min-time-ms">zfs_scan_min_time_ms</a></li>
<li><a class="reference external" href="#zfs-scan-strict-mem-lim">zfs_scan_strict_mem_lim</a></li>
<li><a class="reference external" href="#zfs-scan-suspend-progress">zfs_scan_suspend_progress</a></li>
<li><a class="reference external" href="#zfs-scan-vdev-limit">zfs_scan_vdev_limit</a></li>
<li><a class="reference external" href="#zfs-scrub-delay">zfs_scrub_delay</a></li>
<li><a class="reference external" href="#zfs-scrub-min-time-ms">zfs_scrub_min_time_ms</a></li>
<li><a class="reference external" href="#zfs-send-corrupt-data">zfs_send_corrupt_data</a></li>
<li><a class="reference external" href="#send-holes-without-birth-time">send_holes_without_birth_time</a></li>
<li><a class="reference external" href="#zfs-send-queue-length">zfs_send_queue_length</a></li>
<li><a class="reference external" href="#zfs-send-unmodified-spill-blocks">zfs_send_unmodified_spill_blocks</a></li>
<li><a class="reference external" href="#zfs-slow-io-events-per-second">zfs_slow_io_events_per_second</a></li>
<li><a class="reference external" href="#spa-asize-inflation">spa_asize_inflation</a></li>
<li><a class="reference external" href="#spa-config-path">spa_config_path</a></li>
<li><a class="reference external" href="#zfs-spa-discard-memory-limit">zfs_spa_discard_memory_limit</a></li>
<li><a class="reference external" href="#spa-load-print-vdev-tree">spa_load_print_vdev_tree</a></li>
<li><a class="reference external" href="#spa-load-verify-data">spa_load_verify_data</a></li>
<li><a class="reference external" href="#spa-load-verify-maxinflight">spa_load_verify_maxinflight</a></li>
<li><a class="reference external" href="#spa-load-verify-metadata">spa_load_verify_metadata</a></li>
<li><a class="reference external" href="#spa-load-verify-shift">spa_load_verify_shift</a></li>
<li><a class="reference external" href="#spa-slop-shift">spa_slop_shift</a></li>
<li><a class="reference external" href="#zfs-special-class-metadata-reserve-pct">zfs_special_class_metadata_reserve_pct</a></li>
<li><a class="reference external" href="#spl-hostid">spl_hostid</a></li>
<li><a class="reference external" href="#spl-hostid-path">spl_hostid_path</a></li>
<li><a class="reference external" href="#spl-kmem-alloc-max">spl_kmem_alloc_max</a></li>
<li><a class="reference external" href="#spl-kmem-alloc-warn">spl_kmem_alloc_warn</a></li>
<li><a class="reference external" href="#spl-kmem-cache-expire">spl_kmem_cache_expire</a></li>
<li><a class="reference external" href="#spl-kmem-cache-kmem-limit">spl_kmem_cache_kmem_limit</a></li>
<li><a class="reference external" href="#spl-kmem-cache-kmem-threads">spl_kmem_cache_kmem_threads</a></li>
<li><a class="reference external" href="#spl-kmem-cache-magazine-size">spl_kmem_cache_magazine_size</a></li>
<li><a class="reference external" href="#spl-kmem-cache-max-size">spl_kmem_cache_max_size</a></li>
<li><a class="reference external" href="#spl-kmem-cache-obj-per-slab">spl_kmem_cache_obj_per_slab</a></li>
<li><a class="reference external" href="#spl-kmem-cache-obj-per-slab-min">spl_kmem_cache_obj_per_slab_min</a></li>
<li><a class="reference external" href="#spl-kmem-cache-reclaim">spl_kmem_cache_reclaim</a></li>
<li><a class="reference external" href="#spl-kmem-cache-slab-limit">spl_kmem_cache_slab_limit</a></li>
<li><a class="reference external" href="#spl-max-show-tasks">spl_max_show_tasks</a></li>
<li><a class="reference external" href="#spl-panic-halt">spl_panic_halt</a></li>
<li><a class="reference external" href="#spl-taskq-kick">spl_taskq_kick</a></li>
<li><a class="reference external" href="#spl-taskq-thread-bind">spl_taskq_thread_bind</a></li>
<li><a class="reference external" href="#spl-taskq-thread-dynamic">spl_taskq_thread_dynamic</a></li>
<li><a class="reference external" href="#spl-taskq-thread-priority">spl_taskq_thread_priority</a></li>
<li><a class="reference external" href="#spl-taskq-thread-sequential">spl_taskq_thread_sequential</a></li>
<li><a class="reference external" href="#zfs-sync-pass-deferred-free">zfs_sync_pass_deferred_free</a></li>
<li><a class="reference external" href="#zfs-sync-pass-dont-compress">zfs_sync_pass_dont_compress</a></li>
<li><a class="reference external" href="#zfs-sync-pass-rewrite">zfs_sync_pass_rewrite</a></li>
<li><a class="reference external" href="#zfs-sync-taskq-batch-pct">zfs_sync_taskq_batch_pct</a></li>
<li><a class="reference external" href="#zfs-top-maxinflight">zfs_top_maxinflight</a></li>
<li><a class="reference external" href="#zfs-trim-extent-bytes-max">zfs_trim_extent_bytes_max</a></li>
<li><a class="reference external" href="#zfs-trim-extent-bytes-min">zfs_trim_extent_bytes_min</a></li>
<li><a class="reference external" href="#zfs-trim-metaslab-skip">zfs_trim_metaslab_skip</a></li>
<li><a class="reference external" href="#zfs-trim-queue-limit">zfs_trim_queue_limit</a></li>
<li><a class="reference external" href="#zfs-trim-txg-batch">zfs_trim_txg_batch</a></li>
<li><a class="reference external" href="#zfs-txg-history">zfs_txg_history</a></li>
<li><a class="reference external" href="#zfs-txg-timeout">zfs_txg_timeout</a></li>
<li><a class="reference external" href="#zfs-unlink-suspend-progress">zfs_unlink_suspend_progress</a></li>
<li><a class="reference external" href="#zfs-user-indirect-is-special">zfs_user_indirect_is_special</a></li>
<li><a class="reference external" href="#zfs-vdev-aggregate-trim">zfs_vdev_aggregate_trim</a></li>
<li><a class="reference external" href="#zfs-vdev-aggregation-limit">zfs_vdev_aggregation_limit</a></li>
<li><a class="reference external" href="#zfs-vdev-aggregation-limit-non-rotating">zfs_vdev_aggregation_limit_non_rotating</a></li>
<li><a class="reference external" href="#zfs-vdev-async-read-max-active">zfs_vdev_async_read_max_active</a></li>
<li><a class="reference external" href="#zfs-vdev-async-read-min-active">zfs_vdev_async_read_min_active</a></li>
<li><a class="reference external" href="#zfs-vdev-async-write-active-max-dirty-percent">zfs_vdev_async_write_active_max_dirty_percent</a></li>
<li><a class="reference external" href="#zfs-vdev-async-write-active-min-dirty-percent">zfs_vdev_async_write_active_min_dirty_percent</a></li>
<li><a class="reference external" href="#zfs-vdev-async-write-max-active">zfs_vdev_async_write_max_active</a></li>
<li><a class="reference external" href="#zfs-vdev-async-write-min-active">zfs_vdev_async_write_min_active</a></li>
<li><a class="reference external" href="#zfs-vdev-cache-bshift">zfs_vdev_cache_bshift</a></li>
<li><a class="reference external" href="#zfs-vdev-cache-max">zfs_vdev_cache_max</a></li>
<li><a class="reference external" href="#zfs-vdev-cache-size">zfs_vdev_cache_size</a></li>
<li><a class="reference external" href="#zfs-vdev-default-ms-count">zfs_vdev_default_ms_count</a></li>
<li><a class="reference external" href="#zfs-vdev-initializing-max-active">zfs_vdev_initializing_max_active</a></li>
<li><a class="reference external" href="#zfs-vdev-initializing-min-active">zfs_vdev_initializing_min_active</a></li>
<li><a class="reference external" href="#zfs-vdev-max-active">zfs_vdev_max_active</a></li>
<li><a class="reference external" href="#zfs-vdev-min-ms-count">zfs_vdev_min_ms_count</a></li>
<li><a class="reference external" href="#zfs-vdev-mirror-non-rotating-inc">zfs_vdev_mirror_non_rotating_inc</a></li>
<li><a class="reference external" href="#zfs-vdev-mirror-non-rotating-seek-inc">zfs_vdev_mirror_non_rotating_seek_inc</a></li>
<li><a class="reference external" href="#zfs-vdev-mirror-rotating-inc">zfs_vdev_mirror_rotating_inc</a></li>
<li><a class="reference external" href="#zfs-vdev-mirror-rotating-seek-inc">zfs_vdev_mirror_rotating_seek_inc</a></li>
<li><a class="reference external" href="#zfs-vdev-mirror-rotating-seek-offset">zfs_vdev_mirror_rotating_seek_offset</a></li>
<li><a class="reference external" href="#zfs-vdev-ms-count-limit">zfs_vdev_ms_count_limit</a></li>
<li><a class="reference external" href="#zfs-vdev-queue-depth-pct">zfs_vdev_queue_depth_pct</a></li>
<li><a class="reference external" href="#zfs-vdev-raidz-impl">zfs_vdev_raidz_impl</a></li>
<li><a class="reference external" href="#zfs-vdev-read-gap-limit">zfs_vdev_read_gap_limit</a></li>
<li><a class="reference external" href="#zfs-vdev-removal-max-active">zfs_vdev_removal_max_active</a></li>
<li><a class="reference external" href="#vdev-removal-max-span">vdev_removal_max_span</a></li>
<li><a class="reference external" href="#zfs-vdev-removal-min-active">zfs_vdev_removal_min_active</a></li>
<li><a class="reference external" href="#zfs-vdev-scheduler">zfs_vdev_scheduler</a></li>
<li><a class="reference external" href="#zfs-vdev-scrub-max-active">zfs_vdev_scrub_max_active</a></li>
<li><a class="reference external" href="#zfs-vdev-scrub-min-active">zfs_vdev_scrub_min_active</a></li>
<li><a class="reference external" href="#zfs-vdev-sync-read-max-active">zfs_vdev_sync_read_max_active</a></li>
<li><a class="reference external" href="#zfs-vdev-sync-read-min-active">zfs_vdev_sync_read_min_active</a></li>
<li><a class="reference external" href="#zfs-vdev-sync-write-max-active">zfs_vdev_sync_write_max_active</a></li>
<li><a class="reference external" href="#zfs-vdev-sync-write-min-active">zfs_vdev_sync_write_min_active</a></li>
<li><a class="reference external" href="#zfs-vdev-trim-max-active">zfs_vdev_trim_max_active</a></li>
<li><a class="reference external" href="#zfs-vdev-trim-min-active">zfs_vdev_trim_min_active</a></li>
<li><a class="reference external" href="#vdev-validate-skip">vdev_validate_skip</a></li>
<li><a class="reference external" href="#zfs-vdev-write-gap-limit">zfs_vdev_write_gap_limit</a></li>
<li><a class="reference external" href="#zfs-zevent-cols">zfs_zevent_cols</a></li>
<li><a class="reference external" href="#zfs-zevent-console">zfs_zevent_console</a></li>
<li><a class="reference external" href="#zfs-zevent-len-max">zfs_zevent_len_max</a></li>
<li><a class="reference external" href="#zfetch-array-rd-sz">zfetch_array_rd_sz</a></li>
<li><a class="reference external" href="#zfetch-max-distance">zfetch_max_distance</a></li>
<li><a class="reference external" href="#zfetch-max-streams">zfetch_max_streams</a></li>
<li><a class="reference external" href="#zfetch-min-sec-reap">zfetch_min_sec_reap</a></li>
<li><a class="reference external" href="#zfs-zil-clean-taskq-maxalloc">zfs_zil_clean_taskq_maxalloc</a></li>
<li><a class="reference external" href="#zfs-zil-clean-taskq-minalloc">zfs_zil_clean_taskq_minalloc</a></li>
<li><a class="reference external" href="#zfs-zil-clean-taskq-nthr-pct">zfs_zil_clean_taskq_nthr_pct</a></li>
<li><a class="reference external" href="#zil-nocacheflush">zil_nocacheflush</a></li>
<li><a class="reference external" href="#zil-replay-disable">zil_replay_disable</a></li>
<li><a class="reference external" href="#zil-slog-bulk">zil_slog_bulk</a></li>
<li><a class="reference external" href="#zio-deadman-log-all">zio_deadman_log_all</a></li>
<li><a class="reference external" href="#zio-decompress-fail-fraction">zio_decompress_fail_fraction</a></li>
<li><a class="reference external" href="#zio-delay-max">zio_delay_max</a></li>
<li><a class="reference external" href="#zio-dva-throttle-enabled">zio_dva_throttle_enabled</a></li>
<li><a class="reference external" href="#zio-requeue-io-start-cut-in-line">zio_requeue_io_start_cut_in_line</a></li>
<li><a class="reference external" href="#zio-slow-io-ms">zio_slow_io_ms</a></li>
<li><a class="reference external" href="#zio-taskq-batch-pct">zio_taskq_batch_pct</a></li>
<li><a class="reference external" href="#zvol-inhibit-dev">zvol_inhibit_dev</a></li>
<li><a class="reference external" href="#zvol-major">zvol_major</a></li>
<li><a class="reference external" href="#zvol-max-discard-blocks">zvol_max_discard_blocks</a></li>
<li><a class="reference external" href="#zvol-prefetch-bytes">zvol_prefetch_bytes</a></li>
<li><a class="reference external" href="#zvol-request-sync">zvol_request_sync</a></li>
<li><a class="reference external" href="#zvol-threads">zvol_threads</a></li>
<li><a class="reference external" href="#zvol-volmode">zvol_volmode</a></li>
</ul>
</div>
<div class="section" id="module-parameters">
<span id="zfs-module-parameters-1"></span><h2>Module Parameters<a class="headerlink" href="#module-parameters" title="Permalink to this headline">¶</a></h2>
<div class="section" id="ignore-hole-birth">
<h3>ignore_hole_birth<a class="headerlink" href="#ignore-hole-birth" title="Permalink to this headline">¶</a></h3>
<p>When set, the hole_birth optimization will not be used and all holes
will always be sent by <code class="docutils literal notranslate"><span class="pre">zfs</span> <span class="pre">send</span></code> In the source code,
ignore_hole_birth is an alias for and SysFS PARAMETER for
<a class="reference external" href="#send-holes-without-birth-time">send_holes_without_birth_time</a>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">ignore_hole_birth</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#send">send</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Enable if you suspect your datasets are
affected by a bug in hole_birth during
<code class="docutils literal notranslate"><span class="pre">zfs</span> <span class="pre">send</span></code> operations</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=disabled, 1=enabled</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>1 (hole birth optimization is ignored)</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>TBD</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="l2arc-feed-again">
<h3>l2arc_feed_again<a class="headerlink" href="#l2arc-feed-again" title="Permalink to this headline">¶</a></h3>
<p>Turbo L2ARC cache warm-up. When the L2ARC is cold the fill interval will
be set to aggressively fill as fast as possible.</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">l2arc_feed_again</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#arc">ARC</a>, <a class="reference external" href="#l2arc">L2ARC</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>If cache devices exist and it is desired to
fill them as fast as possible</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=disabled, 1=enabled</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>TBD</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="l2arc-feed-min-ms">
<h3>l2arc_feed_min_ms<a class="headerlink" href="#l2arc-feed-min-ms" title="Permalink to this headline">¶</a></h3>
<p>Minimum time period for aggressively feeding the L2ARC. The L2ARC feed
thread wakes up once per second (see
<a class="reference external" href="#l2arc-feed-secs">l2arc_feed_secs</a>) to look for data to feed into
the L2ARC. <code class="docutils literal notranslate"><span class="pre">l2arc_feed_min_ms</span></code> only affects the turbo L2ARC cache
warm-up and allows the aggressiveness to be adjusted.</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">l2arc_feed_min_ms</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#arc">ARC</a>, <a class="reference external" href="#l2arc">L2ARC</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>If cache devices exist and
<a class="reference external" href="#l2arc-feed-again">l2arc_feed_again</a> and
the feed is too aggressive, then this tunable
can be adjusted to reduce the impact of the
fill</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint64</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>milliseconds</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to (1000 * l2arc_feed_secs)</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>200</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>0.6 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="l2arc-feed-secs">
<h3>l2arc_feed_secs<a class="headerlink" href="#l2arc-feed-secs" title="Permalink to this headline">¶</a></h3>
<p>Seconds between waking the L2ARC feed thread. One feed thread works for
all cache devices in turn.</p>
<p>If the pool that owns a cache device is imported readonly, then the feed
thread is delayed 5 * <a class="reference external" href="#l2arc-feed-secs">l2arc_feed_secs</a> before
moving onto the next cache device. If multiple pools are imported with
cache devices and one pool with cache is imported readonly, the L2ARC
feed rate to all caches can be slowed.</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">l2arc_feed_secs</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#arc">ARC</a>, <a class="reference external" href="#l2arc">L2ARC</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Do not change</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint64</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>seconds</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to UINT64_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>1</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>0.6 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="l2arc-headroom">
<h3>l2arc_headroom<a class="headerlink" href="#l2arc-headroom" title="Permalink to this headline">¶</a></h3>
<p>How far through the ARC lists to search for L2ARC cacheable content,
expressed as a multiplier of <a class="reference external" href="#l2arc-write-max">l2arc_write_max</a></p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">l2arc_headroom</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#arc">ARC</a>, <a class="reference external" href="#l2arc">L2ARC</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>If the rate of change in the ARC is faster than
the overall L2ARC feed rate, then increasing
l2arc_headroom can increase L2ARC efficiency.
Setting the value too large can cause the L2ARC
feed thread to consume more CPU time looking
for data to feed.</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint64</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>unit</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to UINT64_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>2</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>0.6 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="l2arc-headroom-boost">
<h3>l2arc_headroom_boost<a class="headerlink" href="#l2arc-headroom-boost" title="Permalink to this headline">¶</a></h3>
<p>Percentage scale for <a class="reference external" href="#l2arc-headroom">l2arc_headroom</a> when L2ARC
contents are being successfully compressed before writing.</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">l2arc_headroom_boost</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#arc">ARC</a>, <a class="reference external" href="#l2arc">L2ARC</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>If average compression efficiency is greater
than 2:1, then increasing
<a class="reference external" href="#l2arc-headroom-boost">l2a
rc_headroom_boost</a>
can increase the L2ARC feed rate</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint64</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>percent</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>100 to UINT64_MAX, when set to 100, the
L2ARC headroom boost feature is effectively
disabled</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>200</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="l2arc-nocompress">
<h3>l2arc_nocompress<a class="headerlink" href="#l2arc-nocompress" title="Permalink to this headline">¶</a></h3>
<p>Disable writing compressed data to cache devices. Disabling allows the
legacy behavior of writing decompressed data to cache devices.</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">l2arc_nocompress</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#arc">ARC</a>, <a class="reference external" href="#l2arc">L2ARC</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>When testing compressed L2ARC feature</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=store compressed blocks in cache device,
1=store uncompressed blocks in cache device</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>deprecated in v0.7.0 by new compressed ARC
design</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="l2arc-noprefetch">
<h3>l2arc_noprefetch<a class="headerlink" href="#l2arc-noprefetch" title="Permalink to this headline">¶</a></h3>
<p>Disables writing prefetched, but unused, buffers to cache devices.</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">l2arc_noprefetch</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#arc">ARC</a>, <a class="reference external" href="#l2arc">L2ARC</a>,
<a class="reference external" href="#prefetch">prefetch</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Setting to 0 can increase L2ARC hit rates for
workloads where the ARC is too small for a read
workload that benefits from prefetching. Also,
if the main pool devices are very slow, setting
to 0 can improve some workloads such as
backups.</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=write prefetched but unused buffers to cache
devices, 1=do not write prefetched but unused
buffers to cache devices</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.6.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="l2arc-norw">
<h3>l2arc_norw<a class="headerlink" href="#l2arc-norw" title="Permalink to this headline">¶</a></h3>
<p>Disables writing to cache devices while they are being read.</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">l2arc_norw</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#arc">ARC</a>, <a class="reference external" href="#l2arc">L2ARC</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>In the early days of SSDs, some devices did not
perform well when reading and writing
simultaneously. Modern SSDs do not have these
issues.</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=read and write simultaneously, 1=avoid writes
when reading for antique SSDs</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="l2arc-write-boost">
<h3>l2arc_write_boost<a class="headerlink" href="#l2arc-write-boost" title="Permalink to this headline">¶</a></h3>
<p>Until the ARC fills, increases the L2ARC fill rate
<a class="reference external" href="#l2arc-write-max">l2arc_write_max</a> by <code class="docutils literal notranslate"><span class="pre">l2arc_write_boost</span></code>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">l2arc_write_boost</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#arc">ARC</a>, <a class="reference external" href="#l2arc">L2ARC</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>To fill the cache devices more aggressively
after pool import.</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint64</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to UINT64_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>8,388,608</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="l2arc-write-max">
<h3>l2arc_write_max<a class="headerlink" href="#l2arc-write-max" title="Permalink to this headline">¶</a></h3>
<p>Maximum number of bytes to be written to each cache device for each
L2ARC feed thread interval (see <a class="reference external" href="#l2arc-feed-secs">l2arc_feed_secs</a>).
The actual limit can be adjusted by
<a class="reference external" href="#l2arc-write-boost">l2arc_write_boost</a>. By default
<a class="reference external" href="#l2arc-feed-secs">l2arc_feed_secs</a> is 1 second, delivering a maximum
write workload to cache devices of 8 MiB/sec.</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">l2arc_write_max</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#arc">ARC</a>, <a class="reference external" href="#l2arc">L2ARC</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>If the cache devices can sustain the write
workload, increasing the rate of cache device
fill when workloads generate new data at a rate
higher than l2arc_write_max can increase L2ARC
hit rate</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint64</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to UINT64_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>8,388,608</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="metaslab-aliquot">
<h3>metaslab_aliquot<a class="headerlink" href="#metaslab-aliquot" title="Permalink to this headline">¶</a></h3>
<p>Sets the metaslab granularity. Nominally, ZFS will try to allocate this
amount of data to a top-level vdev before moving on to the next
top-level vdev. This is roughly similar to what would be referred to as
the “stripe size” in traditional RAID arrays.</p>
<p>When tuning for HDDs, it can be more efficient to have a few larger,
sequential writes to a device rather than switching to the next device.
Monitoring the size of contiguous writes to the disks relative to the
write throughput can be used to determine if increasing
<code class="docutils literal notranslate"><span class="pre">metaslab_aliquot</span></code> can help. For modern devices, it is unlikely that
decreasing <code class="docutils literal notranslate"><span class="pre">metaslab_aliquot</span></code> from the default will help.</p>
<p>If there is only one top-level vdev, this tunable is not used.</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">metaslab_aliquot</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#allocation">allocation</a>,
<a class="reference external" href="#metaslab">metaslab</a>, <a class="reference external" href="#vdev">vdev</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>If write performance increases as devices more
efficiently write larger, contiguous blocks</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint64</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to UINT64_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>524,288</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="metaslab-bias-enabled">
<h3>metaslab_bias_enabled<a class="headerlink" href="#metaslab-bias-enabled" title="Permalink to this headline">¶</a></h3>
<p>Enables metaslab group biasing based on a top-level vdev’s utilization
relative to the pool. Nominally, all top-level devs are the same size
and the allocation is spread evenly. When the top-level vdevs are not of
the same size, for example if a new (empty) top-level is added to the
pool, this allows the new top-level vdev to get a larger portion of new
allocations.</p>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">metaslab_bias_enabled</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#allocation">allocation</a>,
<a class="reference external" href="#metaslab">metaslab</a>, <a class="reference external" href="#vdev">vdev</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>If a new top-level vdev is added and you do
not want to bias new allocations to the new
top-level vdev</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=spread evenly across top-level vdevs,
1=bias spread to favor less full top-level
vdevs</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.6.4 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-metaslab-segment-weight-enabled">
<h3>zfs_metaslab_segment_weight_enabled<a class="headerlink" href="#zfs-metaslab-segment-weight-enabled" title="Permalink to this headline">¶</a></h3>
<p>Enables metaslab allocation based on largest free segment rather than
total amount of free space. The goal is to avoid metaslabs that exhibit
free space fragmentation: when there is a lot of small free spaces, but
few larger free spaces.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">zfs_metaslab_segment_weight_enabled</span></code> is enabled, then
<a class="reference external" href="#metaslab-fragmentation-factor-enabled">metaslab_fragmentation_factor_enabled</a>
is ignored.</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs
_metaslab_segment_weight_enabled</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#allocation">allocation</a>,
<a class="reference external" href="#metaslab">metaslab</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>When testing allocation and
fragmentation</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=do not consider metaslab
fragmentation, 1=avoid metaslabs
where free space is highly
fragmented</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-metaslab-switch-threshold">
<h3>zfs_metaslab_switch_threshold<a class="headerlink" href="#zfs-metaslab-switch-threshold" title="Permalink to this headline">¶</a></h3>
<p>When using segment-based metaslab selection (see
<a class="reference external" href="#zfs-metaslab-segment-weight-enabled">zfs_metaslab_segment_weight_enabled</a>),
continue allocating from the active metaslab until
<code class="docutils literal notranslate"><span class="pre">zfs_metaslab_switch_threshold</span></code> worth of free space buckets have been
exhausted.</p>
<table border="1" class="docutils">
<colgroup>
<col width="46%" />
<col width="54%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_metaslab_switch_threshold</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#allocation">allocation</a>,
<a class="reference external" href="#metaslab">metaslab</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>When testing allocation and
fragmentation</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint64</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>free spaces</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to UINT64_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>2</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="metaslab-debug-load">
<h3>metaslab_debug_load<a class="headerlink" href="#metaslab-debug-load" title="Permalink to this headline">¶</a></h3>
<p>When enabled, all metaslabs are loaded into memory during pool import.
Nominally, metaslab space map information is loaded and unloaded as
needed (see <a class="reference external" href="#metaslab-debug-unload">metaslab_debug_unload</a>)</p>
<p>It is difficult to predict how much RAM is required to store a space
map. An empty or completely full metaslab has a small space map.
However, a highly fragmented space map can consume significantly more
memory.</p>
<p>Enabling <code class="docutils literal notranslate"><span class="pre">metaslab_debug_load</span></code> can increase pool import time.</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">metaslab_debug_load</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#allocation">allocation</a>,
<a class="reference external" href="#memory">memory</a>,
<a class="reference external" href="#metaslab">metaslab</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>When RAM is plentiful and pool import time is
not a consideration</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=do not load all metaslab info at pool
import, 1=dynamically load metaslab info as
needed</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.6.4 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="metaslab-debug-unload">
<h3>metaslab_debug_unload<a class="headerlink" href="#metaslab-debug-unload" title="Permalink to this headline">¶</a></h3>
<p>When enabled, prevents metaslab information from being dynamically
unloaded from RAM. Nominally, metaslab space map information is loaded
and unloaded as needed (see
<a class="reference external" href="#metaslab-debug-load">metaslab_debug_load</a>)</p>
<p>It is difficult to predict how much RAM is required to store a space
map. An empty or completely full metaslab has a small space map.
However, a highly fragmented space map can consume significantly more
memory.</p>
<p>Enabling <code class="docutils literal notranslate"><span class="pre">metaslab_debug_unload</span></code> consumes RAM that would otherwise be
freed.</p>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">metaslab_debug_unload</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#allocation">allocation</a>,
<a class="reference external" href="#memory">memory</a>,
<a class="reference external" href="#metaslab">metaslab</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>When RAM is plentiful and the penalty for
dynamically reloading metaslab info from
the pool is high</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=dynamically unload metaslab info,
1=unload metaslab info only upon pool
export</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.6.4 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="metaslab-fragmentation-factor-enabled">
<h3>metaslab_fragmentation_factor_enabled<a class="headerlink" href="#metaslab-fragmentation-factor-enabled" title="Permalink to this headline">¶</a></h3>
<p>Enable use of the fragmentation metric in computing metaslab weights.</p>
<p>In version v0.7.0, if
<a class="reference external" href="#zfs-metaslab-segment-weight-enabled">zfs_metaslab_segment_weight_enabled</a>
is enabled, then <code class="docutils literal notranslate"><span class="pre">metaslab_fragmentation_factor_enabled</span></code> is ignored.</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">metas
lab_fragmentation_factor_enabled</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#allocation">allocation</a>,
<a class="reference external" href="#metaslab">metaslab</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>To test metaslab fragmentation</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=do not consider metaslab free
space fragmentation, 1=try to
avoid fragmented metaslabs</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.6.4 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="metaslabs-per-vdev">
<h3>metaslabs_per_vdev<a class="headerlink" href="#metaslabs-per-vdev" title="Permalink to this headline">¶</a></h3>
<p>When a vdev is added, it will be divided into approximately, but no more
than, this number of metaslabs.</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">metaslabs_per_vdev</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#allocation">allocation</a>,
<a class="reference external" href="#metaslab">metaslab</a>, <a class="reference external" href="#vdev">vdev</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>When testing metaslab allocation</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint64</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>metaslabs</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>16 to UINT64_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>200</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Prior to pool creation or adding new top-level
vdevs</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="metaslab-preload-enabled">
<h3>metaslab_preload_enabled<a class="headerlink" href="#metaslab-preload-enabled" title="Permalink to this headline">¶</a></h3>
<p>Enable metaslab group preloading. Each top-level vdev has a metaslab
group. By default, up to 3 copies of metadata can exist and are
distributed across multiple top-level vdevs.
<code class="docutils literal notranslate"><span class="pre">metaslab_preload_enabled</span></code> allows the corresponding metaslabs to be
preloaded, thus improving allocation efficiency.</p>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="62%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">metaslab_preload_enabled</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#allocation">allocation</a>,
<a class="reference external" href="#metaslab">metaslab</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>When testing metaslab allocation</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=do not preload metaslab info,
1=preload up to 3 metaslabs</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.6.4 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="metaslab-lba-weighting-enabled">
<h3>metaslab_lba_weighting_enabled<a class="headerlink" href="#metaslab-lba-weighting-enabled" title="Permalink to this headline">¶</a></h3>
<p>Modern HDDs have uniform bit density and constant angular velocity.
Therefore, the outer recording zones are faster (higher bandwidth) than
the inner zones by the ratio of outer to inner track diameter. The
difference in bandwidth can be 2:1, and is often available in the HDD
detailed specifications or drive manual. For HDDs when
<code class="docutils literal notranslate"><span class="pre">metaslab_lba_weighting_enabled</span></code> is true, write allocation preference
is given to the metaslabs representing the outer recording zones. Thus
the allocation to metaslabs prefers faster bandwidth over free space.</p>
<p>If the devices are not rotational, yet misrepresent themselves to the OS
as rotational, then disabling <code class="docutils literal notranslate"><span class="pre">metaslab_lba_weighting_enabled</span></code> can
result in more even, free-space-based allocation.</p>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="53%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">metaslab_lba_weighting_enabled</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#allocation">allocation</a>,
<a class="reference external" href="#metaslab">metaslab</a>,
<a class="reference external" href="#hdd">HDD</a>, <a class="reference external" href="#ssd">SSD</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>disable if using only SSDs and
version v0.6.4 or earlier</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=do not use LBA weighting, 1=use
LBA weighting</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Verfication</td>
<td>The rotational setting described
by a block device in sysfs by
observing
<code class="docutils literal notranslate"><span class="pre">/sys/</span>
<span class="pre">block/DISK_NAME/queue/rotational</span></code></td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>prior to v0.6.5, the check for
non-rotation media did not exist</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="spa-config-path">
<h3>spa_config_path<a class="headerlink" href="#spa-config-path" title="Permalink to this headline">¶</a></h3>
<p>By default, the <code class="docutils literal notranslate"><span class="pre">zpool</span> <span class="pre">import</span></code> command searches for pool information
in the <code class="docutils literal notranslate"><span class="pre">zpool.cache</span></code> file. If the pool to be imported has an entry in
<code class="docutils literal notranslate"><span class="pre">zpool.cache</span></code> then the devices do not have to be scanned to determine
if they are pool members. The path to the cache file is spa_config_path.</p>
<p>For more information on <code class="docutils literal notranslate"><span class="pre">zpool</span> <span class="pre">import</span></code> and the <code class="docutils literal notranslate"><span class="pre">-o</span> <span class="pre">cachefile</span></code> and
<code class="docutils literal notranslate"><span class="pre">-d</span></code> options, see the man page for zpool(8)</p>
<p>See also <a class="reference external" href="#zfs-autoimport-disable">zfs_autoimport_disable</a></p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">spa_config_path</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#import">import</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>If creating a non-standard distribution and the
cachefile property is inconvenient</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>string</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td><code class="docutils literal notranslate"><span class="pre">/etc/zfs/zpool.cache</span></code></td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic, applies only to the next invocation of
<code class="docutils literal notranslate"><span class="pre">zpool</span> <span class="pre">import</span></code></td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="spa-asize-inflation">
<h3>spa_asize_inflation<a class="headerlink" href="#spa-asize-inflation" title="Permalink to this headline">¶</a></h3>
<p>Multiplication factor used to estimate actual disk consumption from the
size of data being written. The default value is a worst case estimate,
but lower values may be valid for a given pool depending on its
configuration. Pool administrators who understand the factors involved
may wish to specify a more realistic inflation factor, particularly if
they operate close to quota or capacity limits.</p>
<p>The worst case space requirement for allocation is single-sector
max-parity RAIDZ blocks, in which case the space requirement is exactly
4 times the size, accounting for a maximum of 3 parity blocks. This is
added to the maximum number of ZFS <code class="docutils literal notranslate"><span class="pre">copies</span></code> parameter (copies max=3).
Additional space is required if the block could impact deduplication
tables. Altogether, the worst case is 24.</p>
<p>If the estimation is not correct, then quotas or out-of-space conditions
can lead to optimistic expectations of the ability to allocate.
Applications are typically not prepared to deal with such failures and
can misbehave.</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">spa_asize_inflation</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#allocation">allocation</a>, <a class="reference external" href="#spa">SPA</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>If the allocation requirements for the
workload are well known and quotas are used</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint64</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>unit</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to 24</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>24</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.3 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="spa-load-verify-data">
<h3>spa_load_verify_data<a class="headerlink" href="#spa-load-verify-data" title="Permalink to this headline">¶</a></h3>
<p>An extreme rewind import (see <code class="docutils literal notranslate"><span class="pre">zpool</span> <span class="pre">import</span> <span class="pre">-X</span></code>) normally performs a
full traversal of all blocks in the pool for verification. If this
parameter is set to 0, the traversal skips non-metadata blocks. It can
be toggled once the import has started to stop or start the traversal of
non-metadata blocks. See also
<a class="reference external" href="#spa-load-verify-metadata">spa_load_verify_metadata</a>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">spa_load_verify_data</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#allocation">allocation</a>, <a class="reference external" href="#spa">SPA</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>At the risk of data integrity, to speed
extreme import of large pool</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=do not verify data upon pool import,
1=verify pool data upon import</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.6.4 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="spa-load-verify-metadata">
<h3>spa_load_verify_metadata<a class="headerlink" href="#spa-load-verify-metadata" title="Permalink to this headline">¶</a></h3>
<p>An extreme rewind import (see <code class="docutils literal notranslate"><span class="pre">zpool</span> <span class="pre">import</span> <span class="pre">-X</span></code>) normally performs a
full traversal of all blocks in the pool for verification. If this
parameter is set to 0, the traversal is not performed. It can be toggled
once the import has started to stop or start the traversal. See
<a class="reference external" href="#spa-load-verify-data">spa_load_verify_data</a></p>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="62%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">spa_load_verify_metadata</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#import">import</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>At the risk of data integrity, to speed
extreme import of large pool</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=do not verify metadata upon pool
import, 1=verify pool metadata upon
import</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.6.4 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="spa-load-verify-maxinflight">
<h3>spa_load_verify_maxinflight<a class="headerlink" href="#spa-load-verify-maxinflight" title="Permalink to this headline">¶</a></h3>
<p>Maximum number of concurrent I/Os during the data verification performed
during an extreme rewind import (see <code class="docutils literal notranslate"><span class="pre">zpool</span> <span class="pre">import</span> <span class="pre">-X</span></code>)</p>
<table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">spa_load_verify_maxinflight</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#import">import</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>During an extreme rewind import, to
match the concurrent I/O capabilities
of the pool devices</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>I/Os</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to MAX_INT</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>10,000</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.4 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="spa-slop-shift">
<h3>spa_slop_shift<a class="headerlink" href="#spa-slop-shift" title="Permalink to this headline">¶</a></h3>
<p>Normally, the last 3.2% (1/(2^<code class="docutils literal notranslate"><span class="pre">spa_slop_shift</span></code>)) of pool space is
reserved to ensure the pool doesn’t run completely out of space, due to
unaccounted changes (e.g. to the MOS). This also limits the worst-case
time to allocate space. When less than this amount of free space exists,
most ZPL operations (e.g. write, create) return error:no space (ENOSPC).</p>
<p>Changing spa_slop_shift affects the currently loaded ZFS module and all
imported pools. spa_slop_shift is not stored on disk. Beware when
importing full pools on systems with larger spa_slop_shift can lead to
over-full conditions.</p>
<p>The minimum SPA slop space is limited to 128 MiB.</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">spa_slop_shift</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#allocation">allocation</a>, <a class="reference external" href="#spa">SPA</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>For large pools, when 3.2% may be too
conservative and more usable space is desired,
consider increasing <code class="docutils literal notranslate"><span class="pre">spa_slop_shift</span></code></td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>shift</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to MAX_INT, however the practical upper limit
is 15 for a system with 4TB of RAM</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>5</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.5 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfetch-array-rd-sz">
<h3>zfetch_array_rd_sz<a class="headerlink" href="#zfetch-array-rd-sz" title="Permalink to this headline">¶</a></h3>
<p>If prefetching is enabled, do not prefetch blocks larger than
<code class="docutils literal notranslate"><span class="pre">zfetch_array_rd_sz</span></code> size.</p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="73%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfetch_array_rd_sz</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#prefetch">prefetch</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>To allow prefetching when using large block sizes</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>unsigned long</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to MAX_ULONG</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>1,048,576 (1 MiB)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfetch-max-distance">
<h3>zfetch_max_distance<a class="headerlink" href="#zfetch-max-distance" title="Permalink to this headline">¶</a></h3>
<p>Limits the maximum number of bytes to prefetch per stream.</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfetch_max_distance</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#prefetch">prefetch</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Consider increasing read workloads that use
large blocks and exhibit high prefetch hit
ratios</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to UINT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>8,388,608</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfetch-max-streams">
<h3>zfetch_max_streams<a class="headerlink" href="#zfetch-max-streams" title="Permalink to this headline">¶</a></h3>
<p>Maximum number of prefetch streams per file.</p>
<p>For version v0.7.0 and later, when prefetching small files the number of
prefetch streams is automatically reduced below to prevent the streams
from overlapping.</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfetch_max_streams</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#prefetch">prefetch</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>If the workload benefits from prefetching and
has more than <code class="docutils literal notranslate"><span class="pre">zfetch_max_streams</span></code>
concurrent reader threads</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>streams</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to MAX_UINT</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>8</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfetch-min-sec-reap">
<h3>zfetch_min_sec_reap<a class="headerlink" href="#zfetch-min-sec-reap" title="Permalink to this headline">¶</a></h3>
<p>Prefetch streams that have been accessed in <code class="docutils literal notranslate"><span class="pre">zfetch_min_sec_reap</span></code>
seconds are automatically stopped.</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfetch_min_sec_reap</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#prefetch">prefetch</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>To test prefetch efficiency</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>seconds</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to MAX_UINT</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>2</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-arc-dnode-limit-percent">
<h3>zfs_arc_dnode_limit_percent<a class="headerlink" href="#zfs-arc-dnode-limit-percent" title="Permalink to this headline">¶</a></h3>
<p>Percentage of ARC metadata space that can be used for dnodes.</p>
<p>The value calculated for <code class="docutils literal notranslate"><span class="pre">zfs_arc_dnode_limit_percent</span></code> can be
overridden by <a class="reference external" href="#zfs-arc-dnode-limit">zfs_arc_dnode_limit</a>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_arc_dnode_limit_percent</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#arc">ARC</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Consider increasing if <code class="docutils literal notranslate"><span class="pre">arc_prune</span></code>
is using excessive system time and
<code class="docutils literal notranslate"><span class="pre">/proc/spl/kstat/zfs/arcstats</span></code>
shows <code class="docutils literal notranslate"><span class="pre">arc_dnode_size</span></code> is near or
over <code class="docutils literal notranslate"><span class="pre">arc_dnode_limit</span></code></td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>percent of arc_meta_limit</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to 100</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>10</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-arc-dnode-limit">
<h3>zfs_arc_dnode_limit<a class="headerlink" href="#zfs-arc-dnode-limit" title="Permalink to this headline">¶</a></h3>
<p>When the number of bytes consumed by dnodes in the ARC exceeds
<code class="docutils literal notranslate"><span class="pre">zfs_arc_dnode_limit</span></code> bytes, demand for new metadata can take from the
space consumed by dnodes.</p>
<p>The default value 0, indicates that a percent which is based on
<a class="reference external" href="#zfs-arc-dnode-limit-percent">zfs_arc_dnode_limit_percent</a> of the
ARC meta buffers that may be used for dnodes.</p>
<p><code class="docutils literal notranslate"><span class="pre">zfs_arc_dnode_limit</span></code> is similar to
<a class="reference external" href="#zfs-arc-meta-prune">zfs_arc_meta_prune</a> which serves a similar
purpose for metadata.</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_arc_dnode_limit</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#arc">ARC</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Consider increasing if <code class="docutils literal notranslate"><span class="pre">arc_prune</span></code> is using
excessive system time and
<code class="docutils literal notranslate"><span class="pre">/proc/spl/kstat/zfs/arcstats</span></code> shows
<code class="docutils literal notranslate"><span class="pre">arc_dnode_size</span></code> is near or over
<code class="docutils literal notranslate"><span class="pre">arc_dnode_limit</span></code></td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint64</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to MAX_UINT64</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>0 (uses
<a class="reference external" href="#zfs-arc-dnode-limit-percent">zfs_arc_dnode_lim
it_percent</a>)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-arc-dnode-reduce-percent">
<h3>zfs_arc_dnode_reduce_percent<a class="headerlink" href="#zfs-arc-dnode-reduce-percent" title="Permalink to this headline">¶</a></h3>
<p>Percentage of ARC dnodes to try to evict in response to demand for
non-metadata when the number of bytes consumed by dnodes exceeds
<a class="reference external" href="#zfs-arc-dnode-limit">zfs_arc_dnode_limit</a>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_arc_dnode_reduce_percent</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#arc">ARC</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Testing dnode cache efficiency</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint64</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>percent of size of dnode space used
above
<a class="reference external" href="#zfs-arc-dnode-limit">zfs_arc_d
node_limit</a></td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to 100</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>10</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-arc-average-blocksize">
<h3>zfs_arc_average_blocksize<a class="headerlink" href="#zfs-arc-average-blocksize" title="Permalink to this headline">¶</a></h3>
<p>The ARC’s buffer hash table is sized based on the assumption of an
average block size of <code class="docutils literal notranslate"><span class="pre">zfs_arc_average_blocksize</span></code>. The default of 8
KiB uses approximately 1 MiB of hash table per 1 GiB of physical memory
with 8-byte pointers.</p>
<table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_arc_average_blocksize</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#arc">ARC</a>, <a class="reference external" href="#memory">memory</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>For workloads where the known average
blocksize is larger, increasing
<code class="docutils literal notranslate"><span class="pre">zfs_arc_average_blocksize</span></code> can
reduce memory usage</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>512 to 16,777,216</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>8,192</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Prior to zfs module load</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-arc-evict-batch-limit">
<h3>zfs_arc_evict_batch_limit<a class="headerlink" href="#zfs-arc-evict-batch-limit" title="Permalink to this headline">¶</a></h3>
<p>Number ARC headers to evict per sublist before proceeding to another
sublist. This batch-style operation prevents entire sublists from being
evicted at once but comes at a cost of additional unlocking and locking.</p>
<table border="1" class="docutils">
<colgroup>
<col width="45%" />
<col width="55%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_arc_evict_batch_limit</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#arc">ARC</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Testing ARC multilist features</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>count of ARC headers</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to INT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>10</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.5 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-arc-grow-retry">
<h3>zfs_arc_grow_retry<a class="headerlink" href="#zfs-arc-grow-retry" title="Permalink to this headline">¶</a></h3>
<p>When the ARC is shrunk due to memory demand, do not retry growing the
ARC for <code class="docutils literal notranslate"><span class="pre">zfs_arc_grow_retry</span></code> seconds. This operates as a damper to
prevent oscillating grow/shrink cycles when there is memory pressure.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">zfs_arc_grow_retry</span></code> = 0, the internal default of 5 seconds is
used.</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_arc_grow_retry</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#arc">ARC</a>, <a class="reference external" href="#memory">memory</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>seconds</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to MAX_INT</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.5 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-arc-lotsfree-percent">
<h3>zfs_arc_lotsfree_percent<a class="headerlink" href="#zfs-arc-lotsfree-percent" title="Permalink to this headline">¶</a></h3>
<p>Throttle ARC memory consumption, effectively throttling I/O, when free
system memory drops below this percentage of total system memory.
Setting <code class="docutils literal notranslate"><span class="pre">zfs_arc_lotsfree_percent</span></code> to 0 disables the throttle.</p>
<p>The arcstat_memory_throttle_count counter in
<code class="docutils literal notranslate"><span class="pre">/proc/spl/kstat/arcstats</span></code> can indicate throttle activity.</p>
<table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_arc_lotsfree_percent</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#arc">ARC</a>, <a class="reference external" href="#memory">memory</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>percent</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to 100</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>10</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.5 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-arc-max">
<h3>zfs_arc_max<a class="headerlink" href="#zfs-arc-max" title="Permalink to this headline">¶</a></h3>
<p>Maximum size of ARC in bytes. If set to 0 then the maximum ARC size is
set to 1/2 of system RAM.</p>
<p><code class="docutils literal notranslate"><span class="pre">zfs_arc_max</span></code> can be changed dynamically with some caveats. It cannot
be set back to 0 while running and reducing it below the current ARC
size will not cause the ARC to shrink without memory pressure to induce
shrinking.</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_arc_max</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#arc">ARC</a>, <a class="reference external" href="#memory">memory</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Reduce if ARC competes too much with other
applications, increase if ZFS is the primary
application and can use more RAM</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint64</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>67,108,864 to RAM size in bytes</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>0 (uses default of RAM size in bytes / 2)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic (see description above)</td>
</tr>
<tr class="row-odd"><td>Verification</td>
<td><code class="docutils literal notranslate"><span class="pre">c</span></code> column in <code class="docutils literal notranslate"><span class="pre">arcstats.py</span></code> or
<code class="docutils literal notranslate"><span class="pre">/proc/spl/kstat/zfs/arcstats</span></code> entry
<code class="docutils literal notranslate"><span class="pre">c_max</span></code></td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-arc-meta-adjust-restarts">
<h3>zfs_arc_meta_adjust_restarts<a class="headerlink" href="#zfs-arc-meta-adjust-restarts" title="Permalink to this headline">¶</a></h3>
<p>The number of restart passes to make while scanning the ARC attempting
the free buffers in order to stay below the
<a class="reference external" href="#zfs-arc-meta-limit">zfs_arc_meta_limit</a>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="42%" />
<col width="58%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_arc_meta_adjust_restarts</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#arc">ARC</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Testing ARC metadata adjustment feature</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>restarts</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to INT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>4,096</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.5 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-arc-meta-limit">
<h3>zfs_arc_meta_limit<a class="headerlink" href="#zfs-arc-meta-limit" title="Permalink to this headline">¶</a></h3>
<p>Sets the maximum allowed size metadata buffers in the ARC. When
<a class="reference external" href="#zfs-arc-meta-limit">zfs_arc_meta_limit</a> is reached metadata buffers
are reclaimed, even if the overall <code class="docutils literal notranslate"><span class="pre">c_max</span></code> has not been reached.</p>
<p>In version v0.7.0, with a default value = 0,
<code class="docutils literal notranslate"><span class="pre">zfs_arc_meta_limit_percent</span></code> is used to set <code class="docutils literal notranslate"><span class="pre">arc_meta_limit</span></code></p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_arc_meta_limit</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#arc">ARC</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>For workloads where the metadata to data ratio
in the ARC can be changed to improve ARC hit
rates</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint64</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to <code class="docutils literal notranslate"><span class="pre">c_max</span></code></td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic, except that it cannot be set back to
0 for a specific percent of the ARC; it must
be set to an explicit value</td>
</tr>
<tr class="row-odd"><td>Verification</td>
<td><code class="docutils literal notranslate"><span class="pre">/proc/spl/kstat/zfs/arcstats</span></code> entry
<code class="docutils literal notranslate"><span class="pre">arc_meta_limit</span></code></td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-arc-meta-limit-percent">
<h3>zfs_arc_meta_limit_percent<a class="headerlink" href="#zfs-arc-meta-limit-percent" title="Permalink to this headline">¶</a></h3>
<p>Sets the limit to ARC metadata, <code class="docutils literal notranslate"><span class="pre">arc_meta_limit</span></code>, as a percentage of
the maximum size target of the ARC, <code class="docutils literal notranslate"><span class="pre">c_max</span></code></p>
<p>Prior to version v0.7.0, the
<a class="reference external" href="#zfs-arc-meta-limit">zfs_arc_meta_limit</a> was used to set the limit
as a fixed size. <code class="docutils literal notranslate"><span class="pre">zfs_arc_meta_limit_percent</span></code> provides a more
convenient interface for setting the limit.</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_arc_meta_limit_percent</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#arc">ARC</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>For workloads where the metadata to
data ratio in the ARC can be changed
to improve ARC hit rates</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint64</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>percent of <code class="docutils literal notranslate"><span class="pre">c_max</span></code></td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to 100</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>75</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Verification</td>
<td><code class="docutils literal notranslate"><span class="pre">/proc/spl/kstat/zfs/arcstats</span></code> entry
<code class="docutils literal notranslate"><span class="pre">arc_meta_limit</span></code></td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-arc-meta-min">
<h3>zfs_arc_meta_min<a class="headerlink" href="#zfs-arc-meta-min" title="Permalink to this headline">¶</a></h3>
<p>The minimum allowed size in bytes that metadata buffers may consume in
the ARC. This value defaults to 0 which disables a floor on the amount
of the ARC devoted meta data.</p>
<p>When evicting data from the ARC, if the <code class="docutils literal notranslate"><span class="pre">metadata_size</span></code> is less than
<code class="docutils literal notranslate"><span class="pre">arc_meta_min</span></code> then data is evicted instead of metadata.</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="75%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_arc_meta_min</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#arc">ARC</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint64</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>16,777,216 to <code class="docutils literal notranslate"><span class="pre">c_max</span></code></td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>0 (use internal default 16 MiB)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Verification</td>
<td><code class="docutils literal notranslate"><span class="pre">/proc/spl/kstat/zfs/arcstats</span></code> entry <code class="docutils literal notranslate"><span class="pre">arc_meta_min</span></code></td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-arc-meta-prune">
<h3>zfs_arc_meta_prune<a class="headerlink" href="#zfs-arc-meta-prune" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_arc_meta_prune</span></code> sets the number of dentries and znodes to be
scanned looking for entries which can be dropped. This provides a
mechanism to ensure the ARC can honor the <code class="docutils literal notranslate"><span class="pre">arc_meta_limit</span> <span class="pre">and</span></code> reclaim
otherwise pinned ARC buffers. Pruning may be required when the ARC size
drops to <code class="docutils literal notranslate"><span class="pre">arc_meta_limit</span></code> because dentries and znodes can pin buffers
in the ARC. Increasing this value will cause to dentry and znode caches
to be pruned more aggressively and the arc_prune thread becomes more
active. Setting <code class="docutils literal notranslate"><span class="pre">zfs_arc_meta_prune</span></code> to 0 will disable pruning.</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_arc_meta_prune</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#arc">ARC</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint64</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>entries</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to INT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>10,000</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>! Verification</td>
<td>Prune activity is counted by the
<code class="docutils literal notranslate"><span class="pre">/proc/spl/kstat/zfs/arcstats</span></code> entry
<code class="docutils literal notranslate"><span class="pre">arc_prune</span></code></td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.6.5 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-arc-meta-strategy">
<h3>zfs_arc_meta_strategy<a class="headerlink" href="#zfs-arc-meta-strategy" title="Permalink to this headline">¶</a></h3>
<p>Defines the strategy for ARC metadata eviction (meta reclaim strategy).
A value of 0 (META_ONLY) will evict only the ARC metadata. A value of 1
(BALANCED) indicates that additional data may be evicted if required in
order to evict the requested amount of metadata.</p>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_arc_meta_strategy</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#arc">ARC</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Testing ARC metadata eviction</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>enum</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0=evict metadata only, 1=also evict data
buffers if they can free metadata buffers
for eviction</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>1 (BALANCED)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.5 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-arc-min">
<h3>zfs_arc_min<a class="headerlink" href="#zfs-arc-min" title="Permalink to this headline">¶</a></h3>
<p>Minimum ARC size limit. When the ARC is asked to shrink, it will stop
shrinking at <code class="docutils literal notranslate"><span class="pre">c_min</span></code> as tuned by <code class="docutils literal notranslate"><span class="pre">zfs_arc_min</span></code>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_arc_min</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#arc">ARC</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>If the primary focus of the system is ZFS, then
increasing can ensure the ARC gets a minimum
amount of RAM</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint64</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>33,554,432 to <code class="docutils literal notranslate"><span class="pre">c_max</span></code></td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>For kernel: greater of 33,554,432 (32 MiB) and
memory size / 32. For user-land: greater of
33,554,432 (32 MiB) and <code class="docutils literal notranslate"><span class="pre">c_max</span></code> / 2.</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Verification</td>
<td><code class="docutils literal notranslate"><span class="pre">/proc/spl/kstat/zfs/arcstats</span></code> entry
<code class="docutils literal notranslate"><span class="pre">c_min</span></code></td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-arc-min-prefetch-ms">
<h3>zfs_arc_min_prefetch_ms<a class="headerlink" href="#zfs-arc-min-prefetch-ms" title="Permalink to this headline">¶</a></h3>
<p>Minimum time prefetched blocks are locked in the ARC.</p>
<p>A value of 0 represents the default of 1 second. However, once changed,
dynamically setting to 0 will not return to the default.</p>
<table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_arc_min_prefetch_ms</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#arc">ARC</a>, <a class="reference external" href="#prefetch">prefetch</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>milliseconds</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to INT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>0 (use internal default of 1000 ms)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.8.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-arc-min-prescient-prefetch-ms">
<h3>zfs_arc_min_prescient_prefetch_ms<a class="headerlink" href="#zfs-arc-min-prescient-prefetch-ms" title="Permalink to this headline">¶</a></h3>
<p>Minimum time “prescient prefetched” blocks are locked in the ARC. These
blocks are meant to be prefetched fairly aggresively ahead of the code
that may use them.</p>
<p>A value of 0 represents the default of 6 seconds. However, once changed,
dynamically setting to 0 will not return to the default.</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">z
fs_arc_min_prescient_prefetch_ms</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#arc">ARC</a>,
<a class="reference external" href="#prefetch">prefetch</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>milliseconds</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to INT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>0 (use internal default of 6000
ms)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.8.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-multilist-num-sublists">
<h3>zfs_multilist_num_sublists<a class="headerlink" href="#zfs-multilist-num-sublists" title="Permalink to this headline">¶</a></h3>
<p>To allow more fine-grained locking, each ARC state contains a series of
lists (sublists) for both data and metadata objects. Locking is
performed at the sublist level. This parameters controls the number of
sublists per ARC state, and also applies to other uses of the multilist
data structure.</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_multilist_num_sublists</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#arc">ARC</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>lists</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to INT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>0 (internal value is greater of number
of online CPUs or 4)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Prior to zfs module load</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-arc-overflow-shift">
<h3>zfs_arc_overflow_shift<a class="headerlink" href="#zfs-arc-overflow-shift" title="Permalink to this headline">¶</a></h3>
<p>The ARC size is considered to be overflowing if it exceeds the current
ARC target size (<code class="docutils literal notranslate"><span class="pre">/proc/spl/kstat/zfs/arcstats</span></code> entry <code class="docutils literal notranslate"><span class="pre">c</span></code>) by a
threshold determined by <code class="docutils literal notranslate"><span class="pre">zfs_arc_overflow_shift</span></code>. The threshold is
calculated as a fraction of c using the formula: (ARC target size)
<code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">&gt;&gt;</span> <span class="pre">zfs_arc_overflow_shift</span></code></p>
<p>The default value of 8 causes the ARC to be considered to be overflowing
if it exceeds the target size by 1/256th (0.3%) of the target size.</p>
<p>When the ARC is overflowing, new buffer allocations are stalled until
the reclaim thread catches up and the overflow condition no longer
exists.</p>
<table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="42%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_arc_overflow_shift</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#arc">ARC</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>shift</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to INT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>8</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.5 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-arc-p-min-shift">
<h3>zfs_arc_p_min_shift<a class="headerlink" href="#zfs-arc-p-min-shift" title="Permalink to this headline">¶</a></h3>
<p>arc_p_min_shift is used to shift of ARC target size
(<code class="docutils literal notranslate"><span class="pre">/proc/spl/kstat/zfs/arcstats</span></code> entry <code class="docutils literal notranslate"><span class="pre">c</span></code>) for calculating both
minimum and maximum most recently used (MRU) target size
(<code class="docutils literal notranslate"><span class="pre">/proc/spl/kstat/zfs/arcstats</span></code> entry <code class="docutils literal notranslate"><span class="pre">p</span></code>)</p>
<p>A value of 0 represents the default setting of <code class="docutils literal notranslate"><span class="pre">arc_p_min_shift</span></code> = 4.
However, once changed, dynamically setting <code class="docutils literal notranslate"><span class="pre">zfs_arc_p_min_shift</span></code> to 0
will not return to the default.</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_arc_p_min_shift</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#arc">ARC</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>shift</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to INT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>0 (internal default = 4)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Verification</td>
<td>Observe changes to
<code class="docutils literal notranslate"><span class="pre">/proc/spl/kstat/zfs/arcstats</span></code> entry <code class="docutils literal notranslate"><span class="pre">p</span></code></td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-arc-p-dampener-disable">
<h3>zfs_arc_p_dampener_disable<a class="headerlink" href="#zfs-arc-p-dampener-disable" title="Permalink to this headline">¶</a></h3>
<p>When data is being added to the ghost lists, the MRU target size is
adjusted. The amount of adjustment is based on the ratio of the MRU/MFU
sizes. When enabled, the ratio is capped to 10, avoiding large
adjustments.</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_arc_p_dampener_disable</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#arc">ARC</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Testing ARC ghost list behaviour</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=avoid large adjustments, 1=permit
large adjustments</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.6.4 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-arc-shrink-shift">
<h3>zfs_arc_shrink_shift<a class="headerlink" href="#zfs-arc-shrink-shift" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">arc_shrink_shift</span></code> is used to adjust the ARC target sizes when large
reduction is required. The current ARC target size, <code class="docutils literal notranslate"><span class="pre">c</span></code>, and MRU size
<code class="docutils literal notranslate"><span class="pre">p</span></code> can be reduced by by the current <code class="docutils literal notranslate"><span class="pre">size</span> <span class="pre">&gt;&gt;</span> <span class="pre">arc_shrink_shift</span></code>. For
the default value of 7, this reduces the target by approximately 0.8%.</p>
<p>A value of 0 represents the default setting of arc_shrink_shift = 7.
However, once changed, dynamically setting arc_shrink_shift to 0 will
not return to the default.</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_arc_shrink_shift</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#arc">ARC</a>, <a class="reference external" href="#memory">memory</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>During memory shortfall, reducing
<code class="docutils literal notranslate"><span class="pre">zfs_arc_shrink_shift</span></code> increases the rate
of ARC shrinkage</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>shift</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to INT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>0 (<code class="docutils literal notranslate"><span class="pre">arc_shrink_shift</span></code> = 7)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-arc-pc-percent">
<h3>zfs_arc_pc_percent<a class="headerlink" href="#zfs-arc-pc-percent" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_arc_pc_percent</span></code> allows ZFS arc to play more nicely with the
kernel’s LRU pagecache. It can guarantee that the arc size won’t
collapse under scanning pressure on the pagecache, yet still allows arc
to be reclaimed down to zfs_arc_min if necessary. This value is
specified as percent of pagecache size (as measured by
<code class="docutils literal notranslate"><span class="pre">NR_FILE_PAGES</span></code>) where that percent may exceed 100. This only operates
during memory pressure/reclaim.</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_arc_pc_percent</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#arc">ARC</a>, <a class="reference external" href="#memory">memory</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>When using file systems under memory
shortfall, if the page scanner causes the ARC
to shrink too fast, then adjusting
<code class="docutils literal notranslate"><span class="pre">zfs_arc_pc_percent</span></code> can reduce the shrink
rate</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>percent</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to 100</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>0 (disabled)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-arc-sys-free">
<h3>zfs_arc_sys_free<a class="headerlink" href="#zfs-arc-sys-free" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_arc_sys_free</span></code> is the target number of bytes the ARC should leave
as free memory on the system. Defaults to the larger of 1/64 of physical
memory or 512K. Setting this option to a non-zero value will override
the default.</p>
<p>A value of 0 represents the default setting of larger of 1/64 of
physical memory or 512 KiB. However, once changed, dynamically setting
zfs_arc_sys_free to 0 will not return to the default.</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_arc_sys_free</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#arc">ARC</a>, <a class="reference external" href="#memory">memory</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Change if more free memory is desired as a
margin against memory demand by applications</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>ulong</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to ULONG_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>0 (default to larger of 1/64 of physical memory
or 512 KiB)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.5 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-autoimport-disable">
<h3>zfs_autoimport_disable<a class="headerlink" href="#zfs-autoimport-disable" title="Permalink to this headline">¶</a></h3>
<p>Disable reading zpool.cache file (see
<a class="reference external" href="#spa-config-path">spa_config_path</a>) when loading the zfs module.</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_autoimport_disable</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#import">import</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Leave as default so that zfs behaves as
other Linux kernel modules</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=read <code class="docutils literal notranslate"><span class="pre">zpool.cache</span></code> at module load,
1=do not read <code class="docutils literal notranslate"><span class="pre">zpool.cache</span></code> at module
load</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.6.4 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-commit-timeout-pct">
<h3>zfs_commit_timeout_pct<a class="headerlink" href="#zfs-commit-timeout-pct" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_commit_timeout_pct</span></code> controls the amount of time that a log (ZIL)
write block (lwb) remains “open” when it isn’t “full” and it has a
thread waiting to commit to stable storage. The timeout is scaled based
on a percentage of the last lwb latency to avoid significantly impacting
the latency of each individual intent log transaction (itx).</p>
<table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="39%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_commit_timeout_pct</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#zil">ZIL</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>percent</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to 100</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>5</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.8.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-dbgmsg-enable">
<h3>zfs_dbgmsg_enable<a class="headerlink" href="#zfs-dbgmsg-enable" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line">Internally ZFS keeps a small log to facilitate debugging. The contents
of the log are in the <code class="docutils literal notranslate"><span class="pre">/proc/spl/kstat/zfs/dbgmsg</span></code> file.</div>
<div class="line">Writing 0 to <code class="docutils literal notranslate"><span class="pre">/proc/spl/kstat/zfs/dbgmsg</span></code> file clears the log.</div>
</div>
<p>See also <a class="reference external" href="#zfs-dbgmsg-maxsize">zfs_dbgmsg_maxsize</a></p>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="74%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_dbgmsg_enable</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#debug">debug</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>To view ZFS internal debug log</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=do not log debug messages, 1=log debug messages</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0 (1 for debug builds)</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.6.5 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-dbgmsg-maxsize">
<h3>zfs_dbgmsg_maxsize<a class="headerlink" href="#zfs-dbgmsg-maxsize" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">/proc/spl/kstat/zfs/dbgmsg</span></code> file size limit is set by
zfs_dbgmsg_maxsize.</p>
<p>See also zfs_dbgmsg_enable</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_dbgmsg_maxsize</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#debug">debug</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to INT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>4 MiB</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.5 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-dbuf-state-index">
<h3>zfs_dbuf_state_index<a class="headerlink" href="#zfs-dbuf-state-index" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">zfs_dbuf_state_index</span></code> feature is currently unused. It is normally
used for controlling values in the <code class="docutils literal notranslate"><span class="pre">/proc/spl/kstat/zfs/dbufs</span></code> file.</p>
<table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="47%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_dbuf_state_index</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#debug">debug</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Do not change</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.5 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-deadman-enabled">
<h3>zfs_deadman_enabled<a class="headerlink" href="#zfs-deadman-enabled" title="Permalink to this headline">¶</a></h3>
<p>When a pool sync operation takes longer than zfs_deadman_synctime_ms
milliseconds, a “slow spa_sync” message is logged to the debug log (see
<a class="reference external" href="#zfs-dbgmsg-enable">zfs_dbgmsg_enable</a>). If <code class="docutils literal notranslate"><span class="pre">zfs_deadman_enabled</span></code>
is set to 1, then all pending IO operations are also checked and if any
haven’t completed within zfs_deadman_synctime_ms milliseconds, a “SLOW
IO” message is logged to the debug log and a “deadman” system event (see
zpool events command) with the details of the hung IO is posted.</p>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_deadman_enabled</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#debug">debug</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>To disable logging of slow I/O</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=do not log slow I/O, 1=log slow I/O</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.8.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-deadman-checktime-ms">
<h3>zfs_deadman_checktime_ms<a class="headerlink" href="#zfs-deadman-checktime-ms" title="Permalink to this headline">¶</a></h3>
<p>Once a pool sync operation has taken longer than
<a class="reference external" href="#zfs-deadman-synctime-ms">zfs_deadman_synctime_ms</a> milliseconds,
continue to check for slow operations every
<a class="reference external" href="#zfs-deadman-synctime-ms">zfs_deadman_checktime_ms</a> milliseconds.</p>
<table border="1" class="docutils">
<colgroup>
<col width="51%" />
<col width="49%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_deadman_checktime_ms</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#debug">debug</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>When debugging slow I/O</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>ulong</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>milliseconds</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to ULONG_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>60,000 (1 minute)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.8.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-deadman-ziotime-ms">
<h3>zfs_deadman_ziotime_ms<a class="headerlink" href="#zfs-deadman-ziotime-ms" title="Permalink to this headline">¶</a></h3>
<p>When an individual I/O takes longer than <code class="docutils literal notranslate"><span class="pre">zfs_deadman_ziotime_ms</span></code>
milliseconds, then the operation is considered to be “hung”. If
<a class="reference external" href="#zfs-deadman-enabled">zfs_deadman_enabled</a> is set then the deadman
behaviour is invoked as described by the
<a class="reference external" href="#zfs-deadman-failmode">zfs_deadman_failmode</a> option.</p>
<table border="1" class="docutils">
<colgroup>
<col width="52%" />
<col width="48%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_deadman_ziotime_ms</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#debug">debug</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Testing ABD features</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>ulong</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>milliseconds</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to ULONG_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>300,000 (5 minutes)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.8.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-deadman-synctime-ms">
<h3>zfs_deadman_synctime_ms<a class="headerlink" href="#zfs-deadman-synctime-ms" title="Permalink to this headline">¶</a></h3>
<p>The I/O deadman timer expiration time has two meanings</p>
<ol class="arabic simple">
<li>determines when the <code class="docutils literal notranslate"><span class="pre">spa_deadman()</span></code> logic should fire, indicating
the txg sync has not completed in a timely manner</li>
<li>determines if an I/O is considered “hung”</li>
</ol>
<p>In version v0.8.0, any I/O that has not completed in
<code class="docutils literal notranslate"><span class="pre">zfs_deadman_synctime_ms</span></code> is considered “hung” resulting in one of
three behaviors controlled by the
<a class="reference external" href="#zfs-deadman-failmode">zfs_deadman_failmode</a> parameter.</p>
<p><code class="docutils literal notranslate"><span class="pre">zfs_deadman_synctime_ms</span></code> takes effect if
<a class="reference external" href="#zfs-deadman-enabled">zfs_deadman_enabled</a> = 1.</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_deadman_synctime_ms</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#debug">debug</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>When debugging slow I/O</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>ulong</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>milliseconds</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to ULONG_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>600,000 (10 minutes)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.5 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-deadman-failmode">
<h3>zfs_deadman_failmode<a class="headerlink" href="#zfs-deadman-failmode" title="Permalink to this headline">¶</a></h3>
<p>zfs_deadman_failmode controls the behavior of the I/O deadman timer when
it detects a “hung” I/O. Valid values are:</p>
<ul class="simple">
<li>wait - Wait for the “hung” I/O (default)</li>
<li>continue - Attempt to recover from a “hung” I/O</li>
<li>panic - Panic the system</li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_deadman_failmode</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#debug">debug</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>In some cluster cases, panic can be appropriate</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>string</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td><em>wait</em>, <em>continue</em>, or <em>panic</em></td>
</tr>
<tr class="row-even"><td>Default</td>
<td>wait</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.8.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-dedup-prefetch">
<h3>zfs_dedup_prefetch<a class="headerlink" href="#zfs-dedup-prefetch" title="Permalink to this headline">¶</a></h3>
<p>ZFS can prefetch deduplication table (DDT) entries.
<code class="docutils literal notranslate"><span class="pre">zfs_dedup_prefetch</span></code> allows DDT prefetches to be enabled.</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_dedup_prefetch</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#prefetch">prefetch</a>, <a class="reference external" href="#memory">memory</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>For systems with limited RAM using the dedup
feature, disabling deduplication table
prefetch can reduce memory pressure</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=do not prefetch, 1=prefetch dedup table
entries</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.6.5 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-delete-blocks">
<h3>zfs_delete_blocks<a class="headerlink" href="#zfs-delete-blocks" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_delete_blocks</span></code> defines a large file for the purposes of delete.
Files containing more than <code class="docutils literal notranslate"><span class="pre">zfs_delete_blocks</span></code> will be deleted
asynchronously while smaller files are deleted synchronously. Decreasing
this value reduces the time spent in an <code class="docutils literal notranslate"><span class="pre">unlink(2)</span></code> system call at the
expense of a longer delay before the freed space is available.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">zfs_delete_blocks</span></code> value is specified in blocks, not bytes. The
size of blocks can vary and is ultimately limited by the filesystem’s
recordsize property.</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_delete_blocks</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#filesystem">filesystem</a>,
<a class="reference external" href="#delete">delete</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>If applications delete large files and blocking
on <code class="docutils literal notranslate"><span class="pre">unlink(2)</span></code> is not desired</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>ulong</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>blocks</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to ULONG_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>20,480</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-delay-min-dirty-percent">
<h3>zfs_delay_min_dirty_percent<a class="headerlink" href="#zfs-delay-min-dirty-percent" title="Permalink to this headline">¶</a></h3>
<p>The ZFS write throttle begins to delay each transaction when the amount
of dirty data reaches the threshold <code class="docutils literal notranslate"><span class="pre">zfs_delay_min_dirty_percent</span></code> of
<a class="reference external" href="#zfs-dirty-data-max">zfs_dirty_data_max</a>. This value should be &gt;=
<a class="reference external" href="#zfs-vdev-async-write-active-max-dirty-percent">zfs_vdev_async_write_active_max_dirty_percent</a>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_delay_min_dirty_percent</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#write-throttle">write_throttle</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>See section “ZFS TRANSACTION DELAY”</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>percent</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to 100</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>60</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.4 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-delay-scale">
<h3>zfs_delay_scale<a class="headerlink" href="#zfs-delay-scale" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_delay_scale</span></code> controls how quickly the ZFS write throttle
transaction delay approaches infinity. Larger values cause longer delays
for a given amount of dirty data.</p>
<p>For the smoothest delay, this value should be about 1 billion divided by
the maximum number of write operations per second the pool can sustain.
The throttle will smoothly handle between 10x and 1/10th
<code class="docutils literal notranslate"><span class="pre">zfs_delay_scale</span></code>.</p>
<p>Note: <code class="docutils literal notranslate"><span class="pre">zfs_delay_scale</span></code> *
<a class="reference external" href="#zfs-dirty-data-max">zfs_dirty_data_max</a> must be &lt; 2^64.</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_delay_scale</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#write-throttle">write_throttle</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>See section “ZFS TRANSACTION DELAY”</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>ulong</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>scalar (nanoseconds)</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to ULONG_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>500,000</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.4 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-dirty-data-max">
<h3>zfs_dirty_data_max<a class="headerlink" href="#zfs-dirty-data-max" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_dirty_data_max</span></code> is the ZFS write throttle dirty space limit. Once
this limit is exceeded, new writes are delayed until space is freed by
writes being committed to the pool.</p>
<p>zfs_dirty_data_max takes precedence over
<a class="reference external" href="#zfs-dirty-data-max-percent">zfs_dirty_data_max_percent</a>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_dirty_data_max</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#write-throttle">write_throttle</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>See section “ZFS TRANSACTION DELAY”</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>ulong</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to
<a class="reference external" href="#zfs-dirty-data-max-max">zfs_d
irty_data_max_max</a></td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>10% of physical RAM</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.4 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-dirty-data-max-percent">
<h3>zfs_dirty_data_max_percent<a class="headerlink" href="#zfs-dirty-data-max-percent" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_dirty_data_max_percent</span></code> is an alternative method of specifying
<a class="reference external" href="#zfs-dirty-data-max">zfs_dirty_data_max</a>, the ZFS write throttle
dirty space limit. Once this limit is exceeded, new writes are delayed
until space is freed by writes being committed to the pool.</p>
<p><a class="reference external" href="#zfs-dirty-data-max">zfs_dirty_data_max</a> takes precedence over
<code class="docutils literal notranslate"><span class="pre">zfs_dirty_data_max_percent</span></code>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_dirty_data_max_percent</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#write-throttle">write_throttle</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>See section “ZFS TRANSACTION DELAY”</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>percent</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to 100</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>10% of physical RAM</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Prior to zfs module load or a memory
hot plug event</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.4 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-dirty-data-max-max">
<h3>zfs_dirty_data_max_max<a class="headerlink" href="#zfs-dirty-data-max-max" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_dirty_data_max_max</span></code> is the maximum allowable value of
<a class="reference external" href="#zfs-dirty-data-max">zfs_dirty_data_max</a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">zfs_dirty_data_max_max</span></code> takes precedence over
<a class="reference external" href="#zfs-dirty-data-max-max-percent">zfs_dirty_data_max_max_percent</a>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="62%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_dirty_data_max_max</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#write-throttle">write_throttle</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>See section “ZFS TRANSACTION DELAY”</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>ulong</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to physical RAM size</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>25% of physical RAM</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Prior to zfs module load</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.4 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-dirty-data-max-max-percent">
<h3>zfs_dirty_data_max_max_percent<a class="headerlink" href="#zfs-dirty-data-max-max-percent" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_dirty_data_max_max_percent</span></code> an alternative to
<a class="reference external" href="#zfs-dirty-data-max-max">zfs_dirty_data_max_max</a> for setting the
maximum allowable value of <a class="reference external" href="#zfs-dirty-data-max">zfs_dirty_data_max</a></p>
<p><a class="reference external" href="#zfs-dirty-data-max-max">zfs_dirty_data_max_max</a> takes precedence
over <code class="docutils literal notranslate"><span class="pre">zfs_dirty_data_max_max_percent</span></code></p>
<table border="1" class="docutils">
<colgroup>
<col width="45%" />
<col width="55%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_dirty_data_max_max_percent</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#write-throttle">write_throttle</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>See section “ZFS TRANSACTION DELAY”</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>percent</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to 100</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>25% of physical RAM</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Prior to zfs module load</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.4 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-dirty-data-sync">
<h3>zfs_dirty_data_sync<a class="headerlink" href="#zfs-dirty-data-sync" title="Permalink to this headline">¶</a></h3>
<p>When there is at least <code class="docutils literal notranslate"><span class="pre">zfs_dirty_data_sync</span></code> dirty data, a transaction
group sync is started. This allows a transaction group sync to occur
more frequently than the transaction group timeout interval (see
<a class="reference external" href="#zfs-txg-timeout">zfs_txg_timeout</a>) when there is dirty data to be
written.</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_dirty_data_sync</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#write-throttle">write_throttle</a>,
<a class="reference external" href="#ZIO-scheduler">ZIO_scheduler</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>ulong</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to ULONG_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>67,108,864 (64 MiB)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.4 through v0.8.x, deprecation planned
for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-dirty-data-sync-percent">
<h3>zfs_dirty_data_sync_percent<a class="headerlink" href="#zfs-dirty-data-sync-percent" title="Permalink to this headline">¶</a></h3>
<p>When there is at least <code class="docutils literal notranslate"><span class="pre">zfs_dirty_data_sync_percent</span></code> of
<a class="reference external" href="#zfs-dirty-data-max">zfs_dirty_data_max</a> dirty data, a transaction
group sync is started. This allows a transaction group sync to occur
more frequently than the transaction group timeout interval (see
<a class="reference external" href="#zfs-txg-timeout">zfs_txg_timeout</a>) when there is dirty data to be
written.</p>
<table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_dirty_data_sync_percent</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#write-throttle">write_throttle</a>,
<a class="reference external" href="#ZIO-scheduler">ZIO_scheduler</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>percent</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to
<a class="reference external" href="#zfs_vdev_async_write_active_min_dirty_percent">zfs_vdev_async_write_ac
tive_min_dirty_percent</a></td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>20</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2, deprecates
<a class="reference external" href="#zfs-dirty-data-sync">zfs_dirt
y_data_sync</a></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-fletcher-4-impl">
<h3>zfs_fletcher_4_impl<a class="headerlink" href="#zfs-fletcher-4-impl" title="Permalink to this headline">¶</a></h3>
<p>Fletcher-4 is the default checksum algorithm for metadata and data. When
the zfs kernel module is loaded, a set of microbenchmarks are run to
determine the fastest algorithm for the current hardware. The
<code class="docutils literal notranslate"><span class="pre">zfs_fletcher_4_impl</span></code> parameter allows a specific implementation to be
specified other than the default (fastest). Selectors other than
<em>fastest</em> and <em>scalar</em> require instruction set extensions to be
available and will only appear if ZFS detects their presence. The
<em>scalar</em> implementation works on all processors.</p>
<p>The results of the microbenchmark are visible in the
<code class="docutils literal notranslate"><span class="pre">/proc/spl/kstat/zfs/fletcher_4_bench</span></code> file. Larger numbers indicate
better performance. Since ZFS is processor endian-independent, the
microbenchmark is run against both big and little-endian transformation.</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_fletcher_4_impl</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#cpu">CPU</a>, <a class="reference external" href="#checksum">checksum</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Testing Fletcher-4 algorithms</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>string</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td><em>fastest</em>, <em>scalar</em>, <em>superscalar</em>,
<em>superscalar4</em>, <em>sse2</em>, <em>ssse3</em>, <em>avx2</em>,
<em>avx512f</em>, or <em>aarch64_neon</em> depending on
hardware support</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>fastest</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-free-bpobj-enabled">
<h3>zfs_free_bpobj_enabled<a class="headerlink" href="#zfs-free-bpobj-enabled" title="Permalink to this headline">¶</a></h3>
<p>The processing of the free_bpobj object can be enabled by
<code class="docutils literal notranslate"><span class="pre">zfs_free_bpobj_enabled</span></code></p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_free_bpobj_enabled</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#delete">delete</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>If there’s a problem with processing
free_bpobj (e.g. i/o error or bug)</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=do not process free_bpobj objects,
1=process free_bpobj objects</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-free-max-blocks">
<h3>zfs_free_max_blocks<a class="headerlink" href="#zfs-free-max-blocks" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_free_max_blocks</span></code> sets the maximum number of blocks to be freed in
a single transaction group (txg). For workloads that delete (free) large
numbers of blocks in a short period of time, the processing of the frees
can negatively impact other operations, including txg commits.
<code class="docutils literal notranslate"><span class="pre">zfs_free_max_blocks</span></code> acts as a limit to reduce the impact.</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_free_max_blocks</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#filesystem">filesystem</a>,
<a class="reference external" href="#delete">delete</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>For workloads that delete large files,
<code class="docutils literal notranslate"><span class="pre">zfs_free_max_blocks</span></code> can be adjusted to
meet performance requirements while reducing
the impacts of deletion</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>ulong</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>blocks</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to ULONG_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>100,000</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-async-read-max-active">
<h3>zfs_vdev_async_read_max_active<a class="headerlink" href="#zfs-vdev-async-read-max-active" title="Permalink to this headline">¶</a></h3>
<p>Maximum asynchronous read I/Os active to each device.</p>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="53%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_vdev_async_read_max_active</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a>,
<a class="reference external" href="#zio-scheduler">ZIO_scheduler</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>See <a class="reference external" href="https://github.com/zfsonlinux/zfs/wiki/ZIO-Scheduler">ZFS I/O
Scheduler</a></td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint32</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>I/O operations</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to
<a class="reference external" href="#zfs-vdev-max-active">zfs_vdev_ma
x_active</a></td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>3</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.4 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-async-read-min-active">
<h3>zfs_vdev_async_read_min_active<a class="headerlink" href="#zfs-vdev-async-read-min-active" title="Permalink to this headline">¶</a></h3>
<p>Minimum asynchronous read I/Os active to each device.</p>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="53%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_vdev_async_read_min_active</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a>,
<a class="reference external" href="#zio-scheduler">ZIO_scheduler</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>See <a class="reference external" href="https://github.com/zfsonlinux/zfs/wiki/ZIO-Scheduler">ZFS I/O
Scheduler</a></td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint32</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>I/O operations</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to
(
<a class="reference external" href="#zfs_vdev_async_read_max_active">zfs_vdev_async_read_max_active</a>
- 1)</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>1</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.4 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-async-write-active-max-dirty-percent">
<h3>zfs_vdev_async_write_active_max_dirty_percent<a class="headerlink" href="#zfs-vdev-async-write-active-max-dirty-percent" title="Permalink to this headline">¶</a></h3>
<p>When the amount of dirty data exceeds the threshold
<code class="docutils literal notranslate"><span class="pre">zfs_vdev_async_write_active_max_dirty_percent</span></code> of
<a class="reference external" href="#zfs-dirty-data-max">zfs_dirty_data_max</a> dirty data, then
<a class="reference external" href="#zfs-vdev-async-write-max-active">zfs_vdev_async_write_max_active</a>
is used to limit active async writes. If the dirty data is between
<a class="reference external" href="#zfs-vdev-async-write-active-min-dirty-percent">zfs_vdev_async_write_active_min_dirty_percent</a>
and <code class="docutils literal notranslate"><span class="pre">zfs_vdev_async_write_active_max_dirty_percent</span></code>, the active I/O
limit is linearly interpolated between
<a class="reference external" href="#zfs-vdev-async-write-min-active">zfs_vdev_async_write_min_active</a>
and
<a class="reference external" href="#zfs-vdev-async-write-max-active">zfs_vdev_async_write_max_active</a></p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_vdev_asyn
c_write_active_max_dirty_percent</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a>,
<a class="reference external" href="#zio-scheduler">Z
IO_scheduler</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>See <a class="reference external" href="https://github.com/zfsonlinux/zfs/wiki/ZIO-Scheduler">ZFS I/O
Sch
eduler</a></td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>percent of
<a class="reference external" href="#zfs-dirty-data-max">zfs_dirty_d
ata_max</a></td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to 100</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>60</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.4 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-async-write-active-min-dirty-percent">
<h3>zfs_vdev_async_write_active_min_dirty_percent<a class="headerlink" href="#zfs-vdev-async-write-active-min-dirty-percent" title="Permalink to this headline">¶</a></h3>
<p>If the amount of dirty data is between
<code class="docutils literal notranslate"><span class="pre">zfs_vdev_async_write_active_min_dirty_percent</span></code> and
<a class="reference external" href="#zfs-vdev-async-write-active-max-dirty-percent">zfs_vdev_async_write_active_max_dirty_percent</a>
of <a class="reference external" href="#zfs-dirty-data-max">zfs_dirty_data_max</a>, the active I/O limit is
linearly interpolated between
<a class="reference external" href="#zfs-vdev-async-write-min-active">zfs_vdev_async_write_min_active</a>
and
<a class="reference external" href="#zfs-vdev-async-write-max-active">zfs_vdev_async_write_max_active</a></p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_vdev_asyn
c_write_active_min_dirty_percent</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a>,
<a class="reference external" href="#zio-scheduler">Z
IO_scheduler</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>See <a class="reference external" href="https://github.com/zfsonlinux/zfs/wiki/ZIO-Scheduler">ZFS I/O
Sch
eduler</a></td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>percent of zfs_dirty_data_max</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to
(<a class="reference external" href="#zfs_vdev_async_write_active_max_dirty_percent">z
fs_vdev_async_write_active_max_d
irty_percent</a>
- 1)</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>30</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.4 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-async-write-max-active">
<h3>zfs_vdev_async_write_max_active<a class="headerlink" href="#zfs-vdev-async-write-max-active" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_vdev_async_write_max_active</span></code> sets the maximum asynchronous write
I/Os active to each device.</p>
<table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_vdev_async_write_max_active</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a>,
`
ZIO_scheduler &lt;#zio-scheduler&gt;`__</td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>See <a class="reference external" href="https://github.com/zfsonlinux/zfs/wiki/ZIO-Scheduler">ZFS I/O
S
cheduler</a></td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint32</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>I/O operations</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to
<a class="reference external" href="#zfs-vdev-max-active">zfs_vdev_max
_active</a></td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>10</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.4 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-async-write-min-active">
<h3>zfs_vdev_async_write_min_active<a class="headerlink" href="#zfs-vdev-async-write-min-active" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_vdev_async_write_min_active</span></code> sets the minimum asynchronous write
I/Os active to each device.</p>
<p>Lower values are associated with better latency on rotational media but
poorer resilver performance. The default value of 2 was chosen as a
compromise. A value of 3 has been shown to improve resilver performance
further at a cost of further increasing latency.</p>
<table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_vdev_async_write_min_active</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a>,
`
ZIO_scheduler &lt;#zio-scheduler&gt;`__</td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>See <a class="reference external" href="https://github.com/zfsonlinux/zfs/wiki/ZIO-Scheduler">ZFS I/O
S
cheduler</a></td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint32</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>I/O operations</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to
<a class="reference external" href="#zfs_vdev_async_write_max_active">zfs
_vdev_async_write_max_active</a></td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>1 for v0.6.x, 2 for v0.7.0 and
later</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.4 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-max-active">
<h3>zfs_vdev_max_active<a class="headerlink" href="#zfs-vdev-max-active" title="Permalink to this headline">¶</a></h3>
<p>The maximum number of I/Os active to each device. Ideally,
<code class="docutils literal notranslate"><span class="pre">zfs_vdev_max_active</span></code> &gt;= the sum of each queue’s max_active.</p>
<p>Once queued to the device, the ZFS I/O scheduler is no longer able to
prioritize I/O operations. The underlying device drivers have their own
scheduler and queue depth limits. Values larger than the device’s
maximum queue depth can have the affect of increased latency as the I/Os
are queued in the intervening device driver layers.</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_vdev_max_active</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a>,
<a class="reference external" href="#zio-scheduler">ZIO_scheduler</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>See <a class="reference external" href="https://github.com/zfsonlinux/zfs/wiki/ZIO-Scheduler">ZFS I/O
Scheduler</a></td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint32</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>I/O operations</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>sum of each queue’s min_active to UINT32_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>1,000</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.4 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-scrub-max-active">
<h3>zfs_vdev_scrub_max_active<a class="headerlink" href="#zfs-vdev-scrub-max-active" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_vdev_scrub_max_active</span></code> sets the maximum scrub or scan read I/Os
active to each device.</p>
<table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_vdev_scrub_max_active</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a>,
<a class="reference external" href="#zio-scheduler">ZIO_scheduler</a>,
<a class="reference external" href="#scrub">scrub</a>,
<a class="reference external" href="#resilver">resilver</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>See <a class="reference external" href="https://github.com/zfsonlinux/zfs/wiki/ZIO-Scheduler">ZFS I/O
Scheduler</a></td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint32</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>I/O operations</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to
<a class="reference external" href="#zfs-vdev-max-active">zfs_vd
ev_max_active</a></td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>2</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.4 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-scrub-min-active">
<h3>zfs_vdev_scrub_min_active<a class="headerlink" href="#zfs-vdev-scrub-min-active" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_vdev_scrub_min_active</span></code> sets the minimum scrub or scan read I/Os
active to each device.</p>
<table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_vdev_scrub_min_active</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a>,
<a class="reference external" href="#zio-scheduler">ZIO_scheduler</a>,
<a class="reference external" href="#scrub">scrub</a>,
<a class="reference external" href="#resilver">resilver</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>See <a class="reference external" href="https://github.com/zfsonlinux/zfs/wiki/ZIO-Scheduler">ZFS I/O
Scheduler</a></td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint32</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>I/O operations</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to
<a class="reference external" href="#zfs-vdev-scrub-max-active">zfs_vdev_scrub_max
_active</a></td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>1</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.4 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-sync-read-max-active">
<h3>zfs_vdev_sync_read_max_active<a class="headerlink" href="#zfs-vdev-sync-read-max-active" title="Permalink to this headline">¶</a></h3>
<p>Maximum synchronous read I/Os active to each device.</p>
<table border="1" class="docutils">
<colgroup>
<col width="46%" />
<col width="54%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_vdev_sync_read_max_active</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a>,
<a class="reference external" href="#zio-scheduler">ZIO_scheduler</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>See <a class="reference external" href="https://github.com/zfsonlinux/zfs/wiki/ZIO-Scheduler">ZFS I/O
Scheduler</a></td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint32</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>I/O operations</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to
<a class="reference external" href="#zfs-vdev-max-active">zfs_vdev_m
ax_active</a></td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>10</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.4 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-sync-read-min-active">
<h3>zfs_vdev_sync_read_min_active<a class="headerlink" href="#zfs-vdev-sync-read-min-active" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_vdev_sync_read_min_active</span></code> sets the minimum synchronous read I/Os
active to each device.</p>
<table border="1" class="docutils">
<colgroup>
<col width="46%" />
<col width="54%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_vdev_sync_read_min_active</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a>,
<a class="reference external" href="#zio-scheduler">ZIO_scheduler</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>See <a class="reference external" href="https://github.com/zfsonlinux/zfs/wiki/ZIO-Scheduler">ZFS I/O
Scheduler</a></td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint32</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>I/O operations</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to
<a class="reference external" href="#zfs-vdev-sync-read-max-active">zfs_vdev_sync_read_max_active</a></td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>10</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.4 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-sync-write-max-active">
<h3>zfs_vdev_sync_write_max_active<a class="headerlink" href="#zfs-vdev-sync-write-max-active" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_vdev_sync_write_max_active</span></code> sets the maximum synchronous write
I/Os active to each device.</p>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="53%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_vdev_sync_write_max_active</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a>,
<a class="reference external" href="#zio-scheduler">ZIO_scheduler</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>See <a class="reference external" href="https://github.com/zfsonlinux/zfs/wiki/ZIO-Scheduler">ZFS I/O
Scheduler</a></td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint32</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>I/O operations</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to
<a class="reference external" href="#zfs-vdev-max-active">zfs_vdev_ma
x_active</a></td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>10</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.4 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-sync-write-min-active">
<h3>zfs_vdev_sync_write_min_active<a class="headerlink" href="#zfs-vdev-sync-write-min-active" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_vdev_sync_write_min_active</span></code> sets the minimum synchronous write
I/Os active to each device.</p>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="53%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_vdev_sync_write_min_active</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a>,
<a class="reference external" href="#zio-scheduler">ZIO_scheduler</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>See <a class="reference external" href="https://github.com/zfsonlinux/zfs/wiki/ZIO-Scheduler">ZFS I/O
Scheduler</a></td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint32</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>I/O operations</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to
<a class="reference external" href="#zfs_vdev_sync_write_max_active">zfs_vdev_sync_write_max_active</a></td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>10</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.4 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-queue-depth-pct">
<h3>zfs_vdev_queue_depth_pct<a class="headerlink" href="#zfs-vdev-queue-depth-pct" title="Permalink to this headline">¶</a></h3>
<p>Maximum number of queued allocations per top-level vdev expressed as a
percentage of
<a class="reference external" href="#zfs-vdev-async-write-max-active">zfs_vdev_async_write_max_active</a>.
This allows the system to detect devices that are more capable of
handling allocations and to allocate more blocks to those devices. It
also allows for dynamic allocation distribution when devices are
imbalanced as fuller devices will tend to be slower than empty devices.
Once the queue depth reaches (<code class="docutils literal notranslate"><span class="pre">zfs_vdev_queue_depth_pct</span></code> *
<a class="reference external" href="#zfs-vdev-async-write-max-active">zfs_vdev_async_write_max_active</a> /
100) then allocator will stop allocating blocks on that top-level device
and switch to the next.</p>
<p>See also <a class="reference external" href="#zio-dva-throttle-enabled">zio_dva_throttle_enabled</a></p>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="62%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_vdev_queue_depth_pct</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a>,
<a class="reference external" href="#zio-scheduler">ZIO_scheduler</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>See <a class="reference external" href="https://github.com/zfsonlinux/zfs/wiki/ZIO-Scheduler">ZFS I/O
Scheduler</a></td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint32</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>I/O operations</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to UINT32_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>1,000</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-disable-dup-eviction">
<h3>zfs_disable_dup_eviction<a class="headerlink" href="#zfs-disable-dup-eviction" title="Permalink to this headline">¶</a></h3>
<p>Disable duplicate buffer eviction from ARC.</p>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="62%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_disable_dup_eviction</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#arc">ARC</a>, <a class="reference external" href="#dedup">dedup</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=duplicate buffers can be evicted, 1=do
not evict duplicate buffers</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.6.5, deprecated in v0.7.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-expire-snapshot">
<h3>zfs_expire_snapshot<a class="headerlink" href="#zfs-expire-snapshot" title="Permalink to this headline">¶</a></h3>
<p>Snapshots of filesystems are normally automounted under the filesystem’s
<code class="docutils literal notranslate"><span class="pre">.zfs/snapshot</span></code> subdirectory. When not in use, snapshots are unmounted
after zfs_expire_snapshot seconds.</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_expire_snapshot</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#filesystem">filesystem</a>,
<a class="reference external" href="#snapshot">snapshot</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>seconds</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 disables automatic unmounting, maximum time
is INT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>300</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.1 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-admin-snapshot">
<h3>zfs_admin_snapshot<a class="headerlink" href="#zfs-admin-snapshot" title="Permalink to this headline">¶</a></h3>
<p>Allow the creation, removal, or renaming of entries in the
<code class="docutils literal notranslate"><span class="pre">.zfs/snapshot</span></code> subdirectory to cause the creation, destruction, or
renaming of snapshots. When enabled this functionality works both
locally and over NFS exports which have the “no_root_squash” option set.</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_admin_snapshot</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#filesystem">filesystem</a>,
<a class="reference external" href="#snapshot">snapshot</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=do not allow snapshot manipulation via the
filesystem, 1=allow snapshot manipulation via
the filesystem</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.6.5 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-flags">
<h3>zfs_flags<a class="headerlink" href="#zfs-flags" title="Permalink to this headline">¶</a></h3>
<p>Set additional debugging flags (see
<a class="reference external" href="#zfs-dbgmsg-enable">zfs_dbgmsg_enable</a>)</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="41%" />
<col width="41%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">flag value</th>
<th class="head">symbolic name</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x1</td>
<td>ZFS_DEBUG_DPRINTF</td>
<td>Enable dprintf entries in
the debug log</td>
</tr>
<tr class="row-odd"><td>0x2</td>
<td>ZFS_DEBUG_DBUF_VERIFY</td>
<td>Enable extra dnode
verifications</td>
</tr>
<tr class="row-even"><td>0x4</td>
<td>ZFS_DEBUG_DNODE_VERIFY</td>
<td>Enable extra dnode
verifications</td>
</tr>
<tr class="row-odd"><td>0x8</td>
<td>ZFS_DEBUG_SNAPNAMES</td>
<td>Enable snapshot name
verification</td>
</tr>
<tr class="row-even"><td>0x10</td>
<td>ZFS_DEBUG_MODIFY</td>
<td>Check for illegally
modified ARC buffers</td>
</tr>
<tr class="row-odd"><td>0x20</td>
<td>ZFS_DEBUG_SPA</td>
<td>Enable spa_dbgmsg entries
in the debug log</td>
</tr>
<tr class="row-even"><td>0x40</td>
<td>ZFS_DEBUG_ZIO_FREE</td>
<td>Enable verification of
block frees</td>
</tr>
<tr class="row-odd"><td>0x80</td>
<td>Z
FS_DEBUG_HISTOGRAM_VERIFY</td>
<td>Enable extra spacemap
histogram verifications</td>
</tr>
<tr class="row-even"><td>0x100</td>
<td>ZFS_DEBUG_METASLAB_VERIFY</td>
<td>Verify space accounting
on disk matches in-core
range_trees</td>
</tr>
<tr class="row-odd"><td>0x200</td>
<td>ZFS_DEBUG_SET_ERROR</td>
<td>Enable SET_ERROR and
dprintf entries in the
debug log</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_flags</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#debug">debug</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>When debugging ZFS</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>0 no debug flags set, for debug builds: all
except ZFS_DEBUG_DPRINTF and ZFS_DEBUG_SPA</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.4 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-free-leak-on-eio">
<h3>zfs_free_leak_on_eio<a class="headerlink" href="#zfs-free-leak-on-eio" title="Permalink to this headline">¶</a></h3>
<p>If destroy encounters an I/O error (EIO) while reading metadata (eg
indirect blocks), space referenced by the missing metadata cannot be
freed. Normally, this causes the background destroy to become “stalled”,
as the destroy is unable to make forward progress. While in this stalled
state, all remaining space to free from the error-encountering
filesystem is temporarily leaked. Set <code class="docutils literal notranslate"><span class="pre">zfs_free_leak_on_eio</span> <span class="pre">=</span> <span class="pre">1</span></code> to
ignore the EIO, permanently leak the space from indirect blocks that can
not be read, and continue to free everything else that it can.</p>
<p>The default, stalling behavior is useful if the storage partially fails
(eg some but not all I/Os fail), and then later recovers. In this case,
we will be able to continue pool operations while it is partially
failed, and when it recovers, we can continue to free the space, with no
leaks. However, note that this case is rare.</p>
<p>Typically pools either:</p>
<ol class="arabic simple">
<li>fail completely (but perhaps temporarily (eg a top-level vdev going
offline)</li>
<li>have localized, permanent errors (eg disk returns the wrong data due
to bit flip or firmware bug)</li>
</ol>
<p>In case (1), the <code class="docutils literal notranslate"><span class="pre">zfs_free_leak_on_eio</span></code> setting does not matter
because the pool will be suspended and the sync thread will not be able
to make forward progress. In case (2), because the error is permanent,
the best effort do is leak the minimum amount of space. Therefore, it is
reasonable for <code class="docutils literal notranslate"><span class="pre">zfs_free_leak_on_eio</span></code> be set, but by default the more
conservative approach is taken, so that there is no possibility of
leaking space in the “partial temporary” failure case.</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_free_leak_on_eio</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#debug">debug</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>When debugging I/O errors during destroy</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=normal behavior, 1=ignore error and
permanently leak space</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.6.5 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-free-min-time-ms">
<h3>zfs_free_min_time_ms<a class="headerlink" href="#zfs-free-min-time-ms" title="Permalink to this headline">¶</a></h3>
<p>During a <code class="docutils literal notranslate"><span class="pre">zfs</span> <span class="pre">destroy</span></code> operation using <code class="docutils literal notranslate"><span class="pre">feature&#64;async_destroy</span></code> a
minimum of <code class="docutils literal notranslate"><span class="pre">zfs_free_min_time_ms</span></code> time will be spent working on
freeing blocks per txg commit.</p>
<table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_free_min_time_ms</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#delete">delete</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>milliseconds</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to (zfs_txg_timeout * 1000)</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>1,000</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-immediate-write-sz">
<h3>zfs_immediate_write_sz<a class="headerlink" href="#zfs-immediate-write-sz" title="Permalink to this headline">¶</a></h3>
<p>If a pool does not have a log device, data blocks equal to or larger
than <code class="docutils literal notranslate"><span class="pre">zfs_immediate_write_sz</span></code> are treated as if the dataset being
written to had the property setting <code class="docutils literal notranslate"><span class="pre">logbias=throughput</span></code></p>
<p>Terminology note: <code class="docutils literal notranslate"><span class="pre">logbias=throughput</span></code> writes the blocks in “indirect
mode” to the ZIL where the data is written to the pool and a pointer to
the data is written to the ZIL.</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_immediate_write_sz</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#zil">ZIL</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>long</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>512 to 16,777,216 (valid block sizes)</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>32,768 (32 KiB)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Verification</td>
<td>Data blocks that exceed
<code class="docutils literal notranslate"><span class="pre">zfs_immediate_write_sz</span></code> or are written
as <code class="docutils literal notranslate"><span class="pre">logbias=throughput</span></code> increment the
<code class="docutils literal notranslate"><span class="pre">zil_itx_indirect_count</span></code> entry in
<code class="docutils literal notranslate"><span class="pre">/proc/spl/kstat/zfs/zil</span></code></td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-max-recordsize">
<h3>zfs_max_recordsize<a class="headerlink" href="#zfs-max-recordsize" title="Permalink to this headline">¶</a></h3>
<p>ZFS supports logical record (block) sizes from 512 bytes to 16 MiB. The
benefits of larger blocks, and thus larger average I/O sizes, can be
weighed against the cost of copy-on-write of large block to modify one
byte. Additionally, very large blocks can have a negative impact on both
I/O latency at the device level and the memory allocator. The
<code class="docutils literal notranslate"><span class="pre">zfs_max_recordsize</span></code> parameter limits the upper bound of the dataset
volblocksize and recordsize properties.</p>
<p>Larger blocks can be created by enabling <code class="docutils literal notranslate"><span class="pre">zpool</span></code> <code class="docutils literal notranslate"><span class="pre">large_blocks</span></code>
feature and changing this <code class="docutils literal notranslate"><span class="pre">zfs_max_recordsize</span></code>. Pools with larger
blocks can always be imported and used, regardless of the value of
<code class="docutils literal notranslate"><span class="pre">zfs_max_recordsize</span></code>.</p>
<p>For 32-bit systems, <code class="docutils literal notranslate"><span class="pre">zfs_max_recordsize</span></code> also limits the size of
kernel virtual memory caches used in the ZFS I/O pipeline (<code class="docutils literal notranslate"><span class="pre">zio_buf_*</span></code>
and <code class="docutils literal notranslate"><span class="pre">zio_data_buf_*</span></code>).</p>
<p>See also the <code class="docutils literal notranslate"><span class="pre">zpool</span></code> <code class="docutils literal notranslate"><span class="pre">large_blocks</span></code> feature.</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_max_recordsize</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#filesystem">filesystem</a>,
<a class="reference external" href="#memory">memory</a>, <a class="reference external" href="#volume">volume</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>To create datasets with larger volblocksize or
recordsize</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>512 to 16,777,216 (valid block sizes)</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>1,048,576</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic, set prior to creating volumes or
changing filesystem recordsize</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.5 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-mdcomp-disable">
<h3>zfs_mdcomp_disable<a class="headerlink" href="#zfs-mdcomp-disable" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_mdcomp_disable</span></code> allows metadata compression to be disabled.</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_mdcomp_disable</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#cpu">CPU</a>, <a class="reference external" href="#metadata">metadata</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>When CPU cycles cost less than I/O</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=compress metadata, 1=do not compress metadata</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>from v0.6.0 to v0.8.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-metaslab-fragmentation-threshold">
<h3>zfs_metaslab_fragmentation_threshold<a class="headerlink" href="#zfs-metaslab-fragmentation-threshold" title="Permalink to this headline">¶</a></h3>
<p>Allow metaslabs to keep their active state as long as their
fragmentation percentage is less than or equal to this value. When
writing, an active metaslab whose fragmentation percentage exceeds
<code class="docutils literal notranslate"><span class="pre">zfs_metaslab_fragmentation_threshold</span></code> is avoided allowing metaslabs
with less fragmentation to be preferred.</p>
<p>Metaslab fragmentation is used to calculate the overall pool
<code class="docutils literal notranslate"><span class="pre">fragmentation</span></code> property value. However, individual metaslab
fragmentation levels are observable using the <code class="docutils literal notranslate"><span class="pre">zdb</span></code> with the <code class="docutils literal notranslate"><span class="pre">-mm</span></code>
option.</p>
<p><code class="docutils literal notranslate"><span class="pre">zfs_metaslab_fragmentation_threshold</span></code> works at the metaslab level and
each top-level vdev has approximately
<a class="reference external" href="#metaslabs-per-vdev">metaslabs_per_vdev</a> metaslabs. See also
<a class="reference external" href="#zfs-mg-fragmentation-threshold">zfs_mg_fragmentation_threshold</a></p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_metaslab_fragmentation_thresh
old</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#allocation">allocation</a>,
<a class="reference external" href="#fragmentation">fr
agmentation</a>,
<a class="reference external" href="#vdev">vdev</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Testing metaslab allocation</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>percent</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to 100</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>70</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.4 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-mg-fragmentation-threshold">
<h3>zfs_mg_fragmentation_threshold<a class="headerlink" href="#zfs-mg-fragmentation-threshold" title="Permalink to this headline">¶</a></h3>
<p>Metaslab groups (top-level vdevs) are considered eligible for
allocations if their fragmentation percentage metric is less than or
equal to <code class="docutils literal notranslate"><span class="pre">zfs_mg_fragmentation_threshold</span></code>. If a metaslab group exceeds
this threshold then it will be skipped unless all metaslab groups within
the metaslab class have also crossed the
<code class="docutils literal notranslate"><span class="pre">zfs_mg_fragmentation_threshold</span></code> threshold.</p>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="53%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_mg_fragmentation_threshold</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#allocation">allocation</a>,
`
fragmentation &lt;#fragmentation&gt;`__,
<a class="reference external" href="#vdev">vdev</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Testing metaslab allocation</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>percent</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to 100</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>85</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.4 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-mg-noalloc-threshold">
<h3>zfs_mg_noalloc_threshold<a class="headerlink" href="#zfs-mg-noalloc-threshold" title="Permalink to this headline">¶</a></h3>
<p>Metaslab groups (top-level vdevs) with free space percentage greater
than <code class="docutils literal notranslate"><span class="pre">zfs_mg_noalloc_threshold</span></code> are eligible for new allocations. If a
metaslab group’s free space is less than or equal to the threshold, the
allocator avoids allocating to that group unless all groups in the pool
have reached the threshold. Once all metaslab groups have reached the
threshold, all metaslab groups are allowed to accept allocations. The
default value of 0 disables the feature and causes all metaslab groups
to be eligible for allocations.</p>
<p>This parameter allows one to deal with pools having heavily imbalanced
vdevs such as would be the case when a new vdev has been added. Setting
the threshold to a non-zero percentage will stop allocations from being
made to vdevs that aren’t filled to the specified percentage and allow
lesser filled vdevs to acquire more allocations than they otherwise
would under the older <code class="docutils literal notranslate"><span class="pre">zfs_mg_alloc_failures</span></code> facility.</p>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="62%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_mg_noalloc_threshold</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#allocation">allocation</a>,
<a class="reference external" href="#fragmentation">fragmentation</a>,
<a class="reference external" href="#vdev">vdev</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>To force rebalancing as top-level vdevs
are added or expanded</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>percent</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to 100</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>0 (disabled)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-multihost-history">
<h3>zfs_multihost_history<a class="headerlink" href="#zfs-multihost-history" title="Permalink to this headline">¶</a></h3>
<p>The pool <code class="docutils literal notranslate"><span class="pre">multihost</span></code> multimodifier protection (MMP) subsystem can
record historical updates in the
<code class="docutils literal notranslate"><span class="pre">/proc/spl/kstat/zfs/POOL_NAME/multihost</span></code> file for debugging purposes.
The number of lines of history is determined by zfs_multihost_history.</p>
<table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_multihost_history</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#mmp">MMP</a>, <a class="reference external" href="#import">import</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>When testing multihost feature</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>lines</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to INT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-multihost-interval">
<h3>zfs_multihost_interval<a class="headerlink" href="#zfs-multihost-interval" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_multihost_interval</span></code> controls the frequency of multihost writes
performed by the pool multihost multimodifier protection (MMP)
subsystem. The multihost write period is (<code class="docutils literal notranslate"><span class="pre">zfs_multihost_interval</span></code> /
number of leaf-vdevs) milliseconds. Thus on average a multihost write
will be issued for each leaf vdev every <code class="docutils literal notranslate"><span class="pre">zfs_multihost_interval</span></code>
milliseconds. In practice, the observed period can vary with the I/O
load and this observed value is the delay which is stored in the
uberblock.</p>
<p>On import the multihost activity check waits a minimum amount of time
determined by (<code class="docutils literal notranslate"><span class="pre">zfs_multihost_interval</span></code> *
<a class="reference external" href="#zfs-multihost-import-intervals">zfs_multihost_import_intervals</a>)
with a lower bound of 1 second. The activity check time may be further
extended if the value of mmp delay found in the best uberblock indicates
actual multihost updates happened at longer intervals than
<code class="docutils literal notranslate"><span class="pre">zfs_multihost_interval</span></code></p>
<p>Note: the multihost protection feature applies to storage devices that
can be shared between multiple systems.</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_multihost_interval</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#mmp">MMP</a>, <a class="reference external" href="#import">import</a>,
<a class="reference external" href="#vdev">vdev</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>To optimize pool import time against
possibility of simultaneous import by
another system</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>ulong</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>milliseconds</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>100 to ULONG_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>1000</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-multihost-import-intervals">
<h3>zfs_multihost_import_intervals<a class="headerlink" href="#zfs-multihost-import-intervals" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_multihost_import_intervals</span></code> controls the duration of the activity
test on pool import for the multihost multimodifier protection (MMP)
subsystem. The activity test can be expected to take a minimum time of
(<code class="docutils literal notranslate"><span class="pre">zfs_multihost_import_interval</span></code>s *
<a class="reference external" href="#zfs-multihost-interval">zfs_multihost_interval</a> * <code class="docutils literal notranslate"><span class="pre">random(25%)</span></code>)
milliseconds. The random period of up to 25% improves simultaneous
import detection. For example, if two hosts are rebooted at the same
time and automatically attempt to import the pool, then is is highly
probable that one host will win.</p>
<p>Smaller values of <code class="docutils literal notranslate"><span class="pre">zfs_multihost_import_intervals</span></code> reduces the import
time but increases the risk of failing to detect an active pool. The
total activity check time is never allowed to drop below one second.</p>
<p>Note: the multihost protection feature applies to storage devices that
can be shared between multiple systems.</p>
<table border="1" class="docutils">
<colgroup>
<col width="45%" />
<col width="55%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_multihost_import_intervals</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#mmp">MMP</a>, <a class="reference external" href="#import">import</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>intervals</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to UINT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>10</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-multihost-fail-intervals">
<h3>zfs_multihost_fail_intervals<a class="headerlink" href="#zfs-multihost-fail-intervals" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_multihost_fail_intervals</span></code> controls the behavior of the pool when
write failures are detected in the multihost multimodifier protection
(MMP) subsystem.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">zfs_multihost_fail_intervals</span> <span class="pre">=</span> <span class="pre">0</span></code> then multihost write failures
are ignored. The write failures are reported to the ZFS event daemon
(<code class="docutils literal notranslate"><span class="pre">zed</span></code>) which can take action such as suspending the pool or offlining
a device.</p>
<div class="line-block">
<div class="line">If <code class="docutils literal notranslate"><span class="pre">zfs_multihost_fail_intervals</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> then sequential multihost
write failures will cause the pool to be suspended. This occurs when
(<code class="docutils literal notranslate"><span class="pre">zfs_multihost_fail_intervals</span></code> *
<a class="reference external" href="#zfs-multihost-interval">zfs_multihost_interval</a>) milliseconds
have passed since the last successful multihost write.</div>
<div class="line">This guarantees the activity test will see multihost writes if the
pool is attempted to be imported by another system.</div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_multihost_fail_intervals</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#mmp">MMP</a>, <a class="reference external" href="#import">import</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>intervals</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to UINT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>5</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-delays-per-second">
<h3>zfs_delays_per_second<a class="headerlink" href="#zfs-delays-per-second" title="Permalink to this headline">¶</a></h3>
<p>The ZFS Event Daemon (zed) processes events from ZFS. However, it can be
overwhelmed by high rates of error reports which can be generated by
failing, high-performance devices. <code class="docutils literal notranslate"><span class="pre">zfs_delays_per_second</span></code> limits the
rate of delay events reported to zed.</p>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_delays_per_second</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#zed">zed</a>, <a class="reference external" href="#delay">delay</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>If processing delay events at a higher rate
is desired</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>events per second</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to UINT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>20</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.7 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-checksums-per-second">
<h3>zfs_checksums_per_second<a class="headerlink" href="#zfs-checksums-per-second" title="Permalink to this headline">¶</a></h3>
<p>The ZFS Event Daemon (zed) processes events from ZFS. However, it can be
overwhelmed by high rates of error reports which can be generated by
failing, high-performance devices. <code class="docutils literal notranslate"><span class="pre">zfs_checksums_per_second</span></code> limits
the rate of checksum events reported to zed.</p>
<p>Note: do not set this value lower than the SERD limit for <code class="docutils literal notranslate"><span class="pre">checksum</span></code>
in zed. By default, <code class="docutils literal notranslate"><span class="pre">checksum_N</span></code> = 10 and <code class="docutils literal notranslate"><span class="pre">checksum_T</span></code> = 10 minutes,
resulting in a practical lower limit of 1.</p>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="62%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_checksums_per_second</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#zed">zed</a>, <a class="reference external" href="#checksum">checksum</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>If processing checksum error events at a
higher rate is desired</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>events per second</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to UINT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>20</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.7 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-no-scrub-io">
<h3>zfs_no_scrub_io<a class="headerlink" href="#zfs-no-scrub-io" title="Permalink to this headline">¶</a></h3>
<p>When <code class="docutils literal notranslate"><span class="pre">zfs_no_scrub_io</span> <span class="pre">=</span> <span class="pre">1</span></code> scrubs do not actually scrub data and
simply doing a metadata crawl of the pool instead.</p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="73%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_no_scrub_io</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#scrub">scrub</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Testing scrub feature</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=perform scrub I/O, 1=do not perform scrub I/O</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.6.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-no-scrub-prefetch">
<h3>zfs_no_scrub_prefetch<a class="headerlink" href="#zfs-no-scrub-prefetch" title="Permalink to this headline">¶</a></h3>
<p>When <code class="docutils literal notranslate"><span class="pre">zfs_no_scrub_prefetch</span> <span class="pre">=</span> <span class="pre">1</span></code>, prefetch is disabled for scrub I/Os.</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_no_scrub_prefetch</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#prefetch">prefetch</a>, <a class="reference external" href="#scrub">scrub</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Testing scrub feature</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=prefetch scrub I/Os, 1=do not prefetch scrub I/Os</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.6.4 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-nocacheflush">
<h3>zfs_nocacheflush<a class="headerlink" href="#zfs-nocacheflush" title="Permalink to this headline">¶</a></h3>
<p>ZFS uses barriers (volatile cache flush commands) to ensure data is
committed to permanent media by devices. This ensures consistent
on-media state for devices where caches are volatile (eg HDDs).</p>
<p>For devices with nonvolatile caches, the cache flush operation can be a
no-op. However, in some RAID arrays, cache flushes can cause the entire
cache to be flushed to the backing devices.</p>
<p>To ensure on-media consistency, keep cache flush enabled.</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_nocacheflush</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#disks">disks</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>If the storage device has nonvolatile cache,
then disabling cache flush can save the cost of
occasional cache flush comamnds</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=send cache flush commands, 1=do not send
cache flush commands</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-nopwrite-enabled">
<h3>zfs_nopwrite_enabled<a class="headerlink" href="#zfs-nopwrite-enabled" title="Permalink to this headline">¶</a></h3>
<p>The NOP-write feature is enabled by default when a
crytographically-secure checksum algorithm is in use by the dataset.
<code class="docutils literal notranslate"><span class="pre">zfs_nopwrite_enabled</span></code> allows the NOP-write feature to be completely
disabled.</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_nopwrite_enabled</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#checksum">checksum</a>, <a class="reference external" href="#debug">debug</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=disable NOP-write feature, 1=enable
NOP-write feature</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.6.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-dmu-offset-next-sync">
<h3>zfs_dmu_offset_next_sync<a class="headerlink" href="#zfs-dmu-offset-next-sync" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_dmu_offset_next_sync</span></code> enables forcing txg sync to find holes.
This causes ZFS to act like older versions when <code class="docutils literal notranslate"><span class="pre">SEEK_HOLE</span></code> or
<code class="docutils literal notranslate"><span class="pre">SEEK_DATA</span></code> flags are used: when a dirty dnode causes txgs to be
synced so the previous data can be found.</p>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="62%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_dmu_offset_next_sync</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#dmu">DMU</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=do not force txg sync to find holes,
1=force txg sync to find holes</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-pd-bytes-max">
<h3>zfs_pd_bytes_max<a class="headerlink" href="#zfs-pd-bytes-max" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_pd_bytes_max</span></code> limits the number of bytes prefetched during a pool
traversal (eg <code class="docutils literal notranslate"><span class="pre">zfs</span> <span class="pre">send</span></code> or other data crawling operations). These
prefetches are referred to as “prescient prefetches” and are always 100%
hit rate. The traversal operations do not use the default data or
metadata prefetcher.</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_pd_bytes_max</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#prefetch">prefetch</a>, <a class="reference external" href="#send">send</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int32</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to INT32_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>52,428,800 (50 MiB)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>TBD</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-per-txg-dirty-frees-percent">
<h3>zfs_per_txg_dirty_frees_percent<a class="headerlink" href="#zfs-per-txg-dirty-frees-percent" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_per_txg_dirty_frees_percent</span></code> as a percentage of
<a class="reference external" href="#zfs-dirty-data-max">zfs_dirty_data_max</a> controls the percentage of
dirtied blocks from frees in one txg. After the threshold is crossed,
additional dirty blocks from frees wait until the next txg. Thus, when
deleting large files, filling consecutive txgs with deletes/frees, does
not throttle other, perhaps more important, writes.</p>
<p>A side effect of this throttle can impact <code class="docutils literal notranslate"><span class="pre">zfs</span> <span class="pre">receive</span></code> workloads that
contain a large number of frees and the
<a class="reference external" href="#ignore-hole-birth">ignore_hole_birth</a> optimization is disabled. The
symptom is that the receive workload causes an increase in the frequency
of txg commits. The frequency of txg commits is observable via the
<code class="docutils literal notranslate"><span class="pre">otime</span></code> column of <code class="docutils literal notranslate"><span class="pre">/proc/spl/kstat/zfs/POOLNAME/txgs</span></code>. Since txg
commits also flush data from volatile caches in HDDs to media, HDD
performance can be negatively impacted. Also, since the frees do not
consume much bandwidth over the pipe, the pipe can appear to stall. Thus
the overall progress of receives is slower than expected.</p>
<p>A value of zero will disable this throttle.</p>
<table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_per_txg_dirty_frees_percent</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#delete">delete</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>For <code class="docutils literal notranslate"><span class="pre">zfs</span> <span class="pre">receive</span></code> workloads,
consider increasing or disabling.
See section <a class="reference external" href="https://github.com/zfsonlinux/zfs/wiki/ZIO-Scheduler">ZFS I/O
S
cheduler</a></td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>ulong</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>percent</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to 100</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>30</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-prefetch-disable">
<h3>zfs_prefetch_disable<a class="headerlink" href="#zfs-prefetch-disable" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_prefetch_disable</span></code> controls the predictive prefetcher.</p>
<p>Note that it leaves “prescient” prefetch (eg prefetch for <code class="docutils literal notranslate"><span class="pre">zfs</span> <span class="pre">send</span></code>)
intact (see <a class="reference external" href="#zfs-pd-bytes-max">zfs_pd_bytes_max</a>)</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_prefetch_disable</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#prefetch">prefetch</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>In some case where the workload is
completely random reads, overall performance
can be better if prefetch is disabled</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=prefetch enabled, 1=prefetch disabled</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Verification</td>
<td>prefetch efficacy is observed by
<code class="docutils literal notranslate"><span class="pre">arcstat</span></code>, <code class="docutils literal notranslate"><span class="pre">arc_summary</span></code>, and the
relevant entries in
<code class="docutils literal notranslate"><span class="pre">/proc/spl/kstat/zfs/arcstats</span></code></td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-read-chunk-size">
<h3>zfs_read_chunk_size<a class="headerlink" href="#zfs-read-chunk-size" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_read_chunk_size</span></code> is the limit for ZFS filesystem reads. If an
application issues a <code class="docutils literal notranslate"><span class="pre">read()</span></code> larger than <code class="docutils literal notranslate"><span class="pre">zfs_read_chunk_size</span></code>,
then the <code class="docutils literal notranslate"><span class="pre">read()</span></code> is divided into multiple operations no larger than
<code class="docutils literal notranslate"><span class="pre">zfs_read_chunk_size</span></code></p>
<table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_read_chunk_size</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#filesystem">filesystem</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>ulong</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>512 to ULONG_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>1,048,576</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-read-history">
<h3>zfs_read_history<a class="headerlink" href="#zfs-read-history" title="Permalink to this headline">¶</a></h3>
<p>Historical statistics for the last <code class="docutils literal notranslate"><span class="pre">zfs_read_history</span></code> reads are
available in <code class="docutils literal notranslate"><span class="pre">/proc/spl/kstat/zfs/POOL_NAME/reads</span></code></p>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_read_history</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#debug">debug</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>To observe read operation details</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>lines</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to INT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-read-history-hits">
<h3>zfs_read_history_hits<a class="headerlink" href="#zfs-read-history-hits" title="Permalink to this headline">¶</a></h3>
<p>When <a class="reference external" href="#zfs-read-history">zfs_read_history</a><code class="docutils literal notranslate"><span class="pre">&gt;</span> <span class="pre">0</span></code>,
zfs_read_history_hits controls whether ARC hits are displayed in the
read history file, <code class="docutils literal notranslate"><span class="pre">/proc/spl/kstat/zfs/POOL_NAME/reads</span></code></p>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_read_history_hits</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#debug">debug</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>To observe read operation details with ARC
hits</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=do not include data for ARC hits,
1=include ARC hit data</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-recover">
<h3>zfs_recover<a class="headerlink" href="#zfs-recover" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_recover</span></code> can be set to true (1) to attempt to recover from
otherwise-fatal errors, typically caused by on-disk corruption. When
set, calls to <code class="docutils literal notranslate"><span class="pre">zfs_panic_recover()</span></code> will turn into warning messages
rather than calling <code class="docutils literal notranslate"><span class="pre">panic()</span></code></p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_recover</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#import">import</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>zfs_recover should only be used as a last
resort, as it typically results in leaked
space, or worse</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=normal operation, 1=attempt recovery zpool
import</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Verification</td>
<td>check output of <code class="docutils literal notranslate"><span class="pre">dmesg</span></code> and other logs for
details</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.4 or later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-resilver-min-time-ms">
<h3>zfs_resilver_min_time_ms<a class="headerlink" href="#zfs-resilver-min-time-ms" title="Permalink to this headline">¶</a></h3>
<p>Resilvers are processed by the sync thread in syncing context. While
resilvering, ZFS spends at least <code class="docutils literal notranslate"><span class="pre">zfs_resilver_min_time_ms</span></code> time
working on a resilver between txg commits.</p>
<p>The <a class="reference external" href="#zfs-txg-timeout">zfs_txg_timeout</a> tunable sets a nominal
timeout value for the txg commits. By default, this timeout is 5 seconds
and the <code class="docutils literal notranslate"><span class="pre">zfs_resilver_min_time_ms</span></code> is 3 seconds. However, many
variables contribute to changing the actual txg times. The measured txg
interval is observed as the <code class="docutils literal notranslate"><span class="pre">otime</span></code> column (in nanoseconds) in the
<code class="docutils literal notranslate"><span class="pre">/proc/spl/kstat/zfs/POOL_NAME/txgs</span></code> file.</p>
<p>See also <a class="reference external" href="#zfs-txg-timeout">zfs_txg_timeout</a> and
<a class="reference external" href="#zfs-scan-min-time-ms">zfs_scan_min_time_ms</a></p>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="62%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_resilver_min_time_ms</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#resilver">resilver</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>In some resilvering cases, increasing
<code class="docutils literal notranslate"><span class="pre">zfs_resilver_min_time_ms</span></code> can result
in faster completion</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>milliseconds</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to
<a class="reference external" href="#zfs-txg-timeout">zfs_txg_timeout</a>
converted to milliseconds</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>3,000</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-scan-min-time-ms">
<h3>zfs_scan_min_time_ms<a class="headerlink" href="#zfs-scan-min-time-ms" title="Permalink to this headline">¶</a></h3>
<p>Scrubs are processed by the sync thread in syncing context. While
scrubbing, ZFS spends at least <code class="docutils literal notranslate"><span class="pre">zfs_scan_min_time_ms</span></code> time working on
a scrub between txg commits.</p>
<p>See also <a class="reference external" href="#zfs-txg-timeout">zfs_txg_timeout</a> and
<a class="reference external" href="#zfs-resilver-min-time-ms">zfs_resilver_min_time_ms</a></p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_scan_min_time_ms</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#scrub">scrub</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>In some scrub cases, increasing
<code class="docutils literal notranslate"><span class="pre">zfs_scan_min_time_ms</span></code> can result in
faster completion</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>milliseconds</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to <a class="reference external" href="#zfs-txg-timeout">zfs_txg_timeout</a>
converted to milliseconds</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>1,000</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-scan-checkpoint-intval">
<h3>zfs_scan_checkpoint_intval<a class="headerlink" href="#zfs-scan-checkpoint-intval" title="Permalink to this headline">¶</a></h3>
<p>To preserve progress across reboots the sequential scan algorithm
periodically needs to stop metadata scanning and issue all the
verifications I/Os to disk every <code class="docutils literal notranslate"><span class="pre">zfs_scan_checkpoint_intval</span></code> seconds.</p>
<table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_scan_checkpoint_intval</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#resilver">resilver</a>, <a class="reference external" href="#scrub">scrub</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>seconds</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to INT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>7,200 (2 hours)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.8.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-scan-fill-weight">
<h3>zfs_scan_fill_weight<a class="headerlink" href="#zfs-scan-fill-weight" title="Permalink to this headline">¶</a></h3>
<p>This tunable affects how scrub and resilver I/O segments are ordered. A
higher number indicates that we care more about how filled in a segment
is, while a lower number indicates we care more about the size of the
extent without considering the gaps within a segment.</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_scan_fill_weight</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#resilver">resilver</a>, <a class="reference external" href="#scrub">scrub</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Testing sequential scrub and resilver</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>scalar</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to INT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>3</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Prior to zfs module load</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.8.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-scan-issue-strategy">
<h3>zfs_scan_issue_strategy<a class="headerlink" href="#zfs-scan-issue-strategy" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_scan_issue_strategy</span></code> controls the order of data verification
while scrubbing or resilvering.</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>fs will use strategy 1 during normal verification and
strategy 2 while taking a checkpoint</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>data is verified as sequentially as possible, given the
amount of memory reserved for scrubbing (see
<a class="reference external" href="#zfs-scan-mem-lim-fact">zfs_scan_mem_lim_fact</a>). This
can improve scrub performance if the pool’s data is heavily
fragmented.</td>
</tr>
<tr class="row-even"><td>2</td>
<td>the largest mostly-contiguous chunk of found data is
verified first. By deferring scrubbing of small segments,
we may later find adjacent data to coalesce and increase
the segment size.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_scan_issue_strategy</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#resilver">resilver</a>, <a class="reference external" href="#scrub">scrub</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>enum</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0 to 2</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>TBD</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-scan-legacy">
<h3>zfs_scan_legacy<a class="headerlink" href="#zfs-scan-legacy" title="Permalink to this headline">¶</a></h3>
<p>Setting <code class="docutils literal notranslate"><span class="pre">zfs_scan_legacy</span> <span class="pre">=</span> <span class="pre">1</span></code> enables the legacy scan and scrub
behavior instead of the newer sequential behavior.</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_scan_legacy</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#resilver">resilver</a>, <a class="reference external" href="#scrub">scrub</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>In some cases, the new scan mode can consumer
more memory as it collects and sorts I/Os;
using the legacy algorithm can be more memory
efficient at the expense of HDD read efficiency</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=use new method: scrubs and resilvers will
gather metadata in memory before issuing
sequential I/O, 1=use legacy algorithm will be
used where I/O is initiated as soon as it is
discovered</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic, however changing to 0 does not affect
in-progress scrubs or resilvers</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.8.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-scan-max-ext-gap">
<h3>zfs_scan_max_ext_gap<a class="headerlink" href="#zfs-scan-max-ext-gap" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_scan_max_ext_gap</span></code> limits the largest gap in bytes between scrub
and resilver I/Os that will still be considered sequential for sorting
purposes.</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_scan_max_ext_gap</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#resilver">resilver</a>, <a class="reference external" href="#scrub">scrub</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>ulong</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>512 to ULONG_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>2,097,152 (2 MiB)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic, however changing to 0 does not
affect in-progress scrubs or resilvers</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.8.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-scan-mem-lim-fact">
<h3>zfs_scan_mem_lim_fact<a class="headerlink" href="#zfs-scan-mem-lim-fact" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_scan_mem_lim_fact</span></code> limits the maximum fraction of RAM used for
I/O sorting by sequential scan algorithm. When the limit is reached
scanning metadata is stopped and data verification I/O is started. Data
verification I/O continues until the memory used by the sorting
algorithm drops below below
<a class="reference external" href="#zfs-scan-mem-lim-soft-fact">zfs_scan_mem_lim_soft_fact</a></p>
<p>Memory used by the sequential scan algorithm can be observed as the kmem
sio_cache. This is visible from procfs as
<code class="docutils literal notranslate"><span class="pre">grep</span> <span class="pre">sio_cache</span> <span class="pre">/proc/slabinfo</span></code> and can be monitored using
slab-monitoring tools such as <code class="docutils literal notranslate"><span class="pre">slabtop</span></code></p>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_scan_mem_lim_fact</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#memory">memory</a>,
<a class="reference external" href="#resilver">resilver</a>,
<a class="reference external" href="#scrub">scrub</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>divisor of physical RAM</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>20 (physical RAM / 20 or 5%)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.8.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-scan-mem-lim-soft-fact">
<h3>zfs_scan_mem_lim_soft_fact<a class="headerlink" href="#zfs-scan-mem-lim-soft-fact" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_scan_mem_lim_soft_fact</span></code> sets the fraction of the hard limit,
<a class="reference external" href="#zfs-scan-mem-lim-fact">zfs_scan_mem_lim_fact</a>, used to determined
the RAM soft limit for I/O sorting by the sequential scan algorithm.
After <a class="reference external" href="#zfs-scan-mem-lim-fact">zfs_scan_mem_lim_fact</a> has been
reached, metadata scanning is stopped until the RAM usage drops below
<code class="docutils literal notranslate"><span class="pre">zfs_scan_mem_lim_soft_fact</span></code></p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_scan_mem_lim_soft_fact</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#resilver">resilver</a>,
<a class="reference external" href="#scrub">scrub</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>divisor of (physical RAM /
<a class="reference external" href="#zfs-scan-mem-lim-fact">zfs_scan_mem
_lim_fact</a>)</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to INT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>20 (for default
<a class="reference external" href="#zfs-scan-mem-lim-fact">zfs_scan_mem
_lim_fact</a>,
0.25% of physical RAM)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.8.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-scan-vdev-limit">
<h3>zfs_scan_vdev_limit<a class="headerlink" href="#zfs-scan-vdev-limit" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_scan_vdev_limit</span></code> is the maximum amount of data that can be
concurrently issued at once for scrubs and resilvers per leaf vdev.
<code class="docutils literal notranslate"><span class="pre">zfs_scan_vdev_limit</span></code> attempts to strike a balance between keeping the
leaf vdev queues full of I/Os while not overflowing the queues causing
high latency resulting in long txg sync times. While
<code class="docutils literal notranslate"><span class="pre">zfs_scan_vdev_limit</span></code> represents a bandwidth limit, the existing I/O
limit of <a class="reference external" href="#zfs-vdev-scrub-max-active">zfs_vdev_scrub_max_active</a>
remains in effect, too.</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_scan_vdev_limit</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#resilver">resilver</a>, <a class="reference external" href="#scrub">scrub</a>,
<a class="reference external" href="#vdev">vdev</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>ulong</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>512 to ULONG_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>4,194,304 (4 MiB)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.8.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-send-corrupt-data">
<h3>zfs_send_corrupt_data<a class="headerlink" href="#zfs-send-corrupt-data" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_send_corrupt_data</span></code> enables <code class="docutils literal notranslate"><span class="pre">zfs</span> <span class="pre">send</span></code> to send of corrupt data
by ignoring read and checksum errors. The corrupted or unreadable blocks
are replaced with the value <code class="docutils literal notranslate"><span class="pre">0x2f5baddb10c</span></code> (ZFS bad block)</p>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_send_corrupt_data</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#send">send</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>When data corruption exists and an attempt
to recover at least some data via
<code class="docutils literal notranslate"><span class="pre">zfs</span> <span class="pre">send</span></code> is needed</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=do not send corrupt data, 1=replace
corrupt data with cookie</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.6.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-sync-pass-deferred-free">
<h3>zfs_sync_pass_deferred_free<a class="headerlink" href="#zfs-sync-pass-deferred-free" title="Permalink to this headline">¶</a></h3>
<p>The SPA sync process is performed in multiple passes. Once the pass
number reaches <code class="docutils literal notranslate"><span class="pre">zfs_sync_pass_deferred_free</span></code>, frees are no long
processed and must wait for the next SPA sync.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">zfs_sync_pass_deferred_free</span></code> value is expected to be removed as a
tunable once the optimal value is determined during field testing.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">zfs_sync_pass_deferred_free</span></code> pass must be greater than 1 to
ensure that regular blocks are not deferred.</p>
<table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="47%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_sync_pass_deferred_free</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#spa">SPA</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Testing SPA sync process</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>SPA sync passes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to INT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>2</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-sync-pass-dont-compress">
<h3>zfs_sync_pass_dont_compress<a class="headerlink" href="#zfs-sync-pass-dont-compress" title="Permalink to this headline">¶</a></h3>
<p>The SPA sync process is performed in multiple passes. Once the pass
number reaches <code class="docutils literal notranslate"><span class="pre">zfs_sync_pass_dont_compress</span></code>, data block compression
is no longer processed and must wait for the next SPA sync.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">zfs_sync_pass_dont_compress</span></code> value is expected to be removed as a
tunable once the optimal value is determined during field testing.</p>
<table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="47%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_sync_pass_dont_compress</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#spa">SPA</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Testing SPA sync process</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>SPA sync passes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to INT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>5</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-sync-pass-rewrite">
<h3>zfs_sync_pass_rewrite<a class="headerlink" href="#zfs-sync-pass-rewrite" title="Permalink to this headline">¶</a></h3>
<p>The SPA sync process is performed in multiple passes. Once the pass
number reaches <code class="docutils literal notranslate"><span class="pre">zfs_sync_pass_rewrite</span></code>, blocks can be split into gang
blocks.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">zfs_sync_pass_rewrite</span></code> value is expected to be removed as a
tunable once the optimal value is determined during field testing.</p>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="53%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_sync_pass_rewrite</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#spa">SPA</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Testing SPA sync process</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>SPA sync passes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to INT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>2</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-sync-taskq-batch-pct">
<h3>zfs_sync_taskq_batch_pct<a class="headerlink" href="#zfs-sync-taskq-batch-pct" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_sync_taskq_batch_pct</span></code> controls the number of threads used by the
DSL pool sync taskq, <code class="docutils literal notranslate"><span class="pre">dp_sync_taskq</span></code></p>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="62%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_sync_taskq_batch_pct</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#spa">SPA</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>to adjust the number of
<code class="docutils literal notranslate"><span class="pre">dp_sync_taskq</span></code> threads</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>percent of number of online CPUs</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to 100</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>75</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Prior to zfs module load</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-txg-history">
<h3>zfs_txg_history<a class="headerlink" href="#zfs-txg-history" title="Permalink to this headline">¶</a></h3>
<p>Historical statistics for the last <code class="docutils literal notranslate"><span class="pre">zfs_txg_history</span></code> txg commits are
available in <code class="docutils literal notranslate"><span class="pre">/proc/spl/kstat/zfs/POOL_NAME/txgs</span></code></p>
<p>The work required to measure the txg commit (SPA statistics) is low.
However, for debugging purposes, it can be useful to observe the SPA
statistics.</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="76%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_txg_history</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#debug">debug</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>To observe details of SPA sync behavior.</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>lines</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to INT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>0 for version v0.6.0 to v0.7.6, 100 for version v0.8.0</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-txg-timeout">
<h3>zfs_txg_timeout<a class="headerlink" href="#zfs-txg-timeout" title="Permalink to this headline">¶</a></h3>
<p>The open txg is committed to the pool periodically (SPA sync) and
<code class="docutils literal notranslate"><span class="pre">zfs_txg_timeout</span></code> represents the default target upper limit.</p>
<p>txg commits can occur more frequently and a rapid rate of txg commits
often indicates a busy write workload, quota limits reached, or the free
space is critically low.</p>
<p>Many variables contribute to changing the actual txg times. txg commits
can also take longer than <code class="docutils literal notranslate"><span class="pre">zfs_txg_timeout</span></code> if the ZFS write throttle
is not properly tuned or the time to sync is otherwise delayed (eg slow
device). Shorter txg commit intervals can occur due to
<a class="reference external" href="#zfs-dirty-data-sync">zfs_dirty_data_sync</a> for write-intensive
workloads. The measured txg interval is observed as the <code class="docutils literal notranslate"><span class="pre">otime</span></code> column
(in nanoseconds) in the <code class="docutils literal notranslate"><span class="pre">/proc/spl/kstat/zfs/POOL_NAME/txgs</span></code> file.</p>
<p>See also <a class="reference external" href="#zfs-dirty-data-sync">zfs_dirty_data_sync</a> and
<a class="reference external" href="#zfs-txg-history">zfs_txg_history</a></p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_txg_timeout</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#spa">SPA</a>,
<a class="reference external" href="#zio-scheduler">ZIO_scheduler</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>To optimize the work done by txg commit
relative to the pool requirements. See also
section <a class="reference external" href="https://github.com/zfsonlinux/zfs/wiki/ZIO-Scheduler">ZFS I/O
Scheduler</a></td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>seconds</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to INT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>5</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-aggregation-limit">
<h3>zfs_vdev_aggregation_limit<a class="headerlink" href="#zfs-vdev-aggregation-limit" title="Permalink to this headline">¶</a></h3>
<p>To reduce IOPs, small, adjacent I/Os can be aggregated (coalesced) into
a large I/O. For reads, aggregations occur across small adjacency gaps.
For writes, aggregation can occur at the ZFS or disk level.
<code class="docutils literal notranslate"><span class="pre">zfs_vdev_aggregation_limit</span></code> is the upper bound on the size of the
larger, aggregated I/O.</p>
<p>Setting <code class="docutils literal notranslate"><span class="pre">zfs_vdev_aggregation_limit</span> <span class="pre">=</span> <span class="pre">0</span></code> effectively disables
aggregation by ZFS. However, the block device scheduler can still merge
(aggregate) I/Os. Also, many devices, such as modern HDDs, contain
schedulers that can aggregate I/Os.</p>
<p>In general, I/O aggregation can improve performance for devices, such as
HDDs, where ordering I/O operations for contiguous LBAs is a benefit.
For random access devices, such as SSDs, aggregation might not improve
performance relative to the CPU cycles needed to aggregate. For devices
that represent themselves as having no rotation, the
<a class="reference external" href="#zfs-vdev-aggregation-limit-non-rotating">zfs_vdev_aggregation_limit_non_rotating</a>
parameter is used instead of <code class="docutils literal notranslate"><span class="pre">zfs_vdev_aggregation_limit</span></code></p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_vdev_aggregation_limit</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a>,
<a class="reference external" href="#zio-scheduler">ZIO_scheduler</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>If the workload does not benefit from
aggregation, the
<code class="docutils literal notranslate"><span class="pre">zfs_vdev_aggregation_limit</span></code> can be
reduced to avoid aggregation attempts</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to 1,048,576 (default) or 16,777,216
(if <code class="docutils literal notranslate"><span class="pre">zpool</span></code> <code class="docutils literal notranslate"><span class="pre">large_blocks</span></code> feature
is enabled)</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>1,048,576, or 131,072 for &lt;v0.8</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Verification</td>
<td>ZFS aggregation is observed with
<code class="docutils literal notranslate"><span class="pre">zpool</span> <span class="pre">iostat</span> <span class="pre">-r</span></code> and the block
scheduler merging is observed with
<code class="docutils literal notranslate"><span class="pre">iostat</span> <span class="pre">-x</span></code></td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-cache-size">
<h3>zfs_vdev_cache_size<a class="headerlink" href="#zfs-vdev-cache-size" title="Permalink to this headline">¶</a></h3>
<p>Note: with the current ZFS code, the vdev cache is not helpful and in
some cases actually harmful. Thusit is disabled by setting the
<code class="docutils literal notranslate"><span class="pre">zfs_vdev_cache_size</span> <span class="pre">=</span> <span class="pre">0</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">zfs_vdev_cache_size</span></code> is the size of the vdev cache.</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_vdev_cache_size</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a>,
<a class="reference external" href="#vdev-cache">vdev_cache</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Do not change</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to MAX_INT</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>0 (vdev cache is disabled)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Verification</td>
<td>vdev cache statistics are availabe in the
<code class="docutils literal notranslate"><span class="pre">/proc/spl/kstat/zfs/vdev_cache_stats</span></code> file</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-cache-bshift">
<h3>zfs_vdev_cache_bshift<a class="headerlink" href="#zfs-vdev-cache-bshift" title="Permalink to this headline">¶</a></h3>
<p>Note: with the current ZFS code, the vdev cache is not helpful and in
some cases actually harmful. Thus it is disabled by setting the
<a class="reference external" href="#zfs-vdev-cache-size">zfs_vdev_cache_size</a> to zero. This related
tunable is, by default, inoperative.</p>
<p>All read I/Os smaller than <a class="reference external" href="#zfs-vdev-cache-max">zfs_vdev_cache_max</a>
are turned into (<code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;&lt;</span> <span class="pre">zfs_vdev_cache_bshift</span></code>) byte reads by the vdev
cache. At most <a class="reference external" href="#zfs-vdev-cache-size">zfs_vdev_cache_size</a> bytes will
be kept in each vdev’s cache.</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_vdev_cache_bshift</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a>, <a class="reference external" href="#vdev-cache">vdev_cache</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Do not change</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>shift</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to INT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>16 (65,536 bytes)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-cache-max">
<h3>zfs_vdev_cache_max<a class="headerlink" href="#zfs-vdev-cache-max" title="Permalink to this headline">¶</a></h3>
<p>Note: with the current ZFS code, the vdev cache is not helpful and in
some cases actually harmful. Thus it is disabled by setting the
<a class="reference external" href="#zfs-vdev-cache-size">zfs_vdev_cache_size</a> to zero. This related
tunable is, by default, inoperative.</p>
<p>All read I/Os smaller than zfs_vdev_cache_max will be turned into
(<code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;&lt;</span></code><a class="reference external" href="#zfs-vdev-cache-bshift">zfs_vdev_cache_bshift</a> byte reads
by the vdev cache. At most <code class="docutils literal notranslate"><span class="pre">zfs_vdev_cache_size</span></code> bytes will be kept in
each vdev’s cache.</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_vdev_cache_max</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a>, <a class="reference external" href="#vdev-cache">vdev_cache</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Do not change</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>512 to INT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>16,384 (16 KiB)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-mirror-rotating-inc">
<h3>zfs_vdev_mirror_rotating_inc<a class="headerlink" href="#zfs-vdev-mirror-rotating-inc" title="Permalink to this headline">¶</a></h3>
<p>The mirror read algorithm uses current load and an incremental weighting
value to determine the vdev to service a read operation. Lower values
determine the preferred vdev. The weighting value is
<code class="docutils literal notranslate"><span class="pre">zfs_vdev_mirror_rotating_inc</span></code> for rotating media and
<a class="reference external" href="#zfs-vdev-mirror-non-rotating-inc">zfs_vdev_mirror_non_rotating_inc</a>
for nonrotating media.</p>
<p>Verify the rotational setting described by a block device in sysfs by
observing <code class="docutils literal notranslate"><span class="pre">/sys/block/DISK_NAME/queue/rotational</span></code></p>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_vdev_mirror_rotating_inc</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a>,
<a class="reference external" href="#mirror">mirror</a>, <a class="reference external" href="#hdd">HDD</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Increasing for mirrors with both
rotating and nonrotating media more
strongly favors the nonrotating
media</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>scalar</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to MAX_INT</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-mirror-non-rotating-inc">
<h3>zfs_vdev_mirror_non_rotating_inc<a class="headerlink" href="#zfs-vdev-mirror-non-rotating-inc" title="Permalink to this headline">¶</a></h3>
<p>The mirror read algorithm uses current load and an incremental weighting
value to determine the vdev to service a read operation. Lower values
determine the preferred vdev. The weighting value is
<a class="reference external" href="#zfs-vdev-mirror-rotating-inc">zfs_vdev_mirror_rotating_inc</a> for
rotating media and <code class="docutils literal notranslate"><span class="pre">zfs_vdev_mirror_non_rotating_inc</span></code> for nonrotating
media.</p>
<p>Verify the rotational setting described by a block device in sysfs by
observing <code class="docutils literal notranslate"><span class="pre">/sys/block/DISK_NAME/queue/rotational</span></code></p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_vdev_mirror_non_rotating_inc</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a>,
<a class="reference external" href="#mirror">mirror</a>,
<a class="reference external" href="#ssd">SSD</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>scalar</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to INT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-mirror-rotating-seek-inc">
<h3>zfs_vdev_mirror_rotating_seek_inc<a class="headerlink" href="#zfs-vdev-mirror-rotating-seek-inc" title="Permalink to this headline">¶</a></h3>
<p>For rotating media in a mirror, if the next I/O offset is within
<a class="reference external" href="#zfs-vdev-mirror-rotating-seek-offset">zfs_vdev_mirror_rotating_seek_offset</a>
then the weighting factor is incremented by
(<code class="docutils literal notranslate"><span class="pre">zfs_vdev_mirror_rotating_seek_inc</span> <span class="pre">/</span> <span class="pre">2</span></code>). Otherwise the weighting
factor is increased by <code class="docutils literal notranslate"><span class="pre">zfs_vdev_mirror_rotating_seek_inc</span></code>. This
algorithm prefers rotating media with lower seek distance.</p>
<p>Verify the rotational setting described by a block device in sysfs by
observing <code class="docutils literal notranslate"><span class="pre">/sys/block/DISK_NAME/queue/rotational</span></code></p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">z
fs_vdev_mirror_rotating_seek_inc</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a>,
<a class="reference external" href="#mirror">mirror</a>,
<a class="reference external" href="#hdd">HDD</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>scalar</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to INT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>5</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-mirror-rotating-seek-offset">
<h3>zfs_vdev_mirror_rotating_seek_offset<a class="headerlink" href="#zfs-vdev-mirror-rotating-seek-offset" title="Permalink to this headline">¶</a></h3>
<p>For rotating media in a mirror, if the next I/O offset is within
<code class="docutils literal notranslate"><span class="pre">zfs_vdev_mirror_rotating_seek_offset</span></code> then the weighting factor is
incremented by
(<a class="reference external" href="#zfs-vdev-mirror-rotating-seek-inc">zfs_vdev_mirror_rotating_seek_inc</a><code class="docutils literal notranslate"><span class="pre">/</span> <span class="pre">2</span></code>).
Otherwise the weighting factor is increased by
<code class="docutils literal notranslate"><span class="pre">zfs_vdev_mirror_rotating_seek_inc</span></code>. This algorithm prefers rotating
media with lower seek distance.</p>
<p>Verify the rotational setting described by a block device in sysfs by
observing <code class="docutils literal notranslate"><span class="pre">/sys/block/DISK_NAME/queue/rotational</span></code></p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_vdev_mirror_rotating_seek_off
set</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a>,
<a class="reference external" href="#mirror">mirror</a>,
<a class="reference external" href="#hdd">HDD</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to INT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>1,048,576 (1 MiB)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-mirror-non-rotating-seek-inc">
<h3>zfs_vdev_mirror_non_rotating_seek_inc<a class="headerlink" href="#zfs-vdev-mirror-non-rotating-seek-inc" title="Permalink to this headline">¶</a></h3>
<p>For nonrotating media in a mirror, a seek penalty is applied as
sequential I/O’s can be aggregated into fewer operations, avoiding
unnecessary per-command overhead, often boosting performance.</p>
<p>Verify the rotational setting described by a block device in SysFS by
observing <code class="docutils literal notranslate"><span class="pre">/sys/block/DISK_NAME/queue/rotational</span></code></p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_v
dev_mirror_non_rotating_seek_inc</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a>,
<a class="reference external" href="#mirror">mirror</a>,
<a class="reference external" href="#ssd">SSD</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>scalar</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to INT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>1</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-read-gap-limit">
<h3>zfs_vdev_read_gap_limit<a class="headerlink" href="#zfs-vdev-read-gap-limit" title="Permalink to this headline">¶</a></h3>
<p>To reduce IOPs, small, adjacent I/Os are aggregated (coalesced) into
into a large I/O. For reads, aggregations occur across small adjacency
gaps where the gap is less than <code class="docutils literal notranslate"><span class="pre">zfs_vdev_read_gap_limit</span></code></p>
<table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_vdev_read_gap_limit</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a>,
<a class="reference external" href="#zio-scheduler">ZIO_scheduler</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to INT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>32,768 (32 KiB)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-write-gap-limit">
<h3>zfs_vdev_write_gap_limit<a class="headerlink" href="#zfs-vdev-write-gap-limit" title="Permalink to this headline">¶</a></h3>
<p>To reduce IOPs, small, adjacent I/Os are aggregated (coalesced) into
into a large I/O. For writes, aggregations occur across small adjacency
gaps where the gap is less than <code class="docutils literal notranslate"><span class="pre">zfs_vdev_write_gap_limit</span></code></p>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="62%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_vdev_write_gap_limit</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a>,
<a class="reference external" href="#zio-scheduler">ZIO_scheduler</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to INT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>4,096 (4 KiB)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-scheduler">
<h3>zfs_vdev_scheduler<a class="headerlink" href="#zfs-vdev-scheduler" title="Permalink to this headline">¶</a></h3>
<p>When the pool is imported, for whole disk vdevs, the block device I/O
scheduler is set to <code class="docutils literal notranslate"><span class="pre">zfs_vdev_scheduler</span></code>. The most common schedulers
are: <em>noop</em>, <em>cfq</em>, <em>bfq</em>, and <em>deadline</em>.</p>
<p>In some cases, the scheduler is not changeable using this method. Known
schedulers that cannot be changed are: <em>scsi_mq</em> and <em>none</em>. In these
cases, the scheduler is unchanged and an error message can be reported
to logs.</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_vdev_scheduler</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a>,
<a class="reference external" href="#zio-scheduler">ZIO_scheduler</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>since ZFS has its own I/O scheduler, using a
simple scheduler can result in more consistent
performance</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>string</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>expected: <em>noop</em>, <em>cfq</em>, <em>bfq</em>, and <em>deadline</em></td>
</tr>
<tr class="row-even"><td>Default</td>
<td><em>noop</em></td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic, but takes effect upon pool creation
or import</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-raidz-impl">
<h3>zfs_vdev_raidz_impl<a class="headerlink" href="#zfs-vdev-raidz-impl" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_vdev_raidz_impl</span></code> overrides the raidz parity algorithm. By
default, the algorithm is selected at zfs module load time by the
results of a microbenchmark of algorithms based on the current hardware.</p>
<p>Once the module is loaded, the content of
<code class="docutils literal notranslate"><span class="pre">/sys/module/zfs/parameters/zfs_vdev_raidz_impl</span></code> shows available
options with the currently selected enclosed in <code class="docutils literal notranslate"><span class="pre">[]</span></code>. Details of the
results of the microbenchmark are observable in the
<code class="docutils literal notranslate"><span class="pre">/proc/spl/kstat/zfs/vdev_raidz_bench</span></code> file.</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="35%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">algorithm</th>
<th class="head">architecture</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>fastest</td>
<td>all</td>
<td>fastest implementation
selected by
microbenchmark</td>
</tr>
<tr class="row-odd"><td>original</td>
<td>all</td>
<td>original raidz
implementation</td>
</tr>
<tr class="row-even"><td>scalar</td>
<td>all</td>
<td>scalar raidz
implementation</td>
</tr>
<tr class="row-odd"><td>sse2</td>
<td>64-bit x86</td>
<td>uses SSE2 instruction
set</td>
</tr>
<tr class="row-even"><td>ssse3</td>
<td>64-bit x86</td>
<td>uses SSSE3 instruction
set</td>
</tr>
<tr class="row-odd"><td>avx2</td>
<td>64-bit x86</td>
<td>uses AVX2 instruction
set</td>
</tr>
<tr class="row-even"><td>avx512f</td>
<td>64-bit x86</td>
<td>uses AVX512F
instruction set</td>
</tr>
<tr class="row-odd"><td>avx512bw</td>
<td>64-bit x86</td>
<td>uses AVX512F &amp; AVX512BW
instruction sets</td>
</tr>
<tr class="row-even"><td>aarch64_neon</td>
<td>aarch64/64 bit ARMv8</td>
<td>uses NEON</td>
</tr>
<tr class="row-odd"><td>aarch64_neonx2</td>
<td>aarch64/64 bit ARMv8</td>
<td>uses NEON with more
unrolling</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="73%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_vdev_raidz_impl</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#cpu">CPU</a>, <a class="reference external" href="#raidz">raidz</a>, <a class="reference external" href="#vdev">vdev</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>testing raidz algorithms</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>string</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>see table above</td>
</tr>
<tr class="row-even"><td>Default</td>
<td><em>fastest</em></td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-zevent-cols">
<h3>zfs_zevent_cols<a class="headerlink" href="#zfs-zevent-cols" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_zevent_cols</span></code> is a soft wrap limit in columns (characters) for ZFS
events logged to the console.</p>
<table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_zevent_cols</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#debug">debug</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>if 80 columns isn’t enough</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>characters</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to INT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>80</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-zevent-console">
<h3>zfs_zevent_console<a class="headerlink" href="#zfs-zevent-console" title="Permalink to this headline">¶</a></h3>
<p>If <code class="docutils literal notranslate"><span class="pre">zfs_zevent_console</span></code> is true (1), then ZFS events are logged to the
console.</p>
<p>More logging and log filtering capabilities are provided by <code class="docutils literal notranslate"><span class="pre">zed</span></code></p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_zevent_console</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#debug">debug</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>to log ZFS events to the console</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=do not log to console, 1=log to console</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-zevent-len-max">
<h3>zfs_zevent_len_max<a class="headerlink" href="#zfs-zevent-len-max" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_zevent_len_max</span></code> is the maximum ZFS event queue length. A value of
0 results in a calculated value (16 * number of CPUs) with a minimum of
64. Events in the queue can be viewed with the <code class="docutils literal notranslate"><span class="pre">zpool</span> <span class="pre">events</span></code> command.</p>
<table border="1" class="docutils">
<colgroup>
<col width="36%" />
<col width="64%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_zevent_len_max</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#debug">debug</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>increase to see more ZFS events</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>events</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to INT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>0 (calculate as described above)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-zil-clean-taskq-maxalloc">
<h3>zfs_zil_clean_taskq_maxalloc<a class="headerlink" href="#zfs-zil-clean-taskq-maxalloc" title="Permalink to this headline">¶</a></h3>
<p>During a SPA sync, intent log transaction groups (itxg) are cleaned. The
cleaning work is dispatched to the DSL pool ZIL clean taskq
(<code class="docutils literal notranslate"><span class="pre">dp_zil_clean_taskq</span></code>).
<a class="reference external" href="#zfs-zil-clean-taskq-minalloc">zfs_zil_clean_taskq_minalloc</a> is the
minumum and <code class="docutils literal notranslate"><span class="pre">zfs_zil_clean_taskq_maxalloc</span></code> is the maximum number of
cached taskq entries for <code class="docutils literal notranslate"><span class="pre">dp_zil_clean_taskq</span></code>. The actual number of
taskq entries dynamically varies between these values.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">zfs_zil_clean_taskq_maxalloc</span></code> is exceeded transaction records
(itxs) are cleaned synchronously with possible negative impact to the
performance of SPA sync.</p>
<p>Ideally taskq entries are pre-allocated prior to being needed by
<code class="docutils literal notranslate"><span class="pre">zil_clean()</span></code>, thus avoiding dynamic allocation of new taskq entries.</p>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_zil_clean_taskq_maxalloc</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#zil">ZIL</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>If more <code class="docutils literal notranslate"><span class="pre">dp_zil_clean_taskq</span></code>
entries are needed to prevent the
itxs from being synchronously
cleaned</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td><code class="docutils literal notranslate"><span class="pre">dp_zil_clean_taskq</span></code> taskq entries</td>
</tr>
<tr class="row-even"><td>Range</td>
<td><a class="reference external" href="#zfs-zil-clean-taskq-minalloc">zfs_zil_clean_taskq_minallo
c</a>
to <code class="docutils literal notranslate"><span class="pre">INT_MAX</span></code></td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>1,048,576</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic, takes effect per-pool when
the pool is imported</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.8.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-zil-clean-taskq-minalloc">
<h3>zfs_zil_clean_taskq_minalloc<a class="headerlink" href="#zfs-zil-clean-taskq-minalloc" title="Permalink to this headline">¶</a></h3>
<p>During a SPA sync, intent log transaction groups (itxg) are cleaned. The
cleaning work is dispatched to the DSL pool ZIL clean taskq
(<code class="docutils literal notranslate"><span class="pre">dp_zil_clean_taskq</span></code>). <code class="docutils literal notranslate"><span class="pre">zfs_zil_clean_taskq_minalloc</span></code> is the
minumum and
<a class="reference external" href="#zfs-zil-clean-taskq-maxalloc">zfs_zil_clean_taskq_maxalloc</a> is the
maximum number of cached taskq entries for <code class="docutils literal notranslate"><span class="pre">dp_zil_clean_taskq</span></code>. The
actual number of taskq entries dynamically varies between these values.</p>
<p><code class="docutils literal notranslate"><span class="pre">zfs_zil_clean_taskq_minalloc</span></code> is the minimum number of ZIL
transaction records (itxs).</p>
<p>Ideally taskq entries are pre-allocated prior to being needed by
<code class="docutils literal notranslate"><span class="pre">zil_clean()</span></code>, thus avoiding dynamic allocation of new taskq entries.</p>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_zil_clean_taskq_minalloc</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#zil">ZIL</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>dp_zil_clean_taskq taskq entries</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to
<a class="reference external" href="#zfs-zil-clean-taskq-maxalloc">zfs_zil_clean_taskq_maxallo
c</a></td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>1,024</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic, takes effect per-pool when
the pool is imported</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.8.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-zil-clean-taskq-nthr-pct">
<h3>zfs_zil_clean_taskq_nthr_pct<a class="headerlink" href="#zfs-zil-clean-taskq-nthr-pct" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_zil_clean_taskq_nthr_pct</span></code> controls the number of threads used by
the DSL pool ZIL clean taskq (<code class="docutils literal notranslate"><span class="pre">dp_zil_clean_taskq</span></code>). The default value
of 100% will create a maximum of one thread per cpu.</p>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_zil_clean_taskq_nthr_pct</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#taskq">taskq</a>, <a class="reference external" href="#zil">ZIL</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Testing ZIL clean and SPA sync
performance</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>percent of number of CPUs</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to 100</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>100</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic, takes effect per-pool when
the pool is imported</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.8.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zil-replay-disable">
<h3>zil_replay_disable<a class="headerlink" href="#zil-replay-disable" title="Permalink to this headline">¶</a></h3>
<p>If <code class="docutils literal notranslate"><span class="pre">zil_replay_disable</span> <span class="pre">=</span> <span class="pre">1</span></code>, then when a volume or filesystem is
brought online, no attempt to replay the ZIL is made and any existing
ZIL is destroyed. This can result in loss of data without notice.</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zil_replay_disable</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#debug">debug</a>, <a class="reference external" href="#zil">ZIL</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Do not change</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=replay ZIL, 1=destroy ZIL</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.6.5</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zil-slog-bulk">
<h3>zil_slog_bulk<a class="headerlink" href="#zil-slog-bulk" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zil_slog_bulk</span></code> is the log device write size limit per commit executed
with synchronous priority. Writes below <code class="docutils literal notranslate"><span class="pre">zil_slog_bulk</span></code> are executed
with synchronous priority. Writes above <code class="docutils literal notranslate"><span class="pre">zil_slog_bulk</span></code> are executed
with lower (asynchronous) priority to reduct potential log device abuse
by a single active ZIL writer.</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zil_slog_bulk</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#zil">ZIL</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>See <a class="reference external" href="https://github.com/zfsonlinux/zfs/wiki/ZIO-Scheduler">ZFS I/O
Scheduler</a></td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>ulong</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to ULONG_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>786,432</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.8.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zio-delay-max">
<h3>zio_delay_max<a class="headerlink" href="#zio-delay-max" title="Permalink to this headline">¶</a></h3>
<p>If a ZFS I/O operation takes more than <code class="docutils literal notranslate"><span class="pre">zio_delay_max</span></code> milliseconds to
complete, then an event is logged. Note that this is only a logging
facility, not a timeout on operations. See also <code class="docutils literal notranslate"><span class="pre">zpool</span> <span class="pre">events</span></code></p>
<table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="58%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zio_delay_max</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#debug">debug</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>when debugging slow I/O</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>milliseconds</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to INT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>30,000 (30 seconds)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zio-dva-throttle-enabled">
<h3>zio_dva_throttle_enabled<a class="headerlink" href="#zio-dva-throttle-enabled" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zio_dva_throttle_enabled</span></code> controls throttling of block allocations in
the ZFS I/O (ZIO) pipeline. When enabled, the maximum number of pending
allocations per top-level vdev is limited by
<a class="reference external" href="#zfs-vdev-queue-depth-pct">zfs_vdev_queue_depth_pct</a></p>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="62%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zio_dva_throttle_enabled</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a>,
<a class="reference external" href="#zio-scheduler">ZIO_scheduler</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Testing ZIO block allocation algorithms</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=do not throttle ZIO block allocations,
1=throttle ZIO block allocations</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zio-requeue-io-start-cut-in-line">
<h3>zio_requeue_io_start_cut_in_line<a class="headerlink" href="#zio-requeue-io-start-cut-in-line" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zio_requeue_io_start_cut_in_line</span></code> controls prioritization of a
re-queued ZFS I/O (ZIO) in the ZIO pipeline by the ZIO taskq.</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zio_requeue_io_start_cut_in_line</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#zio-scheduler">Z
IO_scheduler</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Do not change</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=don’t prioritize re-queued
I/Os, 1=prioritize re-queued
I/Os</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zio-taskq-batch-pct">
<h3>zio_taskq_batch_pct<a class="headerlink" href="#zio-taskq-batch-pct" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zio_taskq_batch_pct</span></code> sets the number of I/O worker threads as a
percentage of online CPUs. These workers threads are responsible for IO
work such as compression and checksum calculations.</p>
<p>Each block is handled by one worker thread, so maximum overall worker
thread throughput is function of the number of concurrent blocks being
processed, the number of worker threads, and the algorithms used. The
default value of 75% is chosen to avoid using all CPUs which can result
in latency issues and inconsistent application performance, especially
when high compression is enabled.</p>
<p>The taskq batch processes are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="21%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">taskq</th>
<th class="head">process name</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Write issue</td>
<td>z_wr_iss[_#]</td>
<td>Can be CPU intensive, runs at lower
priority than other taskqs</td>
</tr>
</tbody>
</table>
<p>Other taskqs exist, but most have fixed numbers of instances and
therefore require recompiling the kernel module to adjust.</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zio_taskq_batch_pct</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#taskq">taskq</a>,
<a class="reference external" href="#zio-scheduler">ZIO_scheduler</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>To tune parallelism in multiprocessor systems</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>percent of number of CPUs</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to 100, fractional number of CPUs are
rounded down</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>75</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Prior to zfs module load</td>
</tr>
<tr class="row-odd"><td>Verification</td>
<td>The number of taskqs for each batch group can
be observed using <code class="docutils literal notranslate"><span class="pre">ps</span></code> and counting the
threads</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>TBD</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zvol-inhibit-dev">
<h3>zvol_inhibit_dev<a class="headerlink" href="#zvol-inhibit-dev" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zvol_inhibit_dev</span></code> controls the creation of volume device nodes upon
pool import.</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zvol_inhibit_dev</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#import">import</a>, <a class="reference external" href="#volume">volume</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Inhibiting can slightly improve startup time on
systems with a very large number of volumes</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=create volume device nodes, 1=do not create
volume device nodes</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic, takes effect per-pool when the pool is
imported</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.6.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zvol-major">
<h3>zvol_major<a class="headerlink" href="#zvol-major" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zvol_major</span></code> is the default major number for volume devices.</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zvol_major</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#volume">volume</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Do not change</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>230</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic, takes effect per-pool when the pool is
imported or volumes are created</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>all</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zvol-max-discard-blocks">
<h3>zvol_max_discard_blocks<a class="headerlink" href="#zvol-max-discard-blocks" title="Permalink to this headline">¶</a></h3>
<p>Discard (aka ATA TRIM or SCSI UNMAP) operations done on volumes are done
in batches <code class="docutils literal notranslate"><span class="pre">zvol_max_discard_blocks</span></code> blocks. The block size is
determined by the <code class="docutils literal notranslate"><span class="pre">volblocksize</span></code> property of a volume.</p>
<p>Some applications, such as <code class="docutils literal notranslate"><span class="pre">mkfs</span></code>, discard the whole volume at once
using the maximum possible discard size. As a result, many gigabytes of
discard requests are not uncommon. Unfortunately, if a large amount of
data is already allocated in the volume, ZFS can be quite slow to
process discard requests. This is especially true if the volblocksize is
small (eg default=8KB). As a result, very large discard requests can
take a very long time (perhaps minutes under heavy load) to complete.
This can cause a number of problems, most notably if the volume is
accessed remotely (eg via iSCSI), in which case the client has a high
probability of timing out on the request.</p>
<p>Limiting the <code class="docutils literal notranslate"><span class="pre">zvol_max_discard_blocks</span></code> can decrease the amount of
discard workload request by setting the <code class="docutils literal notranslate"><span class="pre">discard_max_bytes</span></code> and
<code class="docutils literal notranslate"><span class="pre">discard_max_hw_bytes</span></code> for the volume’s block device in SysFS. This
value is readable by volume device consumers.</p>
<table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zvol_max_discard_blocks</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#discard">discard</a>,
<a class="reference external" href="#volume">volume</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>if volume discard activity severely
impacts other workloads</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>ulong</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>number of blocks of size volblocksize</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to ULONG_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>16,384</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic, takes effect per-pool when the
pool is imported or volumes are created</td>
</tr>
<tr class="row-odd"><td>Verification</td>
<td>Observe value of
<code class="docutils literal notranslate"><span class="pre">/sys/block/</span>
<span class="pre">VOLUME_INSTANCE/queue/discard_max_bytes</span></code></td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.6.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zvol-prefetch-bytes">
<h3>zvol_prefetch_bytes<a class="headerlink" href="#zvol-prefetch-bytes" title="Permalink to this headline">¶</a></h3>
<p>When importing a pool with volumes or adding a volume to a pool,
<code class="docutils literal notranslate"><span class="pre">zvol_prefetch_bytes</span></code> are prefetch from the start and end of the
volume. Prefetching these regions of the volume is desirable because
they are likely to be accessed immediately by <code class="docutils literal notranslate"><span class="pre">blkid(8)</span></code> or by the
kernel scanning for a partition table.</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zvol_prefetch_bytes</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#prefetch">prefetch</a>, <a class="reference external" href="#volume">volume</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to UINT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>131,072</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.5 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zvol-request-sync">
<h3>zvol_request_sync<a class="headerlink" href="#zvol-request-sync" title="Permalink to this headline">¶</a></h3>
<p>When processing I/O requests for a volume submit them synchronously.
This effectively limits the queue depth to 1 for each I/O submitter.
When set to 0 requests are handled asynchronously by the “zvol” thread
pool.</p>
<p>See also <a class="reference external" href="#zvol-threads">zvol_threads</a></p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zvol_request_sync</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#volume">volume</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Testing concurrent volume requests</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=do concurrent (async) volume requests, 1=do
sync volume requests</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.7.2 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zvol-threads">
<h3>zvol_threads<a class="headerlink" href="#zvol-threads" title="Permalink to this headline">¶</a></h3>
<p>zvol_threads controls the maximum number of threads handling concurrent
volume I/O requests.</p>
<p>The default of 32 threads behaves similarly to a disk with a 32-entry
command queue. The actual number of threads required can vary widely by
workload and available CPUs. If lock analysis shows high contention in
the zvol taskq threads, then reducing the number of zvol_threads or
workload queue depth can improve overall throughput.</p>
<p>See also <a class="reference external" href="#zvol-request-sync">zvol_request_sync</a></p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zvol_threads</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#volume">volume</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Matching the number of concurrent volume
requests with workload requirements can improve
concurrency</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>threads</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to UINT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>32</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic, takes effect per-volume when the pool
is imported or volumes are created</td>
</tr>
<tr class="row-odd"><td>Verification</td>
<td><code class="docutils literal notranslate"><span class="pre">iostat</span></code> using <code class="docutils literal notranslate"><span class="pre">avgqu-sz</span></code> or <code class="docutils literal notranslate"><span class="pre">aqu-sz</span></code>
results</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zvol-volmode">
<h3>zvol_volmode<a class="headerlink" href="#zvol-volmode" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zvol_volmode</span></code> defines volume block devices behaviour when the
<code class="docutils literal notranslate"><span class="pre">volmode</span></code> property is set to <code class="docutils literal notranslate"><span class="pre">default</span></code></p>
<p>Note: to maintain compatibility with ZFS on BSD, “geom” is synonymous
with “full”</p>
<table border="1" class="docutils">
<colgroup>
<col width="9%" />
<col width="13%" />
<col width="78%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">value</th>
<th class="head">volmode</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>full</td>
<td>legacy fully functional behaviour (default)</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>dev</td>
<td>hide partitions on volume block devices</td>
</tr>
<tr class="row-even"><td>3</td>
<td>none</td>
<td>not exposing volumes outside ZFS</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="46%" />
<col width="54%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zvol_volmode</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#volume">volume</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>enum</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>1, 2, or 3</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-qat-disable">
<h3>zfs_qat_disable<a class="headerlink" href="#zfs-qat-disable" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_qat_disable</span></code> controls the Intel QuickAssist Technology (QAT)
driver providing hardware acceleration for gzip compression. When the
QAT hardware is present and qat driver available, the default behaviour
is to enable QAT.</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_qat_disable</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#compression">compression</a>, <a class="reference external" href="#qat">QAT</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Testing QAT functionality</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=use QAT acceleration if available, 1=do not
use QAT acceleration</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.7, renamed to
<a class="reference external" href="#zfs-qat-compress-disable">zfs_qat_
compress_disable</a>
in v0.8</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-qat-checksum-disable">
<h3>zfs_qat_checksum_disable<a class="headerlink" href="#zfs-qat-checksum-disable" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_qat_checksum_disable</span></code> controls the Intel QuickAssist Technology
(QAT) driver providing hardware acceleration for checksums. When the QAT
hardware is present and qat driver available, the default behaviour is
to enable QAT.</p>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="62%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_qat_checksum_disable</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#checksum">checksum</a>, <a class="reference external" href="#qat">QAT</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Testing QAT functionality</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=use QAT acceleration if available,
1=do not use QAT acceleration</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.8.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-qat-compress-disable">
<h3>zfs_qat_compress_disable<a class="headerlink" href="#zfs-qat-compress-disable" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_qat_compress_disable</span></code> controls the Intel QuickAssist Technology
(QAT) driver providing hardware acceleration for gzip compression. When
the QAT hardware is present and qat driver available, the default
behaviour is to enable QAT.</p>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="62%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_qat_compress_disable</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#compression">compression</a>,
<a class="reference external" href="#qat">QAT</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Testing QAT functionality</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=use QAT acceleration if available,
1=do not use QAT acceleration</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.8.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-qat-encrypt-disable">
<h3>zfs_qat_encrypt_disable<a class="headerlink" href="#zfs-qat-encrypt-disable" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_qat_encrypt_disable</span></code> controls the Intel QuickAssist Technology
(QAT) driver providing hardware acceleration for encryption. When the
QAT hardware is present and qat driver available, the default behaviour
is to enable QAT.</p>
<table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_qat_encrypt_disable</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#encryption">encryption</a>,
<a class="reference external" href="#qat">QAT</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Testing QAT functionality</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=use QAT acceleration if available, 1=do
not use QAT acceleration</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.8.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="dbuf-cache-hiwater-pct">
<h3>dbuf_cache_hiwater_pct<a class="headerlink" href="#dbuf-cache-hiwater-pct" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">dbuf_cache_hiwater_pct</span></code> and
<a class="reference external" href="#dbuf-cache-lowater-pct">dbuf_cache_lowater_pct</a> define the
operating range for dbuf cache evict thread. The hiwater and lowater are
percentages of the <a class="reference external" href="#dbuf-cache-max-bytes">dbuf_cache_max_bytes</a>
value. When the dbuf cache grows above ((100% +
<code class="docutils literal notranslate"><span class="pre">dbuf_cache_hiwater_pct</span></code>) *
<a class="reference external" href="#dbuf-cache-max-bytes">dbuf_cache_max_bytes</a>) then the dbuf cache
thread begins evicting. When the dbug cache falls below ((100% -
<a class="reference external" href="#dbuf-cache-lowater-pct">dbuf_cache_lowater_pct</a>) *
<a class="reference external" href="#dbuf-cache-max-bytes">dbuf_cache_max_bytes</a>) then the dbuf cache
thread stops evicting.</p>
<table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">dbuf_cache_hiwater_pct</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#dbuf-cache">dbuf_cache</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Testing dbuf cache algorithms</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>percent</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to UINT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>10</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="dbuf-cache-lowater-pct">
<h3>dbuf_cache_lowater_pct<a class="headerlink" href="#dbuf-cache-lowater-pct" title="Permalink to this headline">¶</a></h3>
<p>The dbuf_cache_hiwater_pct and dbuf_cache_lowater_pct define the
operating range for dbuf cache evict thread. The hiwater and lowater are
percentages of the <a class="reference external" href="#dbuf-cache-max-bytes">dbuf_cache_max_bytes</a>
value. When the dbuf cache grows above ((100% +
<a class="reference external" href="#dbuf-cache-hiwater-pct">dbuf_cache_hiwater_pct</a>) *
<a class="reference external" href="#dbuf-cache-max-bytes">dbuf_cache_max_bytes</a>) then the dbuf cache
thread begins evicting. When the dbug cache falls below ((100% -
<code class="docutils literal notranslate"><span class="pre">dbuf_cache_lowater_pct</span></code>) *
<a class="reference external" href="#dbuf-cache-max-bytes">dbuf_cache_max_bytes</a>) then the dbuf cache
thread stops evicting.</p>
<table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">dbuf_cache_lowater_pct</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#dbuf-cache">dbuf_cache</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Testing dbuf cache algorithms</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>percent</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to UINT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>10</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="dbuf-cache-max-bytes">
<h3>dbuf_cache_max_bytes<a class="headerlink" href="#dbuf-cache-max-bytes" title="Permalink to this headline">¶</a></h3>
<p>The dbuf cache maintains a list of dbufs that are not currently held but
have been recently released. These dbufs are not eligible for ARC
eviction until they are aged out of the dbuf cache. Dbufs are added to
the dbuf cache once the last hold is released. If a dbuf is later
accessed and still exists in the dbuf cache, then it will be removed
from the cache and later re-added to the head of the cache. Dbufs that
are aged out of the cache will be immediately destroyed and become
eligible for ARC eviction.</p>
<p>The size of the dbuf cache is set by <code class="docutils literal notranslate"><span class="pre">dbuf_cache_max_bytes</span></code>. The
actual size is dynamically adjusted to the minimum of current ARC target
size (<code class="docutils literal notranslate"><span class="pre">c</span></code>) &gt;&gt; <a class="reference external" href="#dbuf-cache-max-shift">dbuf_cache_max_shift</a> and the
default <code class="docutils literal notranslate"><span class="pre">dbuf_cache_max_bytes</span></code></p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">dbuf_cache_max_bytes</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#dbuf-cache">dbuf_cache</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Testing dbuf cache algorithms</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>ulong</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>16,777,216 to ULONG_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>104,857,600 (100 MiB)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="dbuf-cache-max-shift">
<h3>dbuf_cache_max_shift<a class="headerlink" href="#dbuf-cache-max-shift" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference external" href="#dbuf-cache-max-bytes">dbuf_cache_max_bytes</a> minimum is the
lesser of <a class="reference external" href="#dbuf-cache-max-bytes">dbuf_cache_max_bytes</a> and the
current ARC target size (<code class="docutils literal notranslate"><span class="pre">c</span></code>) &gt;&gt; <code class="docutils literal notranslate"><span class="pre">dbuf_cache_max_shift</span></code></p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">dbuf_cache_max_shift</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#dbuf-cache">dbuf_cache</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Testing dbuf cache algorithms</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>shift</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to 63</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>5</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="dmu-object-alloc-chunk-shift">
<h3>dmu_object_alloc_chunk_shift<a class="headerlink" href="#dmu-object-alloc-chunk-shift" title="Permalink to this headline">¶</a></h3>
<p>Each of the concurrent object allocators grabs
<code class="docutils literal notranslate"><span class="pre">2^dmu_object_alloc_chunk_shift</span></code> dnode slots at a time. The default is
to grab 128 slots, or 4 blocks worth. This default value was
experimentally determined to be the lowest value that eliminates the
measurable effect of lock contention in the DMU object allocation code
path.</p>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">dmu_object_alloc_chunk_shift</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#allocation">allocation</a>,
<a class="reference external" href="#dmu">DMU</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>If the workload creates many files
concurrently on a system with many
CPUs, then increasing
<code class="docutils literal notranslate"><span class="pre">dmu_object_alloc_chunk_shift</span></code> can
decrease lock contention</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>shift</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>7 to 9</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>7</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="send-holes-without-birth-time">
<h3>send_holes_without_birth_time<a class="headerlink" href="#send-holes-without-birth-time" title="Permalink to this headline">¶</a></h3>
<p>Alias for <a class="reference external" href="#ignore-hole-birth">ignore_hole_birth</a></p>
</div>
<div class="section" id="zfs-abd-scatter-enabled">
<h3>zfs_abd_scatter_enabled<a class="headerlink" href="#zfs-abd-scatter-enabled" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_abd_scatter_enabled</span></code> controls the ARC Buffer Data (ABD)
scatter/gather feature.</p>
<p>When disabled, the legacy behaviour is selected using linear buffers.
For linear buffers, all the data in the ABD is stored in one contiguous
buffer in memory (from a <code class="docutils literal notranslate"><span class="pre">zio_[data_]buf_*</span></code> kmem cache).</p>
<p>When enabled (default), the data in the ABD is split into equal-sized
chunks (from the <code class="docutils literal notranslate"><span class="pre">abd_chunk_cache</span></code> kmem_cache), with pointers to the
chunks recorded in an array at the end of the ABD structure. This allows
more efficient memory allocation for buffers, especially when large
recordsizes are used.</p>
<table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_abd_scatter_enabled</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#abd">ABD</a>, <a class="reference external" href="#memory">memory</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Testing ABD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=use linear allocation only, 1=allow
scatter/gather</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Verification</td>
<td>ABD statistics are observable in
<code class="docutils literal notranslate"><span class="pre">/proc/spl/kstat/zfs/abdstats</span></code>. Slab
allocations are observable in
<code class="docutils literal notranslate"><span class="pre">/proc/slabinfo</span></code></td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-abd-scatter-max-order">
<h3>zfs_abd_scatter_max_order<a class="headerlink" href="#zfs-abd-scatter-max-order" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_abd_scatter_max_order</span></code> sets the maximum order for physical page
allocation when ABD is enabled (see
<a class="reference external" href="#zfs-abd-scatter-enabled">zfs_abd_scatter_enabled</a>)</p>
<p>See also Buddy Memory Allocation in the Linux kernel documentation.</p>
<table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_abd_scatter_max_order</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#abd">ABD</a>, <a class="reference external" href="#memory">memory</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Testing ABD features</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>orders</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to 10 (upper limit is
hardware-dependent)</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>10</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Verification</td>
<td>ABD statistics are observable in
<code class="docutils literal notranslate"><span class="pre">/proc/spl/kstat/zfs/abdstats</span></code></td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-compressed-arc-enabled">
<h3>zfs_compressed_arc_enabled<a class="headerlink" href="#zfs-compressed-arc-enabled" title="Permalink to this headline">¶</a></h3>
<p>When compression is enabled for a dataset, later reads of the data can
store the blocks in ARC in their on-disk, compressed state. This can
increse the effective size of the ARC, as counted in blocks, and thus
improve the ARC hit ratio.</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_compressed_arc_enabled</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#abd">ABD</a>,
<a class="reference external" href="#compression">compression</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Testing ARC compression feature</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=compressed ARC disabled (legacy
behaviour), 1=compress ARC data</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Verification</td>
<td>raw ARC statistics are observable in
<code class="docutils literal notranslate"><span class="pre">/proc/spl/kstat/zfs/arcstats</span></code> and
ARC hit ratios can be observed using
<code class="docutils literal notranslate"><span class="pre">arcstat</span></code></td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-key-max-salt-uses">
<h3>zfs_key_max_salt_uses<a class="headerlink" href="#zfs-key-max-salt-uses" title="Permalink to this headline">¶</a></h3>
<p>For encrypted datasets, the salt is regenerated every
<code class="docutils literal notranslate"><span class="pre">zfs_key_max_salt_uses</span></code> blocks. This automatic regeneration reduces
the probability of collisions due to the Birthday problem. When set to
the default (400,000,000) the probability of collision is approximately
1 in 1 trillion.</p>
<table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_key_max_salt_uses</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#encryption">encryption</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Testing encryption features</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>ulong</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>blocks encrypted</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to ULONG_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>400,000,000</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.8.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-object-mutex-size">
<h3>zfs_object_mutex_size<a class="headerlink" href="#zfs-object-mutex-size" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_object_mutex_size</span></code> facilitates resizing the the per-dataset znode
mutex array for testing deadlocks therein.</p>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_object_mutex_size</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#debug">debug</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Testing znode mutex array deadlocks</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>orders</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to UINT_MAX</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>64</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.0 and later</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-scan-strict-mem-lim">
<h3>zfs_scan_strict_mem_lim<a class="headerlink" href="#zfs-scan-strict-mem-lim" title="Permalink to this headline">¶</a></h3>
<p>When scrubbing or resilvering, by default, ZFS checks to ensure it is
not over the hard memory limit before each txg commit. If finer-grained
control of this is needed <code class="docutils literal notranslate"><span class="pre">zfs_scan_strict_mem_lim</span></code> can be set to 1 to
enable checking before scanning each block.</p>
<table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_scan_strict_mem_lim</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#memory">memory</a>,
<a class="reference external" href="#resilver">resilver</a>,
<a class="reference external" href="#scrub">scrub</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>Do not change</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=normal scan behaviour, 1=check hard
memory limit strictly during scan</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.8.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-send-queue-length">
<h3>zfs_send_queue_length<a class="headerlink" href="#zfs-send-queue-length" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_send_queue_length</span></code> is the maximum number of bytes allowed in the
zfs send queue.</p>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_send_queue_length</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#send">send</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>When using the largest recordsize or
volblocksize (16 MiB), increasing can
improve send efficiency</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>Must be at least twice the maximum
recordsize or volblocksize in use</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>16,777,216 bytes (16 MiB)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.8.1</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-recv-queue-length">
<h3>zfs_recv_queue_length<a class="headerlink" href="#zfs-recv-queue-length" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_recv_queue_length</span></code> is the maximum number of bytes allowed in the
zfs receive queue.</p>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_recv_queue_length</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#receive">receive</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>When using the largest recordsize or
volblocksize (16 MiB), increasing can
improve receive efficiency</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>Must be at least twice the maximum
recordsize or volblocksize in use</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>16,777,216 bytes (16 MiB)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.8.1</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-arc-min-prefetch-lifespan">
<h3>zfs_arc_min_prefetch_lifespan<a class="headerlink" href="#zfs-arc-min-prefetch-lifespan" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">arc_min_prefetch_lifespan</span></code> is the minimum time for a prefetched block
to remain in ARC before it is eligible for eviction.</p>
<table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_arc_min_prefetch_lifespan</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#ARC">ARC</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>clock ticks</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 = use default value</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>1 second (as expressed in clock ticks)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-scan-ignore-errors">
<h3>zfs_scan_ignore_errors<a class="headerlink" href="#zfs-scan-ignore-errors" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_scan_ignore_errors</span></code> allows errors discovered during scrub or
resilver to be ignored. This can be tuned as a workaround to remove the
dirty time list (DTL) when completing a pool scan. It is intended to be
used during pool repair or recovery to prevent resilvering when the pool
is imported.</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_scan_ignore_errors</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#resilver">resilver</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>See description above</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0 = do not ignore errors, 1 = ignore
errors during pool scrub or resilver</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.8.1</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-top-maxinflight">
<h3>zfs_top_maxinflight<a class="headerlink" href="#zfs-top-maxinflight" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_top_maxinflight</span></code> is used to limit the maximum number of I/Os
queued to top-level vdevs during scrub or resilver operations. The
actual top-level vdev limit is calculated by multiplying the number of
child vdevs by <code class="docutils literal notranslate"><span class="pre">zfs_top_maxinflight</span></code> This limit is an additional cap
over and above the scan limits</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_top_maxinflight</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#resilver">resilver</a>, <a class="reference external" href="#scrub">scrub</a>,
<a class="reference external" href="#zio-scheduler">ZIO_scheduler</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>for modern ZFS versions, the ZIO scheduler
limits usually take precedence</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>I/O operations</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to MAX_INT</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>32</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-resilver-delay">
<h3>zfs_resilver_delay<a class="headerlink" href="#zfs-resilver-delay" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_resilver_delay</span></code> sets a time-based delay for resilver I/Os. This
delay is in addition to the ZIO scheduler’s treatement of scrub
workloads. See also <a class="reference external" href="#zfs-scan-idle">zfs_scan_idle</a></p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_resilver_delay</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#resilver">resilver</a>,
<a class="reference external" href="#zio-scheduler">ZIO_scheduler</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>increasing can reduce impact of resilver
workload on dynamic workloads</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>clock ticks</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to MAX_INT</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>2</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-scrub-delay">
<h3>zfs_scrub_delay<a class="headerlink" href="#zfs-scrub-delay" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_scrub_delay</span></code> sets a time-based delay for scrub I/Os. This delay
is in addition to the ZIO scheduler’s treatment of scrub workloads. See
also <a class="reference external" href="#zfs-scan-idle">zfs_scan_idle</a></p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_scrub_delay</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#scrub">scrub</a>,
<a class="reference external" href="#zio-scheduler">ZIO_scheduler</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>increasing can reduce impact of scrub workload
on dynamic workloads</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>clock ticks</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to MAX_INT</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>4</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-scan-idle">
<h3>zfs_scan_idle<a class="headerlink" href="#zfs-scan-idle" title="Permalink to this headline">¶</a></h3>
<p>When a non-scan I/O has occurred in the past <code class="docutils literal notranslate"><span class="pre">zfs_scan_idle</span></code> clock
ticks, then <a class="reference external" href="#zfs-resilver-delay">zfs_resilver_delay</a> or
<a class="reference external" href="#zfs-scrub-delay">zfs_scrub_delay</a> are enabled.</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_scan_idle</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#resilver">resilver</a>, <a class="reference external" href="#scrub">scrub</a>,
<a class="reference external" href="#zio-scheduler">ZIO_scheduler</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>as part of a resilver/scrub tuning effort</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>clock ticks</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to MAX_INT</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>50</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="icp-aes-impl">
<h3>icp_aes_impl<a class="headerlink" href="#icp-aes-impl" title="Permalink to this headline">¶</a></h3>
<p>By default, ZFS will choose the highest performance, hardware-optimized
implementation of the AES encryption algorithm. The <code class="docutils literal notranslate"><span class="pre">icp_aes_impl</span></code>
tunable overrides this automatic choice.</p>
<p>Note: <code class="docutils literal notranslate"><span class="pre">icp_aes_impl</span></code> is set in the <code class="docutils literal notranslate"><span class="pre">icp</span></code> kernel module, not the
<code class="docutils literal notranslate"><span class="pre">zfs</span></code> kernel module.</p>
<p>To observe the available options
<code class="docutils literal notranslate"><span class="pre">cat</span> <span class="pre">/sys/module/icp/parameters/icp_aes_impl</span></code> The default option is
shown in brackets ‘[]’</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">icp_aes_impl</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#encryption">encryption</a></td>
</tr>
<tr class="row-odd"><td>Kernel module</td>
<td>icp</td>
</tr>
<tr class="row-even"><td>When to change</td>
<td>debugging ZFS encryption on hardware</td>
</tr>
<tr class="row-odd"><td>Data Type</td>
<td>string</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>varies by hardware</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>automatic, depends on the hardware</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="icp-gcm-impl">
<h3>icp_gcm_impl<a class="headerlink" href="#icp-gcm-impl" title="Permalink to this headline">¶</a></h3>
<p>By default, ZFS will choose the highest performance, hardware-optimized
implementation of the GCM encryption algorithm. The <code class="docutils literal notranslate"><span class="pre">icp_gcm_impl</span></code>
tunable overrides this automatic choice.</p>
<p>Note: <code class="docutils literal notranslate"><span class="pre">icp_gcm_impl</span></code> is set in the <code class="docutils literal notranslate"><span class="pre">icp</span></code> kernel module, not the
<code class="docutils literal notranslate"><span class="pre">zfs</span></code> kernel module.</p>
<p>To observe the available options
<code class="docutils literal notranslate"><span class="pre">cat</span> <span class="pre">/sys/module/icp/parameters/icp_gcm_impl</span></code> The default option is
shown in brackets ‘[]’</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">icp_gcm_impl</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#encryption">encryption</a></td>
</tr>
<tr class="row-odd"><td>Kernel module</td>
<td>icp</td>
</tr>
<tr class="row-even"><td>When to change</td>
<td>debugging ZFS encryption on hardware</td>
</tr>
<tr class="row-odd"><td>Data Type</td>
<td>string</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>varies by hardware</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>automatic, depends on the hardware</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-abd-scatter-min-size">
<h3>zfs_abd_scatter_min_size<a class="headerlink" href="#zfs-abd-scatter-min-size" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_abd_scatter_min_size</span></code> changes the ARC buffer data (ABD)
allocator’s threshold for using linear or page-based scatter buffers.
Allocations smaller than <code class="docutils literal notranslate"><span class="pre">zfs_abd_scatter_min_size</span></code> use linear ABDs.</p>
<p>Scatter ABD’s use at least one page each, so sub-page allocations waste
some space when allocated as scatter allocations. For example, 2KB
scatter allocation wastes half of each page. Using linear ABD’s for
small allocations results in slabs containing many allocations. This can
improve memory efficiency, at the expense of more work for ARC evictions
attempting to free pages, because all the buffers on one slab need to be
freed in order to free the slab and its underlying pages.</p>
<p>Typically, 512B and 1KB kmem caches have 16 buffers per slab, so it’s
possible for them to actually waste more memory than scatter
allocations:</p>
<ul class="simple">
<li>one page per buf = wasting 3/4 or 7/8</li>
<li>one buf per slab = wasting 15/16</li>
</ul>
<p>Spill blocks are typically 512B and are heavily used on systems running
<em>selinux</em> with the default dnode size and the <code class="docutils literal notranslate"><span class="pre">xattr=sa</span></code> property set.</p>
<p>By default, linear allocations for 512B and 1KB, and scatter allocations
for larger (&gt;= 1.5KB) allocation requests.</p>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="62%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_abd_scatter_min_size</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#ARC">ARC</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>debugging memory allocation, especially
for large pages</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to MAX_INT</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>1536 (512B and 1KB allocations will be
linear)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-unlink-suspend-progress">
<h3>zfs_unlink_suspend_progress<a class="headerlink" href="#zfs-unlink-suspend-progress" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_unlink_suspend_progress</span></code> changes the policy for removing pending
unlinks. When enabled, files will not be asynchronously removed from the
list of pending unlinks and the space they consume will be leaked. Once
this option has been disabled and the dataset is remounted, the pending
unlinks will be processed and the freed space returned to the pool.</p>
<table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_unlink_suspend_progress</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>used by the ZFS test suite (ZTS) to
facilitate testing</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0 = use async unlink removal, 1 = do
not async unlink thus leaking space</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>prior to dataset mount</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="spa-load-verify-shift">
<h3>spa_load_verify_shift<a class="headerlink" href="#spa-load-verify-shift" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">spa_load_verify_shift</span></code> sets the fraction of ARC that can be used by
inflight I/Os when verifying the pool during import. This value is a
“shift” representing the fraction of ARC target size
(<code class="docutils literal notranslate"><span class="pre">grep</span> <span class="pre">-w</span> <span class="pre">c</span> <span class="pre">/proc/spl/kstat/zfs/arcstats</span></code>). The ARC target size is
shifted to the right. Thus a value of ‘2’ results in the fraction = 1/4,
while a value of ‘4’ results in the fraction = 1/8.</p>
<p>For large memory machines, pool import can consume large amounts of ARC:
much larger than the value of maxinflight. This can result in
<a class="reference external" href="#spa-load-verify-maxinflight">spa_load_verify_maxinflight</a> having a
value of 0 causing the system to hang. Setting <code class="docutils literal notranslate"><span class="pre">spa_load_verify_shift</span></code>
can reduce this limit and allow importing without hanging.</p>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">spa_load_verify_shift</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#import">import</a>, <a class="reference external" href="#ARC">ARC</a>,
<a class="reference external" href="#SPA">SPA</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>troubleshooting pool import on large memory
machines</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>shift</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to MAX_INT</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>4</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>prior to importing a pool</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="spa-load-print-vdev-tree">
<h3>spa_load_print_vdev_tree<a class="headerlink" href="#spa-load-print-vdev-tree" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">spa_load_print_vdev_tree</span></code> enables printing of the attempted pool
import’s vdev tree to kernel message to the ZFS debug message log
<code class="docutils literal notranslate"><span class="pre">/proc/spl/kstat/zfs/dbgmsg</span></code> Both the provided vdev tree and MOS vdev
tree are printed, which can be useful for debugging problems with the
zpool <code class="docutils literal notranslate"><span class="pre">cachefile</span></code></p>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="62%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">spa_load_print_vdev_tree</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#import">import</a>, <a class="reference external" href="#SPA">SPA</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>troubleshooting pool import failures</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0 = do not print pool configuration in
logs, 1 = print pool configuration in
logs</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>prior to pool import</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-max-missing-tvds">
<h3>zfs_max_missing_tvds<a class="headerlink" href="#zfs-max-missing-tvds" title="Permalink to this headline">¶</a></h3>
<p>When importing a pool in readonly mode
(<code class="docutils literal notranslate"><span class="pre">zpool</span> <span class="pre">import</span> <span class="pre">-o</span> <span class="pre">readonly=on</span> <span class="pre">...</span></code>) then up to
<code class="docutils literal notranslate"><span class="pre">zfs_max_missing_tvds</span></code> top-level vdevs can be missing, but the import
can attempt to progress.</p>
<p>Note: This is strictly intended for advanced pool recovery cases since
missing data is almost inevitable. Pools with missing devices can only
be imported read-only for safety reasons, and the pool’s <code class="docutils literal notranslate"><span class="pre">failmode</span></code>
property is automatically set to <code class="docutils literal notranslate"><span class="pre">continue</span></code></p>
<p>The expected use case is to recover pool data immediately after
accidentally adding a non-protected vdev to a protected pool.</p>
<ul class="simple">
<li>With 1 missing top-level vdev, ZFS should be able to import the pool
and mount all datasets. User data that was not modified after the
missing device has been added should be recoverable. Thus snapshots
created prior to the addition of that device should be completely
intact.</li>
<li>With 2 missing top-level vdevs, some datasets may fail to mount since
there are dataset statistics that are stored as regular metadata.
Some data might be recoverable if those vdevs were added recently.</li>
<li>With 3 or more top-level missing vdevs, the pool is severely damaged
and MOS entries may be missing entirely. Chances of data recovery are
very low. Note that there are also risks of performing an inadvertent
rewind as we might be missing all the vdevs with the latest
uberblocks.</li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_max_missing_tvds</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#import">import</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>troubleshooting pools with missing devices</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>missing top-level vdevs</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to MAX_INT</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>prior to pool import</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="dbuf-metadata-cache-shift">
<h3>dbuf_metadata_cache_shift<a class="headerlink" href="#dbuf-metadata-cache-shift" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">dbuf_metadata_cache_shift</span></code> sets the size of the dbuf metadata cache
as a fraction of ARC target size. This is an alternate method for
setting dbuf metadata cache size than
<a class="reference external" href="#dbuf-metadata-cache-max-bytes">dbuf_metadata_cache_max_bytes</a>.</p>
<p><a class="reference external" href="#dbuf-metadata-cache-max-bytes">dbuf_metadata_cache_max_bytes</a>
overrides <code class="docutils literal notranslate"><span class="pre">dbuf_metadata_cache_shift</span></code></p>
<p>This value is a “shift” representing the fraction of ARC target size
(<code class="docutils literal notranslate"><span class="pre">grep</span> <span class="pre">-w</span> <span class="pre">c</span> <span class="pre">/proc/spl/kstat/zfs/arcstats</span></code>). The ARC target size is
shifted to the right. Thus a value of ‘2’ results in the fraction = 1/4,
while a value of ‘6’ results in the fraction = 1/64.</p>
<table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">dbuf_metadata_cache_shift</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#ARC">ARC</a>,
<a class="reference external" href="#dbuf-cache">dbuf_cache</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>shift</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>practical range is
(`
dbuf_cache_shift &lt;#dbuf-cache-shift&gt;`__
+ 1) to MAX_INT</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>6</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="dbuf-metadata-cache-max-bytes">
<h3>dbuf_metadata_cache_max_bytes<a class="headerlink" href="#dbuf-metadata-cache-max-bytes" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">dbuf_metadata_cache_max_bytes</span></code> sets the size of the dbuf metadata
cache as a number of bytes. This is an alternate method for setting dbuf
metadata cache size than
<a class="reference external" href="#dbuf-metadata-cache-shift">dbuf_metadata_cache_shift</a></p>
<p><a class="reference external" href="#dbuf-metadata-cache-max-bytes">dbuf_metadata_cache_max_bytes</a>
overrides <code class="docutils literal notranslate"><span class="pre">dbuf_metadata_cache_shift</span></code></p>
<table border="1" class="docutils">
<colgroup>
<col width="46%" />
<col width="54%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">dbuf_metadata_cache_max_bytes</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#dbuf-cache">dbuf_cache</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 = use
<a class="reference external" href="#dbuf-metadata-cache-shift">dbuf_metadata_cache_sh
ift</a>
to ARC <code class="docutils literal notranslate"><span class="pre">c_max</span></code></td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="dbuf-cache-shift">
<h3>dbuf_cache_shift<a class="headerlink" href="#dbuf-cache-shift" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">dbuf_cache_shift</span></code> sets the size of the dbuf cache as a fraction of
ARC target size. This is an alternate method for setting dbuf cache size
than <a class="reference external" href="#dbuf-cache-max-bytes">dbuf_cache_max_bytes</a>.</p>
<p><a class="reference external" href="#dbuf-cache-max-bytes">dbuf_cache_max_bytes</a> overrides
<code class="docutils literal notranslate"><span class="pre">dbuf_cache_shift</span></code></p>
<p>This value is a “shift” representing the fraction of ARC target size
(<code class="docutils literal notranslate"><span class="pre">grep</span> <span class="pre">-w</span> <span class="pre">c</span> <span class="pre">/proc/spl/kstat/zfs/arcstats</span></code>). The ARC target size is
shifted to the right. Thus a value of ‘2’ results in the fraction = 1/4,
while a value of ‘5’ results in the fraction = 1/32.</p>
<p>Performance tuning of dbuf cache can be monitored using:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">dbufstat</span></code> command</li>
<li><a class="reference external" href="https://github.com/prometheus/node_exporter">node_exporter</a> ZFS
module for prometheus environments</li>
<li><a class="reference external" href="https://github.com/influxdata/telegraf">telegraf</a> ZFS plugin for
general-purpose metric collection</li>
<li><code class="docutils literal notranslate"><span class="pre">/proc/spl/kstat/zfs/dbufstats</span></code> kstat</li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">dbuf_cache_shift</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#ARC">ARC</a>, <a class="reference external" href="#dbuf-cache">dbuf_cache</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>to improve performance of read-intensive
channel programs</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>shift</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>5 to MAX_INT</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>5</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="dbuf-cache-max-bytes-1">
<span id="id1"></span><h3>dbuf_cache_max_bytes<a class="headerlink" href="#dbuf-cache-max-bytes-1" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">dbuf_cache_max_bytes</span></code> sets the size of the dbuf cache in bytes. This
is an alternate method for setting dbuf cache size than
<a class="reference external" href="#dbuf-cache-shift">dbuf_cache_shift</a></p>
<p>Performance tuning of dbuf cache can be monitored using:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">dbufstat</span></code> command</li>
<li><a class="reference external" href="https://github.com/prometheus/node_exporter">node_exporter</a> ZFS
module for prometheus environments</li>
<li><a class="reference external" href="https://github.com/influxdata/telegraf">telegraf</a> ZFS plugin for
general-purpose metric collection</li>
<li><code class="docutils literal notranslate"><span class="pre">/proc/spl/kstat/zfs/dbufstats</span></code> kstat</li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">dbuf_cache_max_bytes</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#ARC">ARC</a>, <a class="reference external" href="#dbuf-cache">dbuf_cache</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 = use
<a class="reference external" href="#dbuf-cache-shift">dbuf_cache_shift</a> to
ARC <code class="docutils literal notranslate"><span class="pre">c_max</span></code></td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="metaslab-force-ganging">
<h3>metaslab_force_ganging<a class="headerlink" href="#metaslab-force-ganging" title="Permalink to this headline">¶</a></h3>
<p>When testing allocation code, <code class="docutils literal notranslate"><span class="pre">metaslab_force_ganging</span></code> forces blocks
above the specified size to be ganged.</p>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">metaslab_force_ganging</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#allocation">allocation</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>for development testing purposes only</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>ulong</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>SPA_MINBLOCKSIZE to (SPA_MAXBLOCKSIZE + 1)</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>SPA_MAXBLOCKSIZE + 1 (16,777,217 bytes)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-default-ms-count">
<h3>zfs_vdev_default_ms_count<a class="headerlink" href="#zfs-vdev-default-ms-count" title="Permalink to this headline">¶</a></h3>
<p>When adding a top-level vdev, <code class="docutils literal notranslate"><span class="pre">zfs_vdev_default_ms_count</span></code> is the
target number of metaslabs.</p>
<table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_vdev_default_ms_count</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#allocation">allocation</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>for development testing purposes only</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>16 to MAX_INT</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>200</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>prior to creating a pool or adding a
top-level vdev</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="vdev-removal-max-span">
<h3>vdev_removal_max_span<a class="headerlink" href="#vdev-removal-max-span" title="Permalink to this headline">¶</a></h3>
<p>During top-level vdev removal, chunks of data are copied from the vdev
which may include free space in order to trade bandwidth for IOPS.
<code class="docutils literal notranslate"><span class="pre">vdev_removal_max_span</span></code> sets the maximum span of free space included
as unnecessary data in a chunk of copied data.</p>
<table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">vdev_removal_max_span</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev-removal">vdev_removal</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to MAX_INT</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>32,768 (32 MiB)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-removal-ignore-errors">
<h3>zfs_removal_ignore_errors<a class="headerlink" href="#zfs-removal-ignore-errors" title="Permalink to this headline">¶</a></h3>
<p>When removing a device, <code class="docutils literal notranslate"><span class="pre">zfs_removal_ignore_errors</span></code> controls the
process for handling hard I/O errors. When set, if a device encounters a
hard IO error during the removal process the removal will not be
cancelled. This can result in a normally recoverable block becoming
permanently damaged and is not recommended. This should only be used as
a last resort when the pool cannot be returned to a healthy state prior
to removing the device.</p>
<table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_removal_ignore_errors</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev-removal">vdev_removal</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>See description for caveat</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>during device removal: 0 = hard errors
are not ignored, 1 = hard errors are
ignored</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-removal-suspend-progress">
<h3>zfs_removal_suspend_progress<a class="headerlink" href="#zfs-removal-suspend-progress" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_removal_suspend_progress</span></code> is used during automated testing of the
ZFS code to incease test coverage.</p>
<table border="1" class="docutils">
<colgroup>
<col width="42%" />
<col width="58%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_removal_suspend_progress</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev-removal">vdev_removal</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>do not change</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0 = do not suspend during vdev removal</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-condense-indirect-commit-entry-delay-ms">
<h3>zfs_condense_indirect_commit_entry_delay_ms<a class="headerlink" href="#zfs-condense-indirect-commit-entry-delay-ms" title="Permalink to this headline">¶</a></h3>
<p>During vdev removal, the vdev indirection layer sleeps for
<code class="docutils literal notranslate"><span class="pre">zfs_condense_indirect_commit_entry_delay_ms</span></code> milliseconds during
mapping geenration. This parameter is used during automated testing of
the ZFS code to improve test coverage.</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_condens
e_indirect_commit_entry_delay_ms</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev-removal">vdev_removal</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>do not change</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>milliseconds</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to MAX_INT</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-condense-indirect-vdevs-enable">
<h3>zfs_condense_indirect_vdevs_enable<a class="headerlink" href="#zfs-condense-indirect-vdevs-enable" title="Permalink to this headline">¶</a></h3>
<p>During vdev removal, condensing process is an attempt to save memory by
removing obsolete mappings. <code class="docutils literal notranslate"><span class="pre">zfs_condense_indirect_vdevs_enable</span></code>
enables condensing indirect vdev mappings. When set, ZFS attempts to
condense indirect vdev mappings if the mapping uses more than
<a class="reference external" href="#zfs-condense-min-mapping-bytes">zfs_condense_min_mapping_bytes</a>
bytes of memory and if the obsolete space map object uses more than
<a class="reference external" href="#zfs-condense-max-obsolete-bytes">zfs_condense_max_obsolete_bytes</a>
bytes on disk.</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zf
s_condense_indirect_vdevs_enable</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev-removal">vdev_removal</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0 = do not save memory, 1 = save
memory by condensing obsolete
mapping after vdev removal</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-condense-max-obsolete-bytes">
<h3>zfs_condense_max_obsolete_bytes<a class="headerlink" href="#zfs-condense-max-obsolete-bytes" title="Permalink to this headline">¶</a></h3>
<p>After vdev removal, <code class="docutils literal notranslate"><span class="pre">zfs_condense_max_obsolete_bytes</span></code> sets the limit
for beginning the condensing process. Condensing begins if the obsolete
space map takes up more than <code class="docutils literal notranslate"><span class="pre">zfs_condense_max_obsolete_bytes</span></code> of
space on disk (logically). The default of 1 GiB is small enough relative
to a typical pool that the space consumed by the obsolete space map is
minimal.</p>
<p>See also
<a class="reference external" href="#zfs-condense-indirect-vdevs-enable">zfs_condense_indirect_vdevs_enable</a></p>
<table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_condense_max_obsolete_bytes</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev-removal">vdev_removal</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>no not change</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>ulong</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to MAX_ULONG</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>1,073,741,824 (1 GiB)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-condense-min-mapping-bytes">
<h3>zfs_condense_min_mapping_bytes<a class="headerlink" href="#zfs-condense-min-mapping-bytes" title="Permalink to this headline">¶</a></h3>
<p>After vdev removal, <code class="docutils literal notranslate"><span class="pre">zfs_condense_min_mapping_bytes</span></code> is the lower
limit for determining when to condense the in-memory obsolete space map.
The condensing process will not continue unless a minimum of
<code class="docutils literal notranslate"><span class="pre">zfs_condense_min_mapping_bytes</span></code> of memory can be freed.</p>
<p>See also
<a class="reference external" href="#zfs-condense-indirect-vdevs-enable">zfs_condense_indirect_vdevs_enable</a></p>
<table border="1" class="docutils">
<colgroup>
<col width="48%" />
<col width="52%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_condense_min_mapping_bytes</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev-removal">vdev_removal</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>do not change</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>ulong</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to MAX_ULONG</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>128 KiB</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-initializing-max-active">
<h3>zfs_vdev_initializing_max_active<a class="headerlink" href="#zfs-vdev-initializing-max-active" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_vdev_initializing_max_active</span></code> sets the maximum initializing I/Os
active to each device.</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_vdev_initializing_max_active</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a>,
<a class="reference external" href="#zio-scheduler">Z
IO_scheduler</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>See <a class="reference external" href="https://github.com/zfsonlinux/zfs/wiki/ZIO-Scheduler">ZFS I/O
Sch
eduler</a></td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint32</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>I/O operations</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to
<a class="reference external" href="#zfs-vdev-max-active">zfs_vdev_max_
active</a></td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>1</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-initializing-min-active">
<h3>zfs_vdev_initializing_min_active<a class="headerlink" href="#zfs-vdev-initializing-min-active" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_vdev_initializing_min_active</span></code> sets the minimum initializing I/Os
active to each device.</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_vdev_initializing_min_active</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a>,
<a class="reference external" href="#zio-scheduler">Z
IO_scheduler</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>See <a class="reference external" href="https://github.com/zfsonlinux/zfs/wiki/ZIO-Scheduler">ZFS I/O
Sch
eduler</a></td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint32</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>I/O operations</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to
<a class="reference external" href="#zfs_vdev_initializing_max_active">zfs_vde
v_initializing_max_active</a></td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>1</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-removal-max-active">
<h3>zfs_vdev_removal_max_active<a class="headerlink" href="#zfs-vdev-removal-max-active" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_vdev_removal_max_active</span></code> sets the maximum top-level vdev removal
I/Os active to each device.</p>
<table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_vdev_removal_max_active</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a>,
<a class="reference external" href="#zio-scheduler">ZIO_scheduler</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>See <a class="reference external" href="https://github.com/zfsonlinux/zfs/wiki/ZIO-Scheduler">ZFS I/O
Scheduler</a></td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint32</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>I/O operations</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to
<a class="reference external" href="#zfs-vdev-max-active">zfs_vdev
_max_active</a></td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>2</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-removal-min-active">
<h3>zfs_vdev_removal_min_active<a class="headerlink" href="#zfs-vdev-removal-min-active" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_vdev_removal_min_active</span></code> sets the minimum top-level vdev removal
I/Os active to each device.</p>
<table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_vdev_removal_min_active</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a>,
<a class="reference external" href="#zio-scheduler">ZIO_scheduler</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>See <a class="reference external" href="https://github.com/zfsonlinux/zfs/wiki/ZIO-Scheduler">ZFS I/O
Scheduler</a></td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint32</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>I/O operations</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to
<a class="reference external" href="#zfs-vdev-removal-max-active">zfs_vdev_removal_max_act
ive</a></td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>1</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-trim-max-active">
<h3>zfs_vdev_trim_max_active<a class="headerlink" href="#zfs-vdev-trim-max-active" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_vdev_trim_max_active</span></code> sets the maximum trim I/Os active to each
device.</p>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="62%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_vdev_trim_max_active</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a>,
<a class="reference external" href="#zio-scheduler">ZIO_scheduler</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>See <a class="reference external" href="https://github.com/zfsonlinux/zfs/wiki/ZIO-Scheduler">ZFS I/O
Scheduler</a></td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint32</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>I/O operations</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to
<a class="reference external" href="#zfs-vdev-max-active">zfs_v
dev_max_active</a></td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>2</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-trim-min-active">
<h3>zfs_vdev_trim_min_active<a class="headerlink" href="#zfs-vdev-trim-min-active" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_vdev_trim_min_active</span></code> sets the minimum trim I/Os active to each
device.</p>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="62%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_vdev_trim_min_active</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a>,
<a class="reference external" href="#zio-scheduler">ZIO_scheduler</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>See <a class="reference external" href="https://github.com/zfsonlinux/zfs/wiki/ZIO-Scheduler">ZFS I/O
Scheduler</a></td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint32</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>I/O operations</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to
<a class="reference external" href="#zfs-vdev-trim-max-active">zfs_vdev_trim_m
ax_active</a></td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>1</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-initialize-value">
<h3>zfs_initialize_value<a class="headerlink" href="#zfs-initialize-value" title="Permalink to this headline">¶</a></h3>
<p>When initializing a vdev, ZFS writes patterns of
<code class="docutils literal notranslate"><span class="pre">zfs_initialize_value</span></code> bytes to the device.</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_initialize_value</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev-initialize">vdev_initialize</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>when debugging initialization code</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint32 or uint64</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>0xdeadbeef for 32-bit systems,
0xdeadbeefdeadbeee for 64-bit systems</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>prior to running <code class="docutils literal notranslate"><span class="pre">zpool</span> <span class="pre">initialize</span></code></td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-lua-max-instrlimit">
<h3>zfs_lua_max_instrlimit<a class="headerlink" href="#zfs-lua-max-instrlimit" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_lua_max_instrlimit</span></code> limits the maximum time for a ZFS channel
program to run.</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_lua_max_instrlimit</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#channel-programs">channel_programs</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>to enforce a CPU usage limit on ZFS
channel programs</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>ulong</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>LUA instructions</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to MAX_ULONG</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>100,000,000</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-lua-max-memlimit">
<h3>zfs_lua_max_memlimit<a class="headerlink" href="#zfs-lua-max-memlimit" title="Permalink to this headline">¶</a></h3>
<p>‘zfs_lua_max_memlimit’ is the maximum memory limit for a ZFS channel
program.</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_lua_max_memlimit</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#channel-programs">channel_programs</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>ulong</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to MAX_ULONG</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>104,857,600 (100 MiB)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-max-dataset-nesting">
<h3>zfs_max_dataset_nesting<a class="headerlink" href="#zfs-max-dataset-nesting" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_max_dataset_nesting</span></code> limits the depth of nested datasets. Deeply
nested datasets can overflow the stack. The maximum stack depth depends
on kernel compilation options, so it is impractical to predict the
possible limits. For kernels compiled with small stack sizes,
<code class="docutils literal notranslate"><span class="pre">zfs_max_dataset_nesting</span></code> may require changes.</p>
<table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_max_dataset_nesting</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#dataset">dataset</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>can be tuned temporarily to fix existing
datasets that exceed the predefined limit</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>datasets</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to MAX_INT</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>50</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic, though once on-disk the value
for the pool is set</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-ddt-data-is-special">
<h3>zfs_ddt_data_is_special<a class="headerlink" href="#zfs-ddt-data-is-special" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_ddt_data_is_special</span></code> enables the deduplication table (DDT) to
reside on a special top-level vdev.</p>
<table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_ddt_data_is_special</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#dedup">dedup</a>,
<a class="reference external" href="#special-vdev">special_vdev</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>when using a special top-level vdev and
no dedup top-level vdev and it is desired
to store the DDT in the main pool
top-level vdevs</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=do not use special vdevs to store DDT,
1=store DDT in special vdevs</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-user-indirect-is-special">
<h3>zfs_user_indirect_is_special<a class="headerlink" href="#zfs-user-indirect-is-special" title="Permalink to this headline">¶</a></h3>
<p>If special vdevs are in use, <code class="docutils literal notranslate"><span class="pre">zfs_user_indirect_is_special</span></code> enables
user data indirect blocks (a form of metadata) to be written to the
special vdevs.</p>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_user_indirect_is_special</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#special-vdev">special_vdev</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>to force user data indirect blocks
to remain in the main pool top-level
vdevs</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=do not write user indirect blocks
to a special vdev, 1=write user
indirect blocks to a special vdev</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-reconstruct-indirect-combinations-max">
<h3>zfs_reconstruct_indirect_combinations_max<a class="headerlink" href="#zfs-reconstruct-indirect-combinations-max" title="Permalink to this headline">¶</a></h3>
<p>After device removal, if an indirect split block contains more than
<code class="docutils literal notranslate"><span class="pre">zfs_reconstruct_indirect_combinations_max</span></code> many possible unique
combinations when being reconstructed, it can be considered too
computationally expensive to check them all. Instead, at most
<code class="docutils literal notranslate"><span class="pre">zfs_reconstruct_indirect_combinations_max</span></code> randomly-selected
combinations are attempted each time the block is accessed. This allows
all segment copies to participate fairly in the reconstruction when all
combinations cannot be checked and prevents repeated use of one bad
copy.</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_recon
struct_indirect_combinations_max</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev-removal">vdev_removal</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>attempts</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0=do not limit attempts, 1 to
MAX_INT = limit for attempts</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>4096</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-send-unmodified-spill-blocks">
<h3>zfs_send_unmodified_spill_blocks<a class="headerlink" href="#zfs-send-unmodified-spill-blocks" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_send_unmodified_spill_blocks</span></code> enables sending of unmodified spill
blocks in the send stream. Under certain circumstances, previous
versions of ZFS could incorrectly remove the spill block from an
existing object. Including unmodified copies of the spill blocks creates
a backwards compatible stream which will recreate a spill block if it
was incorrectly removed.</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_send_unmodified_spill_blocks</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#send">send</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=do not send unmodified spill
blocks, 1=send unmodified spill
blocks</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-spa-discard-memory-limit">
<h3>zfs_spa_discard_memory_limit<a class="headerlink" href="#zfs-spa-discard-memory-limit" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_spa_discard_memory_limit</span></code> sets the limit for maximum memory used
for prefetching a pool’s checkpoint space map on each vdev while
discarding a pool checkpoint.</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_spa_discard_memory_limit</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#checkpoint">checkpoint</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to MAX_INT</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>16,777,216 (16 MiB)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-special-class-metadata-reserve-pct">
<h3>zfs_special_class_metadata_reserve_pct<a class="headerlink" href="#zfs-special-class-metadata-reserve-pct" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_special_class_metadata_reserve_pct</span></code> sets a threshold for space in
special vdevs to be reserved exclusively for metadata. This prevents
small blocks or dedup table from completely consuming a special vdev.</p>
<table border="1" class="docutils">
<colgroup>
<col width="54%" />
<col width="46%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_special_class_metadata_reserve_pct</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#special-vdev">special_vdev</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>percent</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to 100</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>25</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-trim-extent-bytes-max">
<h3>zfs_trim_extent_bytes_max<a class="headerlink" href="#zfs-trim-extent-bytes-max" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_trim_extent_bytes_max</span></code> sets the maximum size of a trim (aka
discard, scsi unmap) command. Ranges larger than
<code class="docutils literal notranslate"><span class="pre">zfs_trim_extent_bytes_max</span></code> are split in to chunks no larger than
<code class="docutils literal notranslate"><span class="pre">zfs_trim_extent_bytes_max</span></code> bytes prior to being issued to the device.
Use <code class="docutils literal notranslate"><span class="pre">zpool</span> <span class="pre">iostat</span> <span class="pre">-w</span></code> to observe the latency of trim commands.</p>
<table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_trim_extent_bytes_max</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#trim">trim</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>if the device can efficiently handle
larger trim requests</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td><a class="reference external" href="#zfs-trim-extent-bytes-min">zfs_trim_extent_by
tes_min</a>
to MAX_UINT</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>134,217,728 (128 MiB)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-trim-extent-bytes-min">
<h3>zfs_trim_extent_bytes_min<a class="headerlink" href="#zfs-trim-extent-bytes-min" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_trim_extent_bytes_min</span></code> sets the minimum size of trim (aka
discard, scsi unmap) commands. Trim ranges smaller than
<code class="docutils literal notranslate"><span class="pre">zfs_trim_extent_bytes_min</span></code> are skipped unless they’re part of a
larger range which was broken in to chunks. Some devices have
performance degradation during trim operations, so using a larger
<code class="docutils literal notranslate"><span class="pre">zfs_trim_extent_bytes_min</span></code> can reduce the total amount of space
trimmed. Use <code class="docutils literal notranslate"><span class="pre">zpool</span> <span class="pre">iostat</span> <span class="pre">-w</span></code> to observe the latency of trim
commands.</p>
<table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_trim_extent_bytes_min</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#trim">trim</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>when trim is in use and device
performance suffers from trimming small
allocations</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0=trim all unallocated space, otherwise
minimum physical block size to MAX_</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>32,768 (32 KiB)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-trim-metaslab-skip">
<h3>zfs_trim_metaslab_skip<a class="headerlink" href="#zfs-trim-metaslab-skip" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">zfs_trim_metaslab_skip</span></code> enables uninitialized metaslabs to be
skipped during the trim (aka discard, scsi unmap) process.
<code class="docutils literal notranslate"><span class="pre">zfs_trim_metaslab_skip</span></code> can be useful for pools constructed from
large thinly-provisioned devices where trim operations perform slowly.</div>
<div class="line">As a pool ages an increasing fraction of the pool’s metaslabs are
initialized, progressively degrading the usefulness of this option.
This setting is stored when starting a manual trim and persists for
the duration of the requested trim. Use <code class="docutils literal notranslate"><span class="pre">zpool</span> <span class="pre">iostat</span> <span class="pre">-w</span></code> to observe
the latency of trim commands.</div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_trim_metaslab_skip</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#trim">trim</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=do not skip unitialized metaslabs during
trim, 1=skip unitialized metaslabs during
trim</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-trim-queue-limit">
<h3>zfs_trim_queue_limit<a class="headerlink" href="#zfs-trim-queue-limit" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_trim_queue_limit</span></code> sets the maximum queue depth for leaf vdevs.
See also <a class="reference external" href="#zfs-vdev-trim-max-active">zfs_vdev_trim_max_active</a> and
<a class="reference external" href="#zfs-trim-extent-bytes-max">zfs_trim_extent_bytes_max</a> Use
<code class="docutils literal notranslate"><span class="pre">zpool</span> <span class="pre">iostat</span> <span class="pre">-q</span></code> to observe trim queue depth.</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_trim_queue_limit</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#trim">trim</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>to restrict the number of trim commands in the queue</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>I/O operations</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to MAX_UINT</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>10</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-trim-txg-batch">
<h3>zfs_trim_txg_batch<a class="headerlink" href="#zfs-trim-txg-batch" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_trim_txg_batch</span></code> sets the number of transaction groups worth of
frees which should be aggregated before trim (aka discard, scsi unmap)
commands are issued to a device. This setting represents a trade-off
between issuing larger, more efficient trim commands and the delay
before the recently trimmed space is available for use by the device.</p>
<p>Increasing this value will allow frees to be aggregated for a longer
time. This will result is larger trim operations and potentially
increased memory usage. Decreasing this value will have the opposite
effect. The default value of 32 was empirically determined to be a
reasonable compromise.</p>
<table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_trim_txg_batch</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#trim">trim</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>metaslabs to stride</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to MAX_UINT</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>32</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-aggregate-trim">
<h3>zfs_vdev_aggregate_trim<a class="headerlink" href="#zfs-vdev-aggregate-trim" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_vdev_aggregate_trim</span></code> allows trim I/Os to be aggregated. This is
normally not helpful because the extents to be trimmed will have been
already been aggregated by the metaslab.</p>
<table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_vdev_aggregate_trim</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#trim">trim</a>, <a class="reference external" href="#vdev">vdev</a>,
<a class="reference external" href="#zio-scheduler">ZIO_scheduler</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>when debugging trim code or trim
performance issues</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=do not attempt to aggregate trim
commands, 1=attempt to aggregate trim
commands</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-aggregation-limit-non-rotating">
<h3>zfs_vdev_aggregation_limit_non_rotating<a class="headerlink" href="#zfs-vdev-aggregation-limit-non-rotating" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_vdev_aggregation_limit_non_rotating</span></code> is the equivalent of
<a class="reference external" href="#zfs-vdev-aggregation-limit">zfs_vdev_aggregation_limit</a> for devices
which represent themselves as non-rotating to the Linux blkdev
interfaces. Such devices have a value of 0 in
<code class="docutils literal notranslate"><span class="pre">/sys/block/DEVICE/queue/rotational</span></code> and are expected to be SSDs.</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_vde
v_aggregation_limit_non_rotating</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a>,
<a class="reference external" href="#zio-scheduler">Z
IO_scheduler</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>see
<a class="reference external" href="#zfs-vdev-aggregation-limit">zfs_vdev_aggregation_limit</a></td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to MAX_INT</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>131,072 bytes (128 KiB)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zil-nocacheflush">
<h3>zil_nocacheflush<a class="headerlink" href="#zil-nocacheflush" title="Permalink to this headline">¶</a></h3>
<p>ZFS uses barriers (volatile cache flush commands) to ensure data is
committed to permanent media by devices. This ensures consistent
on-media state for devices where caches are volatile (eg HDDs).</p>
<p><code class="docutils literal notranslate"><span class="pre">zil_nocacheflush</span></code> disables the cache flush commands that are normally
sent to devices by the ZIL after a log write has completed.</p>
<p>The difference between <code class="docutils literal notranslate"><span class="pre">zil_nocacheflush</span></code> and
<a class="reference external" href="#zfs-nocacheflush">zfs_nocacheflush</a> is <code class="docutils literal notranslate"><span class="pre">zil_nocacheflush</span></code> applies
to ZIL writes while <a class="reference external" href="#zfs-nocacheflush">zfs_nocacheflush</a> disables
barrier writes to the pool devices at the end of tranaction group syncs.</p>
<p>WARNING: setting this can cause ZIL corruption on power loss if the
device has a volatile write cache.</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zil_nocacheflush</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#disks">disks</a>, <a class="reference external" href="#ZIL">ZIL</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>If the storage device has nonvolatile cache,
then disabling cache flush can save the cost of
occasional cache flush comamnds</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=send cache flush commands, 1=do not send
cache flush commands</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zio-deadman-log-all">
<h3>zio_deadman_log_all<a class="headerlink" href="#zio-deadman-log-all" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zio_deadman_log_all</span></code> enables debugging messages for all ZFS I/Os,
rather than only for leaf ZFS I/Os for a vdev. This is meant to be used
by developers to gain diagnostic information for hang conditions which
don’t involve a mutex or other locking primitive. Typically these are
conditions where a thread in the zio pipeline is looping indefinitely.</p>
<p>See also <a class="reference external" href="#zfs-dbgmsg-enable">zfs_dbgmsg_enable</a></p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zio_deadman_log_all</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#debug">debug</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>when debugging ZFS I/O pipeline</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=do not log all deadman events, 1=log all
deadman events</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zio-decompress-fail-fraction">
<h3>zio_decompress_fail_fraction<a class="headerlink" href="#zio-decompress-fail-fraction" title="Permalink to this headline">¶</a></h3>
<p>If non-zero, <code class="docutils literal notranslate"><span class="pre">zio_decompress_fail_fraction</span></code> represents the denominator
of the probability that ZFS should induce a decompression failure. For
instance, for a 5% decompression failure rate, this value should be set
to 20.</p>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zio_decompress_fail_fraction</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#debug">debug</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>when debugging ZFS internal
compressed buffer code</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>ulong</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>probability of induced decompression
failure is
1/<code class="docutils literal notranslate"><span class="pre">zio_decompress_fail_fraction</span></code></td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 = do not induce failures, or 1 to
MAX_ULONG</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zio-slow-io-ms">
<h3>zio_slow_io_ms<a class="headerlink" href="#zio-slow-io-ms" title="Permalink to this headline">¶</a></h3>
<p>An I/O operation taking more than <code class="docutils literal notranslate"><span class="pre">zio_slow_io_ms</span></code> milliseconds to
complete is marked as a slow I/O. Slow I/O counters can be observed with
<code class="docutils literal notranslate"><span class="pre">zpool</span> <span class="pre">status</span> <span class="pre">-s</span></code>. Each slow I/O causes a delay zevent, observable
using <code class="docutils literal notranslate"><span class="pre">zpool</span> <span class="pre">events</span></code>. See also <code class="docutils literal notranslate"><span class="pre">zfs-events(5)</span></code>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zio_slow_io_ms</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a>, <a class="reference external" href="#zed">zed</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>when debugging slow devices and the default
value is inappropriate</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>milliseconds</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to MAX_INT</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>30,000 (30 seconds)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="vdev-validate-skip">
<h3>vdev_validate_skip<a class="headerlink" href="#vdev-validate-skip" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">vdev_validate_skip</span></code> disables label validation steps during pool
import. Changing is not recommended unless you know what you are doing
and are recovering a damaged label.</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">vdev_validate_skip</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>do not change</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=validate labels during pool import, 1=do not
validate vdev labels during pool import</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>prior to pool import</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-async-block-max-blocks">
<h3>zfs_async_block_max_blocks<a class="headerlink" href="#zfs-async-block-max-blocks" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_async_block_max_blocks</span></code> limits the number of blocks freed in a
single transaction group commit. During deletes of large objects, such
as snapshots, the number of freed blocks can cause the DMU to extend txg
sync times well beyond <a class="reference external" href="#zfs-txg-timeout">zfs_txg_timeout</a>.
<code class="docutils literal notranslate"><span class="pre">zfs_async_block_max_blocks</span></code> is used to limit these effects.</p>
<table border="1" class="docutils">
<colgroup>
<col width="42%" />
<col width="58%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_async_block_max_blocks</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#delete">delete</a>, <a class="reference external" href="#DMU">DMU</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>ulong</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>blocks</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to MAX_ULONG</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>MAX_ULONG (do not limit)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-checksum-events-per-second">
<h3>zfs_checksum_events_per_second<a class="headerlink" href="#zfs-checksum-events-per-second" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_checksum_events_per_second</span></code> is a rate limit for checksum events.
Note that this should not be set below the <code class="docutils literal notranslate"><span class="pre">zed</span></code> thresholds (currently
10 checksums over 10 sec) or else <code class="docutils literal notranslate"><span class="pre">zed</span></code> may not trigger any action.</p>
<table border="1" class="docutils">
<colgroup>
<col width="51%" />
<col width="49%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_checksum_events_per_second</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>checksum events</td>
</tr>
<tr class="row-even"><td>Range</td>
<td><code class="docutils literal notranslate"><span class="pre">zed</span></code> threshold to MAX_UINT</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>20</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-disable-ivset-guid-check">
<h3>zfs_disable_ivset_guid_check<a class="headerlink" href="#zfs-disable-ivset-guid-check" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_disable_ivset_guid_check</span></code> disables requirement for IVset guids to
be present and match when doing a raw receive of encrypted datasets.
Intended for users whose pools were created with ZFS on Linux
pre-release versions and now have compatibility issues.</p>
<p>For a ZFS raw receive, from a send stream created by <code class="docutils literal notranslate"><span class="pre">zfs</span> <span class="pre">send</span> <span class="pre">--raw</span></code>,
the crypt_keydata nvlist includes a to_ivset_guid to be set on the new
snapshot. This value will override the value generated by the snapshot
code. However, this value may not be present, because older
implementations of the raw send code did not include this value. When
<code class="docutils literal notranslate"><span class="pre">zfs_disable_ivset_guid_check</span></code> is enabled, the receive proceeds and a
newly-generated value is used.</p>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_disable_ivset_guid_check</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#receive">receive</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>debugging pre-release ZFS raw sends</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=check IVset guid, 1=do not check
IVset guid</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-obsolete-min-time-ms">
<h3>zfs_obsolete_min_time_ms<a class="headerlink" href="#zfs-obsolete-min-time-ms" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_obsolete_min_time_ms</span></code> is similar to
<a class="reference external" href="#zfs-free-min-time-ms">zfs_free_min_time_ms</a> and used for cleanup of
old indirection records for vdevs removed using the <code class="docutils literal notranslate"><span class="pre">zpool</span> <span class="pre">remove</span></code>
command.</p>
<table border="1" class="docutils">
<colgroup>
<col width="36%" />
<col width="64%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_obsolete_min_time_ms</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#delete">delete</a>, <a class="reference external" href="#remove">remove</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>milliseconds</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0 to MAX_INT</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>500</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-override-estimate-recordsize">
<h3>zfs_override_estimate_recordsize<a class="headerlink" href="#zfs-override-estimate-recordsize" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_override_estimate_recordsize</span></code> overrides the default logic for
estimating block sizes when doing a zfs send. The default heuristic is
that the average block size will be the current recordsize.</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_override_estimate_recordsize</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#send">send</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>if most data in your dataset is
not of the current recordsize
and you require accurate zfs
send size estimates</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>ulong</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0=do not override, 1 to
MAX_ULONG</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-remove-max-segment">
<h3>zfs_remove_max_segment<a class="headerlink" href="#zfs-remove-max-segment" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_remove_max_segment</span></code> sets the largest contiguous segment that ZFS
attempts to allocate when removing a vdev. This can be no larger than
16MB. If there is a performance problem with attempting to allocate
large blocks, consider decreasing this. The value is rounded up to a
power-of-2.</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_remove_max_segment</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#remove">remove</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>after removing a top-level vdev, consider
decreasing if there is a performance
degradation when attempting to allocate
large blocks</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>maximum of the physical block size of all
vdevs in the pool to 16,777,216 bytes (16
MiB)</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>16,777,216 bytes (16 MiB)</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-resilver-disable-defer">
<h3>zfs_resilver_disable_defer<a class="headerlink" href="#zfs-resilver-disable-defer" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_resilver_disable_defer</span></code> disables the <code class="docutils literal notranslate"><span class="pre">resilver_defer</span></code> pool
feature. The <code class="docutils literal notranslate"><span class="pre">resilver_defer</span></code> feature allows ZFS to postpone new
resilvers if an existing resilver is in progress.</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_resilver_disable_defer</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#resilver">resilver</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>if resilver postponement is not
desired due to overall resilver time
constraints</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=allow <code class="docutils literal notranslate"><span class="pre">resilver_defer</span></code> to postpone
new resilver operations, 1=immediately
restart resilver when needed</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-scan-suspend-progress">
<h3>zfs_scan_suspend_progress<a class="headerlink" href="#zfs-scan-suspend-progress" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_scan_suspend_progress</span></code> causes a scrub or resilver scan to freeze
without actually pausing.</p>
<table border="1" class="docutils">
<colgroup>
<col width="36%" />
<col width="64%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_scan_suspend_progress</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#resilver">resilver</a>, <a class="reference external" href="#scrub">scrub</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>testing or debugging scan code</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=do not freeze scans, 1=freeze scans</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-scrub-min-time-ms">
<h3>zfs_scrub_min_time_ms<a class="headerlink" href="#zfs-scrub-min-time-ms" title="Permalink to this headline">¶</a></h3>
<p>Scrubs are processed by the sync thread. While scrubbing at least
<code class="docutils literal notranslate"><span class="pre">zfs_scrub_min_time_ms</span></code> time is spent working on a scrub between txg
syncs.</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_scrub_min_time_ms</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#scrub">scrub</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>milliseconds</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to (<a class="reference external" href="#zfs-txg-timeout">zfs_txg_timeout</a> - 1)</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>1,000</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-slow-io-events-per-second">
<h3>zfs_slow_io_events_per_second<a class="headerlink" href="#zfs-slow-io-events-per-second" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_slow_io_events_per_second</span></code> is a rate limit for slow I/O events.
Note that this should not be set below the <code class="docutils literal notranslate"><span class="pre">zed</span></code> thresholds (currently
10 checksums over 10 sec) or else <code class="docutils literal notranslate"><span class="pre">zed</span></code> may not trigger any action.</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_slow_io_events_per_second</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#vdev">vdev</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>uint</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>slow I/O events</td>
</tr>
<tr class="row-even"><td>Range</td>
<td><code class="docutils literal notranslate"><span class="pre">zed</span></code> threshold to MAX_UINT</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>20</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-min-ms-count">
<h3>zfs_vdev_min_ms_count<a class="headerlink" href="#zfs-vdev-min-ms-count" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_vdev_min_ms_count</span></code> is the minimum number of metaslabs to create
in a top-level vdev.</p>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_vdev_min_ms_count</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#metaslab">metaslab</a>, <a class="reference external" href="#vdev">vdev</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>metaslabs</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>16 to
<a class="reference external" href="#zfs-vdev-ms-count-limit">zfs_vdev_m
s_count_limit</a></td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>16</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>prior to creating a pool or adding a
top-level vdev</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="zfs-vdev-ms-count-limit">
<h3>zfs_vdev_ms_count_limit<a class="headerlink" href="#zfs-vdev-ms-count-limit" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">zfs_vdev_ms_count_limit</span></code> is the practical upper limit for the number
of metaslabs per top-level vdev.</p>
<table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">zfs_vdev_ms_count_limit</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#metaslab">metaslab</a>,
<a class="reference external" href="#vdev">vdev</a></td>
</tr>
<tr class="row-odd"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>metaslabs</td>
</tr>
<tr class="row-even"><td>Range</td>
<td><a class="reference external" href="#zfs-vdev-min-ms-count">zfs_vdev
_min_ms_count</a>
to 131,072</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>131,072</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>prior to creating a pool or adding a
top-level vdev</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>planned for v2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="spl-hostid">
<h3>spl_hostid<a class="headerlink" href="#spl-hostid" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">spl_hostid</span></code> is a unique system id number. It orginated in Sun’s
products where most systems had a unique id assigned at the factory.
This assignment does not exist in modern hardware.</div>
<div class="line">In ZFS, the hostid is stored in the vdev label and can be used to
determine if another system had imported the pool. When set
<code class="docutils literal notranslate"><span class="pre">spl_hostid</span></code> can be used to uniquely identify a system. By default
this value is set to zero which indicates the hostid is disabled. It
can be explicitly enabled by placing a unique non-zero value in the
file shown in <a class="reference external" href="#spl-hostid-path">spl_hostid_path</a></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">spl_hostid</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#hostid">hostid</a>, <a class="reference external" href="#MMP">MMP</a></td>
</tr>
<tr class="row-odd"><td>Kernel module</td>
<td>spl</td>
</tr>
<tr class="row-even"><td>When to change</td>
<td>to uniquely identify a system when vdevs can be
shared across multiple systems</td>
</tr>
<tr class="row-odd"><td>Data Type</td>
<td>ulong</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0=ignore hostid, 1 to 4,294,967,295 (32-bits or
0xffffffff)</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>prior to importing pool</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.1</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="spl-hostid-path">
<h3>spl_hostid_path<a class="headerlink" href="#spl-hostid-path" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">spl_hostid_path</span></code> is the path name for a file that can contain a
unique hostid. For testing purposes, <code class="docutils literal notranslate"><span class="pre">spl_hostid_path</span></code> can be
overridden by the ZFS_HOSTID environment variable.</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">spl_hostid_path</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#hostid">hostid</a>, <a class="reference external" href="#MMP">MMP</a></td>
</tr>
<tr class="row-odd"><td>Kernel module</td>
<td>spl</td>
</tr>
<tr class="row-even"><td>When to change</td>
<td>when creating a new ZFS distribution where the
default value is inappropriate</td>
</tr>
<tr class="row-odd"><td>Data Type</td>
<td>string</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>“/etc/hostid”</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>read-only, can only be changed prior to spl
module load</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.6.1</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="spl-kmem-alloc-max">
<h3>spl_kmem_alloc_max<a class="headerlink" href="#spl-kmem-alloc-max" title="Permalink to this headline">¶</a></h3>
<p>Large <code class="docutils literal notranslate"><span class="pre">kmem_alloc()</span></code> allocations fail if they exceed KMALLOC_MAX_SIZE,
as determined by the kernel source. Allocations which are marginally
smaller than this limit may succeed but should still be avoided due to
the expense of locating a contiguous range of free pages. Therefore, a
maximum kmem size with reasonable safely margin of 4x is set.
<code class="docutils literal notranslate"><span class="pre">kmem_alloc()</span></code> allocations larger than this maximum will quickly fail.
<code class="docutils literal notranslate"><span class="pre">vmem_alloc()</span></code> allocations less than or equal to this value will use
<code class="docutils literal notranslate"><span class="pre">kmalloc()</span></code>, but shift to <code class="docutils literal notranslate"><span class="pre">vmalloc()</span></code> when exceeding this value.</p>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="53%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">spl_kmem_alloc_max</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#memory">memory</a></td>
</tr>
<tr class="row-odd"><td>Kernel module</td>
<td>spl</td>
</tr>
<tr class="row-even"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>Data Type</td>
<td>uint</td>
</tr>
<tr class="row-even"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>KMALLOC_MAX_SIZE / 4</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.7.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="spl-kmem-alloc-warn">
<h3>spl_kmem_alloc_warn<a class="headerlink" href="#spl-kmem-alloc-warn" title="Permalink to this headline">¶</a></h3>
<p>As a general rule <code class="docutils literal notranslate"><span class="pre">kmem_alloc()</span></code> allocations should be small,
preferably just a few pages since they must by physically contiguous.
Therefore, a rate limited warning is printed to the console for any
<code class="docutils literal notranslate"><span class="pre">kmem_alloc()</span></code> which exceeds the threshold <code class="docutils literal notranslate"><span class="pre">spl_kmem_alloc_warn</span></code></p>
<p>The default warning threshold is set to eight pages but capped at 32K to
accommodate systems using large pages. This value was selected to be
small enough to ensure the largest allocations are quickly noticed and
fixed. But large enough to avoid logging any warnings when a allocation
size is larger than optimal but not a serious concern. Since this value
is tunable, developers are encouraged to set it lower when testing so
any new largish allocations are quickly caught. These warnings may be
disabled by setting the threshold to zero.</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">spl_kmem_alloc_warn</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#memory">memory</a></td>
</tr>
<tr class="row-odd"><td>Kernel module</td>
<td>spl</td>
</tr>
<tr class="row-even"><td>When to change</td>
<td>developers are encouraged lower when testing
so any new, large allocations are quickly
caught</td>
</tr>
<tr class="row-odd"><td>Data Type</td>
<td>uint</td>
</tr>
<tr class="row-even"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=disable the warnings,</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>32,768 (32 KiB)</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.7.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="spl-kmem-cache-expire">
<h3>spl_kmem_cache_expire<a class="headerlink" href="#spl-kmem-cache-expire" title="Permalink to this headline">¶</a></h3>
<p>Cache expiration is part of default illumos cache behavior. The idea is
that objects in magazines which have not been recently accessed should
be returned to the slabs periodically. This is known as cache aging and
when enabled objects will be typically returned after 15 seconds.</p>
<p>On the other hand Linux slabs are designed to never move objects back to
the slabs unless there is memory pressure. This is possible because
under Linux the cache will be notified when memory is low and objects
can be released.</p>
<p>By default only the Linux method is enabled. It has been shown to
improve responsiveness on low memory systems and not negatively impact
the performance of systems with more memory. This policy may be changed
by setting the <code class="docutils literal notranslate"><span class="pre">spl_kmem_cache_expire</span></code> bit mask as follows, both
policies may be enabled concurrently.</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">spl_kmem_cache_expire</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#memory">memory</a></td>
</tr>
<tr class="row-odd"><td>Kernel module</td>
<td>spl</td>
</tr>
<tr class="row-even"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>Data Type</td>
<td>bitmask</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0x01 - Aging (illumos), 0x02 - Low memory (Linux)</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>0x02</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.6.1</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="spl-kmem-cache-kmem-limit">
<h3>spl_kmem_cache_kmem_limit<a class="headerlink" href="#spl-kmem-cache-kmem-limit" title="Permalink to this headline">¶</a></h3>
<p>Depending on the size of a memory cache object it may be backed by
<code class="docutils literal notranslate"><span class="pre">kmalloc()</span></code> or <code class="docutils literal notranslate"><span class="pre">vmalloc()</span></code> memory. This is because the size of the
required allocation greatly impacts the best way to allocate the memory.</p>
<p>When objects are small and only a small number of memory pages need to
be allocated, ideally just one, then <code class="docutils literal notranslate"><span class="pre">kmalloc()</span></code> is very efficient.
However, allocating multiple pages with <code class="docutils literal notranslate"><span class="pre">kmalloc()</span></code> gets increasingly
expensive because the pages must be physically contiguous.</p>
<p>For this reason we shift to <code class="docutils literal notranslate"><span class="pre">vmalloc()</span></code> for slabs of large objects
which which removes the need for contiguous pages. <code class="docutils literal notranslate"><span class="pre">vmalloc()</span></code> cannot
be used in all cases because there is significant locking overhead
involved. This function takes a single global lock over the entire
virtual address range which serializes all allocations. Using slightly
different allocation functions for small and large objects allows us to
handle a wide range of object sizes.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">spl_kmem_cache_kmem_limit</span></code> value is used to determine this cutoff
size. One quarter of the kernel’s compiled PAGE_SIZE is used as the
default value because
<a class="reference external" href="#spl-kmem-cache-obj-per-slab">spl_kmem_cache_obj_per_slab</a> defaults
to 16. With these default values, at most four contiguous pages are
allocated.</p>
<table border="1" class="docutils">
<colgroup>
<col width="56%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">spl_kmem_cache_kmem_limit</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#memory">memory</a></td>
</tr>
<tr class="row-odd"><td>Kernel module</td>
<td>spl</td>
</tr>
<tr class="row-even"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>Data Type</td>
<td>uint</td>
</tr>
<tr class="row-even"><td>Units</td>
<td>pages</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>PAGE_SIZE / 4</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.7.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="spl-kmem-cache-max-size">
<h3>spl_kmem_cache_max_size<a class="headerlink" href="#spl-kmem-cache-max-size" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">spl_kmem_cache_max_size</span></code> is the maximum size of a kmem cache slab in
MiB. This effectively limits the maximum cache object size to
<code class="docutils literal notranslate"><span class="pre">spl_kmem_cache_max_size</span></code> /
<a class="reference external" href="#spl-kmem-cache-obj-per-slab">spl_kmem_cache_obj_per_slab</a> Kmem
caches may not be created with object sized larger than this limit.</p>
<table border="1" class="docutils">
<colgroup>
<col width="36%" />
<col width="64%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">spl_kmem_cache_max_size</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#memory">memory</a></td>
</tr>
<tr class="row-odd"><td>Kernel module</td>
<td>spl</td>
</tr>
<tr class="row-even"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>Data Type</td>
<td>uint</td>
</tr>
<tr class="row-even"><td>Units</td>
<td>MiB</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>4 for 32-bit kernel, 32 for 64-bit kernel</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.7.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="spl-kmem-cache-obj-per-slab">
<h3>spl_kmem_cache_obj_per_slab<a class="headerlink" href="#spl-kmem-cache-obj-per-slab" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">spl_kmem_cache_obj_per_slab</span></code> is the preferred number of objects per
slab in the kmem cache. In general, a larger value will increase the
caches memory footprint while decreasing the time required to perform an
allocation. Conversely, a smaller value will minimize the footprint and
improve cache reclaim time but individual allocations may take longer.</p>
<table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="43%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">spl_kmem_cache_obj_per_slab</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#memory">memory</a></td>
</tr>
<tr class="row-odd"><td>Kernel module</td>
<td>spl</td>
</tr>
<tr class="row-even"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>Data Type</td>
<td>uint</td>
</tr>
<tr class="row-even"><td>Units</td>
<td>kmem cache objects</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>8</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.7.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="spl-kmem-cache-obj-per-slab-min">
<h3>spl_kmem_cache_obj_per_slab_min<a class="headerlink" href="#spl-kmem-cache-obj-per-slab-min" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">spl_kmem_cache_obj_per_slab_min</span></code> is the minimum number of objects
allowed per slab. Normally slabs will contain
<a class="reference external" href="#spl-kmem-cache-obj-per-slab">spl_kmem_cache_obj_per_slab</a> objects
but for caches that contain very large objects it’s desirable to only
have a few, or even just one, object per slab.</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">spl_kmem_cache_obj_per_slab_min</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#memory">memory</a></td>
</tr>
<tr class="row-odd"><td>Kernel module</td>
<td>spl</td>
</tr>
<tr class="row-even"><td>When to change</td>
<td>debugging kmem cache operations</td>
</tr>
<tr class="row-odd"><td>Data Type</td>
<td>uint</td>
</tr>
<tr class="row-even"><td>Units</td>
<td>kmem cache objects</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.7.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="spl-kmem-cache-reclaim">
<h3>spl_kmem_cache_reclaim<a class="headerlink" href="#spl-kmem-cache-reclaim" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">spl_kmem_cache_reclaim</span></code> prevents Linux from being able to rapidly
reclaim all the memory held by the kmem caches. This may be useful in
circumstances where it’s preferable that Linux reclaim memory from some
other subsystem first. Setting <code class="docutils literal notranslate"><span class="pre">spl_kmem_cache_reclaim</span></code> increases the
likelihood out of memory events on a memory constrained system.</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">spl_kmem_cache_reclaim</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#memory">memory</a></td>
</tr>
<tr class="row-odd"><td>Kernel module</td>
<td>spl</td>
</tr>
<tr class="row-even"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0=enable rapid memory reclaim from kmem
caches, 1=disable rapid memory reclaim
from kmem caches</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="spl-kmem-cache-slab-limit">
<h3>spl_kmem_cache_slab_limit<a class="headerlink" href="#spl-kmem-cache-slab-limit" title="Permalink to this headline">¶</a></h3>
<p>For small objects the Linux slab allocator should be used to make the
most efficient use of the memory. However, large objects are not
supported by the Linux slab allocator and therefore the SPL
implementation is preferred. <code class="docutils literal notranslate"><span class="pre">spl_kmem_cache_slab_limit</span></code> is used to
determine the cutoff between a small and large object.</p>
<p>Objects of <code class="docutils literal notranslate"><span class="pre">spl_kmem_cache_slab_limit</span></code> or smaller will be allocated
using the Linux slab allocator, large objects use the SPL allocator. A
cutoff of 16 KiB was determined to be optimal for architectures using 4
KiB pages.</p>
<table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">spl_kmem_cache_slab_limit</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#memory">memory</a></td>
</tr>
<tr class="row-odd"><td>Kernel module</td>
<td>spl</td>
</tr>
<tr class="row-even"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>Data Type</td>
<td>uint</td>
</tr>
<tr class="row-even"><td>Units</td>
<td>bytes</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>16,384 (16 KiB) when kernel PAGE_SIZE =
4KiB, 0 for other PAGE_SIZE values</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.7.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="spl-max-show-tasks">
<h3>spl_max_show_tasks<a class="headerlink" href="#spl-max-show-tasks" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">spl_max_show_tasks</span></code> is the limit of tasks per pending list in each
taskq shown in <code class="docutils literal notranslate"><span class="pre">/proc/spl/taskq</span></code> and <code class="docutils literal notranslate"><span class="pre">/proc/spl/taskq-all</span></code>. Reading
the ProcFS files walks the lists with lock held and it could cause a
lock up if the list grow too large. If the list is larger than the
limit, the string `”(truncated)” is printed.</p>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">spl_max_show_tasks</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#taskq">taskq</a></td>
</tr>
<tr class="row-odd"><td>Kernel module</td>
<td>spl</td>
</tr>
<tr class="row-even"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>Data Type</td>
<td>uint</td>
</tr>
<tr class="row-even"><td>Units</td>
<td>tasks reported</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0 disables the limit, 1 to MAX_UINT</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>512</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.7.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="spl-panic-halt">
<h3>spl_panic_halt<a class="headerlink" href="#spl-panic-halt" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">spl_panic_halt</span></code> enables kernel panic upon assertion failures. When
not enabled, the asserting thread is halted to facilitate further
debugging.</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">spl_panic_halt</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#debug">debug</a>, <a class="reference external" href="#panic">panic</a></td>
</tr>
<tr class="row-odd"><td>Kernel module</td>
<td>spl</td>
</tr>
<tr class="row-even"><td>When to change</td>
<td>when debugging assertions and kernel core dumps
are desired</td>
</tr>
<tr class="row-odd"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0=halt thread upon assertion, 1=panic kernel
upon assertion</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="spl-taskq-kick">
<h3>spl_taskq_kick<a class="headerlink" href="#spl-taskq-kick" title="Permalink to this headline">¶</a></h3>
<p>Upon writing a non-zero value to <code class="docutils literal notranslate"><span class="pre">spl_taskq_kick</span></code>, all taskqs are
scanned. If any taskq has a pending task more than 5 seconds old, the
taskq spawns more threads. This can be useful in rare deadlock
situations caused by one or more taskqs not spawning a thread when it
should.</p>
<table border="1" class="docutils">
<colgroup>
<col width="45%" />
<col width="55%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">spl_taskq_kick</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#taskq">taskq</a></td>
</tr>
<tr class="row-odd"><td>Kernel module</td>
<td>spl</td>
</tr>
<tr class="row-even"><td>When to change</td>
<td>See description above</td>
</tr>
<tr class="row-odd"><td>Data Type</td>
<td>uint</td>
</tr>
<tr class="row-even"><td>Units</td>
<td>N/A</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="spl-taskq-thread-bind">
<h3>spl_taskq_thread_bind<a class="headerlink" href="#spl-taskq-thread-bind" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">spl_taskq_thread_bind</span></code> enables binding taskq threads to specific
CPUs, distributed evenly over the available CPUs. By default, this
behavior is disabled to allow the Linux scheduler the maximum
flexibility to determine where a thread should run.</p>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">spl_taskq_thread_bind</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#CPU">CPU</a>, <a class="reference external" href="#taskq">taskq</a></td>
</tr>
<tr class="row-odd"><td>Kernel module</td>
<td>spl</td>
</tr>
<tr class="row-even"><td>When to change</td>
<td>when debugging CPU scheduling options</td>
</tr>
<tr class="row-odd"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0=taskqs are not bound to specific CPUs,
1=taskqs are bound to CPUs</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>prior to loading spl kernel module</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="spl-taskq-thread-dynamic">
<h3>spl_taskq_thread_dynamic<a class="headerlink" href="#spl-taskq-thread-dynamic" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">spl_taskq_thread_dynamic</span></code> enables taskqs to set the TASKQ_DYNAMIC
flag will by default create only a single thread. New threads will be
created on demand up to a maximum allowed number to facilitate the
completion of outstanding tasks. Threads which are no longer needed are
promptly destroyed. By default this behavior is enabled but it can be d.</p>
<p>See also
<a class="reference external" href="#zfs-zil-clean-taskq-nthr-pct">zfs_zil_clean_taskq_nthr_pct</a>,
<a class="reference external" href="#zio-taskq-batch-pct">zio_taskq_batch_pct</a></p>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="62%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">spl_taskq_thread_dynamic</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#taskq">taskq</a></td>
</tr>
<tr class="row-odd"><td>Kernel module</td>
<td>spl</td>
</tr>
<tr class="row-even"><td>When to change</td>
<td>disable for performance analysis or
troubleshooting</td>
</tr>
<tr class="row-odd"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0=taskq threads are not dynamic, 1=taskq
threads are dynamically created and
destroyed</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>1</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>prior to loading spl kernel module</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="spl-taskq-thread-priority">
<h3>spl_taskq_thread_priority<a class="headerlink" href="#spl-taskq-thread-priority" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">spl_taskq_thread_priority</span></code> allows newly created taskq threads to
set a non-default scheduler priority. When enabled the priority
specified when a taskq is created will be applied to all threads
created by that taskq.</div>
<div class="line">When disabled all threads will use the default Linux kernel thread
priority.</div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">spl_taskq_thread_priority</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#CPU">CPU</a>, <a class="reference external" href="#taskq">taskq</a></td>
</tr>
<tr class="row-odd"><td>Kernel module</td>
<td>spl</td>
</tr>
<tr class="row-even"><td>When to change</td>
<td>when troubleshooting CPU
scheduling-related performance issues</td>
</tr>
<tr class="row-odd"><td>Data Type</td>
<td>boolean</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>0=taskq threads use the default Linux
kernel thread priority, 1=</td>
</tr>
<tr class="row-odd"><td>Default</td>
<td>1</td>
</tr>
<tr class="row-even"><td>Change</td>
<td>prior to loading spl kernel module</td>
</tr>
<tr class="row-odd"><td>Versions Affected</td>
<td>v0.7.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="spl-taskq-thread-sequential">
<h3>spl_taskq_thread_sequential<a class="headerlink" href="#spl-taskq-thread-sequential" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">spl_taskq_thread_sequential</span></code> is the number of items a taskq worker
thread must handle without interruption before requesting a new worker
thread be spawned. <code class="docutils literal notranslate"><span class="pre">spl_taskq_thread_sequential</span></code> controls how quickly
taskqs ramp up the number of threads processing the queue. Because Linux
thread creation and destruction are relatively inexpensive a small
default value has been selected. Thus threads are created aggressively,
which is typically desirable. Increasing this value results in a slower
thread creation rate which may be preferable for some configurations.</p>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">spl_taskq_thread_sequential</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#CPU">CPU</a>, <a class="reference external" href="#taskq">taskq</a></td>
</tr>
<tr class="row-odd"><td>Kernel module</td>
<td>spl</td>
</tr>
<tr class="row-even"><td>When to change</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-even"><td>Units</td>
<td>taskq items</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>1 to MAX_INT</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>4</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>Dynamic</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.7.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="spl-kmem-cache-kmem-threads">
<h3>spl_kmem_cache_kmem_threads<a class="headerlink" href="#spl-kmem-cache-kmem-threads" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">spl_kmem_cache_kmem_threads</span></code> shows the current number of
<code class="docutils literal notranslate"><span class="pre">spl_kmem_cache</span></code> threads. This task queue is responsible for
allocating new slabs for use by the kmem caches. For the majority of
systems and workloads only a small number of threads are required.</p>
<table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">spl_kmem_cache_kmem_threads</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#CPU">CPU</a>, <a class="reference external" href="#memory">memory</a></td>
</tr>
<tr class="row-odd"><td>Kernel module</td>
<td>spl</td>
</tr>
<tr class="row-even"><td>When to change</td>
<td>read-only</td>
</tr>
<tr class="row-odd"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-even"><td>Range</td>
<td>1 to MAX_INT</td>
</tr>
<tr class="row-odd"><td>Units</td>
<td>threads</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>4</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>read-only, can only be changed prior
to spl module load</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.7.0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="spl-kmem-cache-magazine-size">
<h3>spl_kmem_cache_magazine_size<a class="headerlink" href="#spl-kmem-cache-magazine-size" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">spl_kmem_cache_magazine_size</span></code> shows the current . Cache magazines are
an optimization designed to minimize the cost of allocating memory. They
do this by keeping a per-cpu cache of recently freed objects, which can
then be reallocated without taking a lock. This can improve performance
on highly contended caches. However, because objects in magazines will
prevent otherwise empty slabs from being immediately released this may
not be ideal for low memory machines.</p>
<p>For this reason spl_kmem_cache_magazine_size can be used to set a
maximum magazine size. When this value is set to 0 the magazine size
will be automatically determined based on the object size. Otherwise
magazines will be limited to 2-256 objects per magazine (eg per CPU).
Magazines cannot be disabled entirely in this implementation.</p>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">spl_kmem_cache_magazine_size</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tags</td>
<td><a class="reference external" href="#CPU">CPU</a>, <a class="reference external" href="#memory">memory</a></td>
</tr>
<tr class="row-odd"><td>Kernel module</td>
<td>spl</td>
</tr>
<tr class="row-even"><td>When to change</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>Data Type</td>
<td>int</td>
</tr>
<tr class="row-even"><td>Units</td>
<td>threads</td>
</tr>
<tr class="row-odd"><td>Range</td>
<td>0=automatically scale magazine size,
otherwise 2 to 256</td>
</tr>
<tr class="row-even"><td>Default</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Change</td>
<td>read-only, can only be changed prior
to spl module load</td>
</tr>
<tr class="row-even"><td>Versions Affected</td>
<td>v0.7.0</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index.html">
    <img class="logo" src="../_static//img/320px-Open-ZFS-Secondary-Logo-Colour-halfsize.png" alt="Logo"/>
    
  </a>
</p>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Getting Started/index.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Project and Community/index.html">Project and Community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Developer Resources/index.html">Developer Resources</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Performance and tuning</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Async Write.html">Async Writes</a></li>
<li class="toctree-l2"><a class="reference internal" href="ZFS Transaction Delay.html">ZFS Transaction Delay</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">ZFS on Linux Module Parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="ZIO Scheduler.html">ZFS I/O (ZIO) Scheduler</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Basics concepts/index.html">Basic concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../License.html">License</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Performance and tuning</a><ul>
      <li>Previous: <a href="ZFS Transaction Delay.html" title="previous chapter">ZFS Transaction Delay</a></li>
      <li>Next: <a href="ZIO Scheduler.html" title="next chapter">ZFS I/O (ZIO) Scheduler</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, OpenZFS.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/Performance and tuning/ZFS on Linux Module Parameters.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>